<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Samsung AI Experience Group Dashboard</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1a1a1a;
            color: #e1e1e1;
            overflow-x: hidden;
        }

        /* 스크롤바 스타일링 */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }

        .dashboard-container {
            display: flex;
            height: 100vh;
            align-items: stretch;
        }

        /* 사이드바 스타일 */
        .sidebar {
            width: 250px;
            background-color: #2a2a2a;
            color: #b1b1b1;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }



        .menu-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: #b1b1b1;
            text-decoration: none;
            transition: all 0.2s ease;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .menu-item:hover {
            background-color: #3a3a3a;
            color: #fff;
        }

        .menu-item.active {
            background-color: #4a4a4a;
            color: #fff;
        }

        .refresh-button {
            display: flex;
            align-items: center;
            padding: 12px 20px;
            color: #b1b1b1;
            text-decoration: none;
            transition: all 0.2s ease;
            font-size: 14px;
            cursor: pointer;
            user-select: none;
        }

        .refresh-button:hover {
            background-color: #3a3a3a;
            color: #fff;
        }

        .refresh-progress {
            position: absolute;
            bottom: -10px;
            left: 20px;
            right: 20px;
            height: 6px;
            background-color: #2a2a2a;
            border-radius: 3px;
            overflow: hidden;
            display: none;
        }

        .refresh-progress-bar {
            height: 100%;
            background-color: #4a9eff;
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .refresh-button {
            position: relative;
        }

        .menu-icon {
            width: 16px;
            height: 16px;
            margin-right: 12px;
            opacity: 0.7;
        }

        /* 메인 콘텐츠 영역 */
        .main-content {
            flex: 1;
            background-color: #1a1a1a;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #1a1a1a; /* 배경색 검정으로 변경 */
            padding: 20px 30px;
            height: 80px;
            box-sizing: border-box;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 헤더 아래 선에 여백 추가 */
        .header::after {
            content: '';
            position: absolute;
            left: 30px;
            right: 30px;
            bottom: 0;
            height: 1px;
            background-color: #3a3a3a;
        }



        .header-left h1 {
            color: #fff;
            font-size: 24px;
            font-weight: 600;
        }

        .content-area {
            padding: 30px;
            min-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        /* 기본 숨김 처리 */
        .content-section {
            display: none;
        }

        .content-section.active {
            display: block;
        }

        /* Overview 페이지 스타일 */
        .overview-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .overview-stat-box {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 25px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .overview-stat-box:hover {
            background-color: #3a3a3a;
            border-color: #4a4a4a;
        }

        .overview-stat-box.clickable {
            cursor: pointer;
        }

        .overview-stat-box.selected {
            background-color: #3a3a3a;
            border-color: #5a9eff;
            box-shadow: 0 0 10px rgba(90, 158, 255, 0.3);
        }

        .overview-stat-box.selected .stat-number,
        .overview-stat-box.selected .stat-label,
        .overview-stat-box.selected .stat-description {
            color: white;
        }

        .overview-stat-box .stat-number {
            font-size: 36px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
        }

        .overview-stat-box .stat-label {
            font-size: 16px;
            font-weight: 600;
            color: #e1e1e1;
            margin-bottom: 4px;
        }

        .overview-stat-box .stat-description {
            font-size: 12px;
            color: #b1b1b1;
        }

        .overview-chart-container {
            background-color: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .chart-header h3 {
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            background-color: transparent;
        }

        .chart-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .filter-period-display {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px 16px;
            margin-right: 8px;
            min-width: 220px;
        }

        .filter-period-display span {
            color: #ff9800;
            font-size: 14px;
            font-weight: 600;
        }

        .chart-btn {
            background-color: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #b1b1b1;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .chart-btn:hover {
            background-color: #4a4a4a;
            color: #fff;
        }

        .chart-btn.active {
            background-color: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .overview-member-details {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            overflow: hidden;
        }

        .member-details-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .member-details-header h3 {
            font-size: 18px;
            font-weight: 600;
        }



        .member-list {
            display: grid;
            gap: 0;
        }

        .member-list-header {
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            padding: 12px 20px;
            background-color: #2a2a2a;
            color: #b1b1b1;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            border-bottom: 2px solid #3a3a3a;
        }

        .member-item {
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            align-items: center;
            padding: 12px 20px;
            background-color: #1a1a1a;
            border-bottom: 1px solid #3a3a3a;
            font-size: 14px;
        }

        .member-item:hover {
            background-color: #2a2a2a;
        }

        .member-item:last-child {
            border-bottom: none;
        }

        .member-date {
            color: #b1b1b1;
            font-size: 13px;
        }

        .member-email {
            color: #b1b1b1;
        }

        .clickable-email {
            color: #4a9eff;
            cursor: pointer;
            text-decoration: none;
            transition: color 0.2s ease;
        }

        .clickable-email:hover {
            color: #2196f3;
            text-decoration: underline;
        }

        .member-type {
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .member-type.active {
            background-color: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }

        .member-type.inactive {
            background-color: rgba(255, 152, 0, 0.2);
            color: #ff9800;
        }

        .member-kind {
            color: #e1e1e1;
            font-size: 13px;
        }

        .member-request {
            color: #fff;
            font-weight: 500;
        }

        .member-spend {
            color: #4a9eff;
            font-weight: 600;
        }

        /* 활동리스트 페이지네이션 스타일 */
        .activity-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
        }

        .activity-pagination button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .activity-pagination button:hover {
            background: #4a4a4a;
        }

        .activity-pagination button.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
        }

        .activity-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .activity-pagination .page-info {
            color: #b1b1b1;
            font-size: 12px;
            margin: 0 10px;
        }

        .activity-page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }

        .activity-page-size-selector select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }
        
        /* 사용자별 누적 사용량 정보 페이지네이션 스타일 */
        .user-cumulative-pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            padding: 15px 20px;
            background-color: #2a2a2a;
            border-top: 1px solid #3a3a3a;
        }
        
        .user-cumulative-pagination button {
            background: #3a3a3a;
            color: #e1e1e1;
            border: 1px solid #4a4a4a;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .user-cumulative-pagination button:hover:not(:disabled) {
            background: #4a4a4a;
            border-color: #5a5a5a;
        }
        
        .user-cumulative-pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .user-cumulative-pagination .page-info {
            color: #b1b1b1;
            font-size: 14px;
            min-width: 120px;
            text-align: center;
        }
        
        .user-cumulative-page-size-selector {
            display: flex;
            align-items: center;
        }

        /* 차트 선택기 스타일 */
        .chart-selector {
            margin-bottom: 20px;
        }

        .chart-selector select {
            padding: 10px 16px;
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            color: #e1e1e1;
            font-size: 14px;
            cursor: pointer;
            min-width: 250px;
            transition: all 0.3s ease;
        }

        .chart-selector select:hover {
            border-color: #4a9eff;
        }

        .chart-selector select:focus {
            outline: none;
            border-color: #4a9eff;
            box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.2);
        }

        .chart-content {
            display: none;
            background-color: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 0 6px 6px 6px;
            padding: 20px;
        }

        .chart-content.active {
            display: block;
        }

        .user-cumulative-page-size-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .user-cumulative-page-size-selector select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Members 페이지네이션 스타일 (All Raw Events와 동일) */
        #members-pagination button {
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin: 0 2px;
            transition: all 0.2s ease;
        }

        #members-pagination button:hover {
            background: #4a4a4a;
            border-color: #5a5a5a;
        }

        #members-pagination button.active {
            background: #4a9eff;
            border-color: #4a9eff;
            color: white;
            font-weight: 600;
        }

        #members-pagination span {
            color: #7a7a7a;
            padding: 0 5px;
        }

        /* 필터 및 검색 영역 */
        .filter-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 15px 0;
            border-bottom: 1px solid #3a3a3a;
        }

        /* Members 섹션에서 구분선 제거 및 간격 축소 */
        #members .filter-controls {
            border-bottom: none;
            margin-bottom: 15px;
            padding: 10px 0;
        }

        .filter-controls         .chart-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .date-picker input[type="date"] {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            padding: 8px 12px;
            color: #fff;
            font-size: 14px;
        }

        /* 달력 아이콘 색상 변경 */
        .date-picker input[type="date"]::-webkit-calendar-picker-indicator {
            filter: invert(1) brightness(1.5) sepia(1) saturate(5) hue-rotate(45deg);
            cursor: pointer;
        }

        .date-picker input[type="date"]::-moz-calendar-picker-indicator {
            filter: invert(1) brightness(1.5) sepia(1) saturate(5) hue-rotate(45deg);
            cursor: pointer;
        }

        .date-picker span {
            color: #ccc;
            font-weight: 500;
        }

        .filter-controls .chart-btn {
            min-width: 40px;
        }

        /* 데이터 로딩 버튼 스타일 */
        .data-loading-btn {
            background: linear-gradient(135deg, #4a9eff, #007bff);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(74, 158, 255, 0.3);
        }

        .data-loading-btn:hover {
            background: linear-gradient(135deg, #007bff, #0056b3);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(74, 158, 255, 0.4);
        }

        .data-loading-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(74, 158, 255, 0.3);
        }

        .data-loading-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .date-filter-btn {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e1e1e1;
            padding: 6px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .date-filter-btn:hover {
            background-color: #3a3a3a;
        }

        .analytics-btn {
            background: transparent;
            border: 1px solid #4a4a4a;
            color: #e1e1e1;
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.2s;
            height: 32px;
        }

        .analytics-btn:hover {
            background-color: #2a2a2a;
        }

        /* 배지 스타일 */
        .role-badge {
            background-color: #3a3a3a;
            color: #e1e1e1;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            display: inline-block;
        }

        .role-badge.admin {
            background-color: #4a9eff;
            color: white;
        }

        /* Members 페이지 스타일 */
        .data-table {
            background-color: #1a1a1a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            overflow: hidden;
            width: 100%;
        }

        .table-header {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 2fr 2fr 1fr 1fr 1fr 0.5fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        .table-row {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 2fr 2fr 1fr 1fr 1fr 0.5fr;
            gap: 20px;
            align-items: center;
            font-size: 14px;
            background-color: #1a1a1a;
        }

        .table-row:hover {
            background-color: #2a2a2a;
        }

        .table-row:last-child {
            border-bottom: none;
        }

        /* Usage 페이지 스타일 */
        .usage-cards {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin-bottom: 30px;
        }

        .usage-card {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #3a3a3a;
        }

        .usage-card-number {
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            margin-bottom: 8px;
        }

        .usage-card-label {
            color: #b1b1b1;
            font-size: 14px;
        }

        .search-box {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            padding: 8px 12px;
            color: #e1e1e1;
            font-size: 14px;
            width: 250px;
        }

        .search-container {
            position: relative;
            display: inline-block;
        }

        .search-clear-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #f44336;
            cursor: pointer;
            padding: 4px;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s ease;
        }

        .search-clear-btn:hover {
            background-color: #f44336;
            color: white;
        }

        .search-clear-btn:active {
            background-color: #d32f2f;
            color: white;
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            margin-top: 2px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #3a3a3a;
            transition: background-color 0.2s ease;
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item:hover {
            background-color: #3a3a3a;
        }

        .autocomplete-item.selected {
            background-color: #4a9eff;
            color: white;
        }

        .autocomplete-item .user-name {
            font-weight: 600;
            color: #e1e1e1;
            font-size: 14px;
            margin-bottom: 2px;
        }

        .autocomplete-item .user-email {
            color: #b1b1b1;
            font-size: 12px;
        }

        .autocomplete-item.selected .user-name,
        .autocomplete-item.selected .user-email {
            color: white;
        }

        .user-cumulative-info {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }

        .user-cumulative-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            font-size: 18px;
            font-weight: 600;
        }

        .user-cumulative-table {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        /* Overview 활동 테이블 스타일 */
        .overview-activity-header {
            background-color: #1a1a1a;
            color: #fff;
            padding: 15px 20px;
            margin: 0;
            border-bottom: 1px solid #3a3a3a;
            font-size: 18px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .overview-activity-table {
            background-color: #2a2a2a;
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr 1fr;
            gap: 20px;
            font-size: 12px;
            font-weight: 600;
            color: #b1b1b1;
            text-transform: uppercase;
        }

        /* Export CSV 버튼 호버 효과 */
        .export-csv-btn:hover {
            background-color: #45a049 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .export-csv-btn:active {
            transform: translateY(0);
            box-shadow: 0 1px 2px rgba(0,0,0,0.2);
        }

        .user-cumulative-row {
            padding: 15px 20px;
            border-bottom: 1px solid #3a3a3a;
            display: grid;
            grid-template-columns: 1.5fr 2fr 1fr 1.5fr 1fr 1fr;
            gap: 20px;
            align-items: center;
            font-size: 14px;
            background-color: #1a1a1a;
        }

        .user-cumulative-row:hover {
            background-color: #2a2a2a;
        }

        .user-cumulative-row:last-child {
            border-bottom: none;
        }

        .user-email {
            color: #4a9eff;
            font-weight: 600;
        }

        /* Settings 페이지 스타일 */
        .settings-section {
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            margin-bottom: 20px;
            overflow: hidden;
        }

        .accordion-header {
            background-color: #2a2a2a;
            padding: 20px;
            border-bottom: 1px solid #3a3a3a;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .accordion-header:hover {
            background-color: #3a3a3a;
        }

        .accordion-title {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
        }

        .accordion-arrow {
            font-size: 16px;
            color: #b1b1b1;
            transition: transform 0.2s ease;
        }

        .accordion-content {
            display: none;
            padding: 20px;
            background-color: #1a1a1a;
        }

        .accordion-content.active {
            display: block;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #3a3a3a;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            color: #fff;
            margin-bottom: 4px;
        }

        .setting-description {
            color: #7a7a7a;
            font-size: 12px;
        }

        .toggle-switch {
            width: 44px;
            height: 24px;
            background-color: #4a9eff;
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .toggle-switch.off {
            background-color: #5a5a5a;
        }

        .toggle-switch::after {
            content: '';
            width: 20px;
            height: 20px;
            background-color: white;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            right: 2px;
            transition: all 0.2s ease;
        }

        .toggle-switch.off::after {
            right: 22px;
        }

        .setting-select {
            background: #3a3a3a;
            color: #fff;
            border: 1px solid #4a4a4a;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
        }

        .export-btn {
            background: #4a9eff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all 0.2s;
        }

        .export-btn:hover {
            background: #3a8edf;
        }

        /* 반응형 */
        @media (max-width: 768px) {
            .sidebar {
                width: 70px;
            }
           
            .menu-text {
                display: none;
            }

            .overview-stats {
                grid-template-columns: 1fr;
            }

            .member-item,
            .member-list-header,
            .table-row,
            .table-header,
            .user-cumulative-row,
            .user-cumulative-table {
                grid-template-columns: 1fr;
                gap: 8px;
            }
        }

        /* 차트 검색창 스타일 개선 */
        #chart-search-input {
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #chart-search-input:focus {
            border-color: #4a9eff !important;
            box-shadow: 0 0 0 2px rgba(74, 158, 255, 0.1) !important;
            outline: none;
        }

        /* 검색 clear 버튼 스타일 */
        .search-clear-btn:hover {
            background-color: #3a3a3a !important;
            color: #e1e1e1 !important;
        }

        /* 데이터리스트 드롭다운 스타일 */
        #heatmap-emails-datalist {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background-color: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        /* 시간 입력 필드 스타일링 */
        input[type="time"]::-webkit-calendar-picker-indicator {
            background-color: transparent;
            color: #fff;
            cursor: pointer;
            filter: invert(1) brightness(1.5);
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }

        input[type="time"]::-webkit-calendar-picker-indicator:hover {
            opacity: 1;
        }

        input[type="time"]::-webkit-datetime-edit {
            color: #e1e1e1;
            font-weight: 500;
        }

        input[type="time"]::-webkit-datetime-edit-fields-wrapper {
            color: #e1e1e1;
        }

        input[type="time"]::-webkit-datetime-edit-hour-field,
        input[type="time"]::-webkit-datetime-edit-minute-field,
        input[type="time"]::-webkit-datetime-edit-ampm-field {
            color: #e1e1e1;
            background: transparent;
        }

        input[type="time"]::-webkit-datetime-edit-text {
            color: #e1e1e1;
        }

        /* 시간 드롭다운 스크롤 스타일 */
        #email-hour-select,
        #email-minute-select,
        #new-schedule-hour,
        #new-schedule-minute {
            scrollbar-width: thin;
            scrollbar-color: #3a3a3a #1a1a1a;
        }

        #email-hour-select::-webkit-scrollbar,
        #email-minute-select::-webkit-scrollbar,
        #new-schedule-hour::-webkit-scrollbar,
        #new-schedule-minute::-webkit-scrollbar {
            width: 8px;
        }

        #email-hour-select::-webkit-scrollbar-track,
        #email-minute-select::-webkit-scrollbar-track,
        #new-schedule-hour::-webkit-scrollbar-track,
        #new-schedule-minute::-webkit-scrollbar-track {
            background: #1a1a1a;
            border-radius: 4px;
        }

        #email-hour-select::-webkit-scrollbar-thumb,
        #email-minute-select::-webkit-scrollbar-thumb,
        #new-schedule-hour::-webkit-scrollbar-thumb,
        #new-schedule-minute::-webkit-scrollbar-thumb {
            background: #3a3a3a;
            border-radius: 4px;
        }

        #email-hour-select::-webkit-scrollbar-thumb:hover,
        #email-minute-select::-webkit-scrollbar-thumb:hover,
        #new-schedule-hour::-webkit-scrollbar-thumb:hover,
        #new-schedule-minute::-webkit-scrollbar-thumb:hover {
            background: #4a4a4a;
        }

        /* 드롭다운 옵션 스타일 */
        #email-hour-select option,
        #email-minute-select option,
        #new-schedule-hour option,
        #new-schedule-minute option {
            background-color: #2a2a2a;
            color: #e1e1e1;
            padding: 8px 12px;
        }

        #email-hour-select option:hover,
        #email-minute-select option:hover,
        #new-schedule-hour option:hover,
        #new-schedule-minute option:hover {
            background-color: #3a3a3a;
        }

        #email-hour-select option:checked,
        #email-minute-select option:checked,
        #new-schedule-hour option:checked,
        #new-schedule-minute option:checked {
            background-color: #4a9eff;
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="dashboard-container">
        <!-- 사이드바 -->
        <nav class="sidebar">
            <div style="height: 20px;"></div>
            <a href="javascript:void(0)" class="refresh-button" onclick="handleRefreshClick()">
                <span class="menu-icon">🔄</span>
                <span class="menu-text">사용자 정보 업데이트</span>
                <div class="refresh-progress">
                    <div class="refresh-progress-bar"></div>
                </div>
            </a>
            <div style="height: 1px; background-color: #3a3a3a; margin: 10px 20px;"></div>
            <a href="javascript:void(0)" class="menu-item active" data-section="overview">
                <span class="menu-icon">📊</span>
                <span class="menu-text">Overview</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="settings">
                <span class="menu-icon">⚙️</span>
                <span class="menu-text">Settings</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="members">
                <span class="menu-icon">👥</span>
                <span class="menu-text">Members</span>
            </a>
            <a href="javascript:void(0)" class="menu-item" data-section="usage">
                <span class="menu-icon">📈</span>
                <span class="menu-text">Usage</span>
            </a>
        </nav>

        <!-- 메인 콘텐츠 -->
        <main class="main-content">
            <header class="header">
                <div class="header-left">
                    <h1 id="page-title">Dashboard Overview</h1>
                </div>
                <div class="header-right">
                    <!-- Clear Cache button and Ready status removed -->
                </div>
            </header>

            <div class="content-area">
                <!-- Overview 섹션 -->
                <div id="overview" class="content-section active">
                    <!-- 2.1.1 필터링 기능 -->
                    <div class="filter-controls">
                        <div class="chart-controls">
                            <div class="filter-period-display">
                                <span id="filter-period-text">2025-08-03 ~ 2025-08-03</span>
                            </div>
                            <button class="chart-btn" data-days="1">1d</button>
                            <button class="chart-btn" data-days="7">7d</button>
                            <button class="chart-btn active" data-days="30">30d</button>
                            <div class="date-picker">
                                <input type="date" id="start-date" />
                                <span>~</span>
                                <input type="date" id="end-date" />
                                <button class="analytics-btn" onclick="applyDateFilter()">적용</button>
                            </div>
                        </div>

                    </div>

                    <!-- 사용량 개요 카드 (Usage에서 이동) -->
                    <div class="usage-cards">
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">선택된 기간 내 실제 활동한 사용자 수</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">선택된 기간 내 에이전트 편집 라인 수</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">선택된 기간 내 수락된 탭 수</div>
                        </div>
                        <div class="usage-card">
                            <div class="usage-card-number">-</div>
                            <div class="usage-card-label">선택된 기간 내 채팅 수</div>
                        </div>
                    </div>

                    <!-- 그래프 영역 -->
                    <div class="overview-chart-container">
                        <div class="chart-header">
                            <div class="chart-selector">
                                <select id="chartSelect" onchange="handleChartChange(this.value)">
                                    <option value="activity-trend">📈 일별 활동 추이</option>
                                    <option value="model-distribution">📊 모델 사용 분포</option>
                                    <option value="cost-trend">💰 비용 추이</option>
                                    <option value="activity-type">📊 활동 유형 분포</option>
                                    <option value="user-heatmap">🔥 사용자 활동 히트맵</option>
                                    <option value="cost-efficiency">📊 비용 효율성 분석</option>
                                    <option value="model-preference">🎯 모델 선호도</option>
                                    <option value="user-performance">🏆 사용자별 성과</option>
                                    <option value="activity-type-detailed">📈 활동 유형 상세</option>
                                </select>
                            </div>
                            <!-- 차트별 검색창 (기본적으로 숨김) -->
                            <div id="chart-search-container" class="chart-search" style="display: none; margin-top: 10px;">
                                <div class="search-container">
                                    <div style="position: relative; display: flex; align-items: center; max-width: 300px;">
                                        <span style="position: absolute; left: 12px; color: #7a7a7a; font-size: 14px;">🔍</span>
                                        <input type="text" class="search-box" id="chart-search-input" placeholder="Search..." onkeyup="handleChartSearch(this.value)" oninput="toggleSearchClearBtn('chart-search-input')" onclick="showChartAutocomplete('chart-search-input')" onfocus="showChartAutocomplete('chart-search-input')" autocomplete="off" style="padding-left: 35px; border-radius: 8px; border: 1px solid #3a3a3a; background-color: #2a2a2a; color: #e1e1e1; padding-right: 35px;">
                                        <button class="search-clear-btn" id="chart-search-input-clear" onclick="clearChartSearch('chart-search-input')" style="display: none; position: absolute; right: 8px; background: none; border: none; color: #7a7a7a; font-size: 18px; cursor: pointer; padding: 4px; border-radius: 50%; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center;">×</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="activity-trend-chart" class="chart-content active">
                            <canvas id="overviewChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="model-distribution-chart" class="chart-content">
                            <canvas id="modelDistributionChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="cost-trend-chart" class="chart-content">
                            <canvas id="costTrendChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="activity-type-chart" class="chart-content">
                            <canvas id="activityTypeChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="user-heatmap-chart" class="chart-content">
                            <canvas id="userHeatmapChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="cost-efficiency-chart" class="chart-content">
                            <canvas id="costEfficiencyChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="model-preference-chart" class="chart-content">
                            <canvas id="modelPreferenceChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="user-performance-chart" class="chart-content">
                            <canvas id="userPerformanceChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                        <div id="activity-type-detailed-chart" class="chart-content">
                            <canvas id="activityTypeDetailedChart" style="width: 100%; height: 300px;"></canvas>
                        </div>
                    </div>

                    <!-- 2.1.2 통계 카드 -->
                    <div class="overview-stats">
                        <div class="overview-stat-box clickable" data-type="total" onclick="filterOverviewMembersByType('total')">
                            <div class="stat-number">-</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #4a9eff; color: white;">전체 멤버</span>
                            </div>
                            <div class="stat-description">모든 멤버의 활동 기록</div>
                        </div>
                        <div class="overview-stat-box clickable" data-type="active" onclick="filterOverviewMembersByType('active')">
                            <div class="stat-number">-</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #4caf50; color: white;">활성 멤버</span>
                            </div>
                            <div class="stat-description">활성 멤버의 활동 기록</div>
                        </div>
                        <div class="overview-stat-box clickable" data-type="inactive" onclick="filterOverviewMembersByType('inactive')">
                            <div class="stat-number">-</div>
                            <div class="stat-label">
                                <span class="role-badge" style="background-color: #ff9800; color: white;">비활성 멤버</span>
                            </div>
                            <div class="stat-description">비활성 멤버의 활동 기록</div>
                        </div>
                    </div>

                    <!-- 멤버 세부 리스트 -->
                    <div class="overview-member-details">
                        <div class="overview-activity-header">📋 활동 리스트</div>
                        <div class="overview-activity-table">
                            <div>마지막 활동</div>
                            <div>사용자</div>
                            <div>상태</div>
                            <div>활동 유형</div>
                            <div>요청 수</div>
                            <div>비용</div>
                            <div>제한</div>
                        </div>
                        <div id="overview-activity-container">
                            <!-- 동적으로 생성될 테이블 내용 -->
                            <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                                데이터를 불러오는 중...
                            </div>
                        </div>
                        
                        <!-- Overview 활동리스트 페이지네이션 (Members 스타일) -->
                        <div id="overview-activity-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>
                </div>

                <!-- Members 섹션 -->
                <div id="members" class="content-section">
                    <div class="filter-controls" style="margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                            <div style="color: #e1e1e1; font-size: 14px; font-weight: 500; margin-left: 20px;">
                                Fast Requests last reset on: <span id="fast-requests-reset-date" style="color: #ffffff; font-weight: 600;">2025년 7월 22일</span> (오늘 날짜: <span id="today-date" style="color: #ff9800; font-weight: 600;">2025-08-03</span>)
                            </div>
                            <div style="display: flex; align-items: center; gap: 15px; margin-left: auto;">
                                <div class="search-container">
                                    <div style="position: relative; display: flex; align-items: center;">
                                        <span style="position: absolute; left: 12px; color: #7a7a7a; font-size: 14px;">🔍</span>
                                        <input type="text" class="search-box" id="members-search" placeholder="Search name, email..." onkeyup="filterMembers(this.value)" oninput="toggleSearchClearBtn('members-search'); showAutocomplete('members-search')" onclick="showAutocomplete('members-search')" onfocus="showAutocomplete('members-search')" autocomplete="off" style="padding-left: 35px;">
                                        <button class="search-clear-btn" id="members-search-clear" onclick="clearSearch('members-search')" style="display: none;">×</button>
                                    </div>
                                    <div id="members-autocomplete" class="autocomplete-dropdown" style="display: none;"></div>
                                </div>
                                <button class="export-csv-btn" onclick="exportMembersToCSV()" style="background: #4caf50; color: white; border: none; padding: 8px 16px; border-radius: 4px; font-size: 14px; font-weight: 500; cursor: pointer; transition: background-color 0.2s ease;">
                                    📊 Export CSV
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="data-table" id="members-table-container">
                        <!-- 동적으로 생성될 테이블 헤더와 내용 -->
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            실제 멤버 데이터를 로딩하는 중...
                        </div>
                    </div>
                    
                    <!-- Members 페이지네이션 (All Raw Events 스타일) -->
                    <div id="members-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                        <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                    </div>
                </div>

                <!-- Usage 섹션 -->
                <div id="usage" class="content-section">
                    <!-- 날짜 필터와 검색 -->
                    <div class="filter-controls">
                        <div class="chart-controls">
                            <div class="filter-period-display">
                                <span id="usage-filter-period-text">2025-08-03 ~ 2025-08-03</span>
                            </div>
                            <button class="chart-btn" data-days="1">1d</button>
                            <button class="chart-btn" data-days="7">7d</button>
                            <button class="chart-btn active" data-days="30">30d</button>
                            <div class="date-picker">
                                <input type="date" id="usage-start-date" />
                                <span>~</span>
                                <input type="date" id="usage-end-date" />
                                <button class="analytics-btn" onclick="applyUsageDateFilter()">적용</button>
                            </div>
                        </div>
                        <div>
                            <div class="search-container">
                                <div style="position: relative; display: flex; align-items: center;">
                                    <span style="position: absolute; left: 12px; color: #7a7a7a; font-size: 14px;">🔍</span>
                                    <input type="text" class="search-box" id="usage-search" placeholder="Search name, email..." onkeyup="filterUsageMembers(this.value)" oninput="toggleSearchClearBtn('usage-search'); showAutocomplete('usage-search')" onclick="showAutocomplete('usage-search')" onfocus="showAutocomplete('usage-search')" autocomplete="off" style="padding-left: 35px;">
                                    <button class="search-clear-btn" id="usage-search-clear" onclick="clearSearch('usage-search')" style="display: none;">×</button>
                                </div>
                                <div id="usage-autocomplete" class="autocomplete-dropdown" style="display: none;"></div>
                            </div>
                        </div>
                    </div>

                    <!-- 사용자별 누적 정보 -->
                    <div class="user-cumulative-info">
                        <div class="user-cumulative-header">📊 사용자별 누적 사용량 정보</div>
                        <div class="user-cumulative-table">
                            <div>NAME</div>
                            <div>EMAIL</div>
                            <div>ROLE</div>
                            <div>REQUEST</div>
                            <div>SPEND</div>
                            <div>LAST ACT</div>
                        </div>
                        <div id="user-cumulative-container">
                            <!-- 동적으로 생성될 테이블 내용 -->
                            <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                                데이터를 불러오는 중...
                            </div>
                        </div>
                        
                        <!-- 사용자별 누적 사용량 정보 페이지네이션 (All Raw Events 스타일) -->
                        <div id="user-cumulative-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>

                    <!-- All Raw Events 테이블 -->
                    <div class="user-cumulative-info">
                        <div class="user-cumulative-header">📋 All Raw Events</div>
                        <div class="user-cumulative-table">
                            <div>DATE</div>
                            <div>USER</div>
                            <div>KIND</div>
                            <div>MAX_MODEL</div>
                            <div>MODEL</div>
                            <div>COST</div>
                        </div>
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            데이터를 불러오는 중...
                        </div>
                        
                        <!-- 필터링된 이벤트 페이지네이션 -->
                        <div class="filtered-events-pagination" style="display: none; padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; text-align: center;">
                            <!-- 숫자 페이지 버튼들이 동적으로 생성됨 -->
                        </div>
                    </div>
                </div>

                <!-- Settings 섹션 -->
                <div id="settings" class="content-section">
                    <!-- 활성 기간 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">활성 기간 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">활성 상태 자동 전환</div>
                                    <div class="setting-description">지정된 기간 동안 활동이 없으면 자동으로 비활성 상태로 전환됩니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">비활성 전환 기간</div>
                                    <div class="setting-description">활동이 없을 경우 비활성으로 전환되는 기간</div>
                                </div>
                                <select class="setting-select">
                                    <option>7일</option>
                                    <option>14일</option>
                                    <option selected>30일</option>
                                    <option>60일</option>
                                    <option>90일</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">활성 상태 알림</div>
                                    <div class="setting-description">비활성 전환 전 사용자에게 알림을 발송합니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">알림 발송 시점</div>
                                    <div class="setting-description">비활성 전환 몇 일 전에 알림을 발송할지 설정</div>
                                </div>
                                <select class="setting-select">
                                    <option>1일 전</option>
                                    <option selected>3일 전</option>
                                    <option>7일 전</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <!-- Email Report 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">Email Report 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <!-- 예약 메일 발송 관리 -->
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">예약 메일 발송 관리</div>
                                    <div class="setting-description">예약된 메일의 자동 발송을 관리합니다</div>
                                </div>
                                <div class="toggle-switch" onclick="toggleSwitch(this)"></div>
                            </div>

                            <!-- 발송 주기 -->
                            <div class="setting-item" id="email-frequency-setting">
                                <div>
                                    <div class="setting-label">발송 주기</div>
                                    <div class="setting-description">리포트를 발송할 주기를 선택하세요</div>
                                </div>
                                <select class="setting-select" id="email-frequency-select" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                    <option value="daily">매일</option>
                                    <option value="weekly" selected>매주</option>
                                    <option value="monthly">매월</option>
                                </select>
                            </div>

                            <!-- 발송 시간 설정 -->
                            <div class="setting-item" id="email-time-setting">
                                <div>
                                    <div class="setting-label">발송 시간 설정</div>
                                    <div class="setting-description">리포트를 발송할 구체적인 시간을 설정하세요</div>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select id="email-hour-select" style="
                                        background-color: transparent;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 8px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        font-family: inherit;
                                        transition: background-color 0.2s ease;
                                        min-width: 120px;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="updateTimeInput()">
                                        <option value="00">오전 12시</option>
                                        <option value="01">오전 1시</option>
                                        <option value="02">오전 2시</option>
                                        <option value="03">오전 3시</option>
                                        <option value="04">오전 4시</option>
                                        <option value="05">오전 5시</option>
                                        <option value="06">오전 6시</option>
                                        <option value="07">오전 7시</option>
                                        <option value="08">오전 8시</option>
                                        <option value="09" selected>오전 9시</option>
                                        <option value="10">오전 10시</option>
                                        <option value="11">오전 11시</option>
                                        <option value="12">오후 12시</option>
                                        <option value="13">오후 1시</option>
                                        <option value="14">오후 2시</option>
                                        <option value="15">오후 3시</option>
                                        <option value="16">오후 4시</option>
                                        <option value="17">오후 5시</option>
                                        <option value="18">오후 6시</option>
                                        <option value="19">오후 7시</option>
                                        <option value="20">오후 8시</option>
                                        <option value="21">오후 9시</option>
                                        <option value="22">오후 10시</option>
                                        <option value="23">오후 11시</option>
                                    </select>
                                    <select id="email-minute-select" style="
                                        background-color: transparent;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 8px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        font-family: inherit;
                                        transition: background-color 0.2s ease;
                                        min-width: 80px;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="updateTimeInput()">
                                        <option value="00" selected>00분</option>
                                        <option value="01">01분</option>
                                        <option value="02">02분</option>
                                        <option value="03">03분</option>
                                        <option value="04">04분</option>
                                        <option value="05">05분</option>
                                        <option value="06">06분</option>
                                        <option value="07">07분</option>
                                        <option value="08">08분</option>
                                        <option value="09">09분</option>
                                        <option value="10">10분</option>
                                        <option value="11">11분</option>
                                        <option value="12">12분</option>
                                        <option value="13">13분</option>
                                        <option value="14">14분</option>
                                        <option value="15">15분</option>
                                        <option value="16">16분</option>
                                        <option value="17">17분</option>
                                        <option value="18">18분</option>
                                        <option value="19">19분</option>
                                        <option value="20">20분</option>
                                        <option value="21">21분</option>
                                        <option value="22">22분</option>
                                        <option value="23">23분</option>
                                        <option value="24">24분</option>
                                        <option value="25">25분</option>
                                        <option value="26">26분</option>
                                        <option value="27">27분</option>
                                        <option value="28">28분</option>
                                        <option value="29">29분</option>
                                        <option value="30">30분</option>
                                        <option value="31">31분</option>
                                        <option value="32">32분</option>
                                        <option value="33">33분</option>
                                        <option value="34">34분</option>
                                        <option value="35">35분</option>
                                        <option value="36">36분</option>
                                        <option value="37">37분</option>
                                        <option value="38">38분</option>
                                        <option value="39">39분</option>
                                        <option value="40">40분</option>
                                        <option value="41">41분</option>
                                        <option value="42">42분</option>
                                        <option value="43">43분</option>
                                        <option value="44">44분</option>
                                        <option value="45">45분</option>
                                        <option value="46">46분</option>
                                        <option value="47">47분</option>
                                        <option value="48">48분</option>
                                        <option value="49">49분</option>
                                        <option value="50">50분</option>
                                        <option value="51">51분</option>
                                        <option value="52">52분</option>
                                        <option value="53">53분</option>
                                        <option value="54">54분</option>
                                        <option value="55">55분</option>
                                        <option value="56">56분</option>
                                        <option value="57">57분</option>
                                        <option value="58">58분</option>
                                        <option value="59">59분</option>
                                    </select>
                                    <!-- 숨겨진 time input (기존 로직 호환성을 위해) -->
                                    <input type="time" id="email-time-input" value="09:00" style="display: none;">
                                </div>
                            </div>

                            <!-- 발신인 설정 -->
                            <div class="setting-item" style="flex-direction: column; align-items: flex-start; gap: 10px;">
                                <div>
                                    <div class="setting-label">발신인 설정</div>
                                    <div class="setting-description">이메일의 발신 표시 이름과 발신 이메일을 설정하세요 (옵션)</div>
                                </div>
                                <div style="display: flex; gap: 12px; width: 100%; max-width: 800px; flex-wrap: wrap;">
                                    <input type="text" id="email-sender-name" class="search-box" placeholder="표시 이름 (예: Samsung AI Dashboard)" style="flex:1; min-width: 240px;" />
                                    <input type="email" id="email-sender-address" class="search-box" placeholder="발신 이메일 (예: your-name@gmail.com)" style="flex:1; min-width: 240px;" />
                                </div>
                                <div style="color:#7a7a7a; font-size:12px;">
                                    참고: Gmail을 사용할 경우 실제 발신 계정은 서버에 설정된 Gmail 계정으로 인증됩니다. 발신 이메일을 임의로 변경하면 수신자 메일함에서 표시만 바뀌거나 Gmail 정책에 따라 원래 계정으로 표시될 수 있습니다.
                                </div>
                            </div>

                            <!-- 발송 메시지 입력 -->
                            <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                                <div style="margin-bottom: 15px;">
                                    <div class="setting-label">발송 메시지 입력</div>
                                    <div class="setting-description">이메일 리포트에 포함될 메시지를 입력하세요</div>
                                </div>
                                <div style="
                                    position: relative;
                                    background-color: #1a1a1a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    transition: all 0.2s ease;
                                    width: 100%;
                                    max-width: 800px;
                                ">
                                    <textarea 
                                        id="email-report-message" 
                                        placeholder="이메일에 포함될 메시지를 입력하세요..."
                                        style="
                                            width: 100%;
                                            height: 120px;
                                            padding: 12px;
                                            border: none;
                                            background: transparent;
                                            color: #ff9800;
                                            font-size: 14px;
                                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                            line-height: 1.5;
                                            outline: none;
                                            resize: vertical;
                                            min-height: 120px;
                                            max-height: 200px;
                                            box-sizing: border-box;
                                        "
                                        onfocus="this.parentElement.style.backgroundColor='#2a2a2a'; this.parentElement.style.borderColor='#4a9eff'"
                                        onblur="this.parentElement.style.backgroundColor='#1a1a1a'; this.parentElement.style.borderColor='#3a3a3a'"
                                        oninput="updateMessageCharCount(); syncMessageInputs('email-report-message')"
                                    ></textarea>
                                </div>
                                <div style="
                                    color: #7a7a7a;
                                    font-size: 12px;
                                    margin-top: 5px;
                                    text-align: right;
                                    width: 100%;
                                    max-width: 800px;
                                ">
                                    <span id="report-message-char-count">0</span>/1000 글자
                                </div>
                            </div>

                            <!-- 첨부 파일 -->
                            <div class="setting-item" style="flex-direction: column; align-items: flex-start;">
                                <div style="margin-bottom: 10px;">
                                    <div class="setting-label">첨부 파일</div>
                                    <div class="setting-description">리포트에 포함할 첨부 파일을 선택하세요</div>
                                </div>
                                <div style="display: flex; gap: 12px; flex-wrap: wrap; align-items: center;">
                                    <label style="display: flex; align-items: center; gap: 6px;">
                                        <input type="checkbox" id="attachment-all-members" style="width: 16px; height: 16px;" onclick="handleAttachmentTargetToggle('all', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">전체 멤버</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px;">
                                        <input type="checkbox" id="attachment-inactive-members" style="width: 16px; height: 16px;" onclick="handleAttachmentTargetToggle('inactive', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">비활성 멤버</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 6px;">
                                        <input type="checkbox" id="attachment-custom" style="width: 16px; height: 16px;" onclick="handleAttachmentTargetToggle('custom', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">직접 입력</span>
                                    </label>
                                </div>

                                <!-- 전체 멤버 섹션 -->
                                <div id="attachment-all-section" style="display: none; margin-top: 10px; width: 100%;">
                                    <div class="setting-label" style="margin-bottom: 8px;">전체 멤버 리스트</div>
                                    <div style="display:flex; justify-content: space-between; align-items:center; gap:12px; margin-bottom:8px;">
                                        <div style="position: relative; display:flex; align-items:center;">
                                            <span style="position:absolute; left:10px; color:#7a7a7a;">🔍</span>
                                            <input type="text" id="attachment-all-search" class="search-box" placeholder="Search name, email..." style="padding-left: 30px; width: 260px;" oninput="filterAttachmentList('all', this.value)">
                                        </div>
                                        <div style="display:flex; gap:8px; align-items:center;">
                                            <select id="attachment-all-sort" class="setting-select" style="background-color: transparent; min-width: 160px;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="sortAttachmentList('all', this.value)">
                                                <option value="name_asc" selected>이름 ↑</option>
                                                <option value="name_desc">이름 ↓</option>
                                                <option value="email_asc">이메일 ↑</option>
                                                <option value="email_desc">이메일 ↓</option>
                                            </select>
                                            <select id="attachment-all-page-size" class="setting-select" style="background-color: transparent; min-width: 100px;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="changeAttachmentPageSize('all', this.value)">
                                                <option value="10">10</option>
                                                <option value="20" selected>20</option>
                                                <option value="50">50</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div id="attachment-all-list" style="margin-bottom: 8px; background: #1a1a1a; border: 1px solid #3a3a3a; border-radius: 6px; padding: 12px; color: #e1e1e1; max-height: 220px; overflow-y: auto;"></div>
                                    <div id="attachment-all-pagination" class="pagination-container" style="display:flex; justify-content: flex-end; gap:8px; align-items:center;"></div>
                                    <label style="display:flex; align-items: center; gap: 6px; margin: 12px 0;">
                                        <input type="checkbox" id="attachment-all-usage" style="width: 16px; height: 16px;" onclick="toggleAttachmentUsageSection('all', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">사용량</span>
                                    </label>
                                </div>

                                <!-- 비활성 멤버 섹션 -->
                                <div id="attachment-inactive-section" style="display: none; margin-top: 10px; width: 100%;">
                                    <div class="setting-label" id="attachment-inactive-title" style="margin-bottom: 8px;">비활성 멤버 리스트</div>
                                    <div style="display:flex; justify-content: space-between; align-items:center; gap:12px; margin-bottom:8px;">
                                        <div style="position: relative; display:flex; align-items:center;">
                                            <span style="position:absolute; left:10px; color:#7a7a7a;">🔍</span>
                                            <input type="text" id="attachment-inactive-search" class="search-box" placeholder="Search name, email..." style="padding-left: 30px; width: 260px;" oninput="filterAttachmentList('inactive', this.value)">
                                        </div>
                                        <div style="display:flex; gap:8px; align-items:center;">
                                            <select id="attachment-inactive-sort" class="setting-select" style="background-color: transparent; min-width: 160px;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="sortAttachmentList('inactive', this.value)">
                                                <option value="name_asc" selected>이름 ↑</option>
                                                <option value="name_desc">이름 ↓</option>
                                                <option value="email_asc">이메일 ↑</option>
                                                <option value="email_desc">이메일 ↓</option>
                                                <option value="last_asc">마지막 활동 오래된순</option>
                                                <option value="last_desc">마지막 활동 최근순</option>
                                            </select>
                                            <select id="attachment-inactive-page-size" class="setting-select" style="background-color: transparent; min-width: 100px;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="changeAttachmentPageSize('inactive', this.value)">
                                                <option value="10">10</option>
                                                <option value="20" selected>20</option>
                                                <option value="50">50</option>
                                            </select>
                                            <select id="attachment-inactive-days" class="setting-select" style="background-color: transparent; min-width: 140px;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="setInactiveDaysFilter(this.value)">
                                                <option value="7">최근 7일 무활동</option>
                                                <option value="14" selected>최근 14일 무활동</option>
                                                <option value="30">최근 30일 무활동</option>
                                                <option value="60">최근 60일 무활동</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div id="attachment-inactive-list" style="margin-bottom: 8px; background: #1a1a1a; border: 1px solid #3a3a3a; border-radius: 6px; padding: 12px; color: #e1e1e1; max-height: 220px; overflow-y: auto;"></div>
                                    <div id="attachment-inactive-pagination" class="pagination-container" style="display:flex; justify-content: flex-end; gap:8px; align-items:center;"></div>
                                    <label style="display:flex; align-items: center; gap: 6px; margin: 12px 0;">
                                        <input type="checkbox" id="attachment-inactive-usage" style="width: 16px; height: 16px;" onclick="toggleAttachmentUsageSection('inactive', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">사용량</span>
                                    </label>
                                </div>

                                <!-- 직접 입력 섹션 -->
                                <div id="attachment-custom-section" style="display: none; margin-top: 10px; width: 100%;">
                                    <div style="margin-bottom: 10px;">
                                        <div class="setting-label">직접 입력 이메일 주소</div>
                                        <div class="setting-description">쉼표로 구분하여 이메일 주소를 직접 입력하세요</div>
                                    </div>
                                    <div style="position: relative; background-color: #1a1a1a; border: 1px solid #3a3a3a; border-radius: 4px; transition: all 0.2s ease; width: 100%; max-width: 800px; margin-bottom: 16px;">
                                        <textarea id="attachment-custom-emails" placeholder="email을 직접 입력 하세요.(example1@samsung.com, example2@samsung.com)" style="width: 100%; height: 120px; padding: 12px; border: none; background: transparent; color: #ff9800; font-size: 14px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; line-height: 1.5; outline: none; resize: vertical; min-height: 120px; max-height: 200px; box-sizing: border-box;" onfocus="this.parentElement.style.backgroundColor='#2a2a2a'; this.parentElement.style.borderColor='#4a9eff'" onblur="this.parentElement.style.backgroundColor='#1a1a1a'; this.parentElement.style.borderColor='#3a3a3a'"></textarea>
                                    </div>
                                    <label style="display:flex; align-items: center; gap: 6px; margin: 16px 0 12px;">
                                        <input type="checkbox" id="attachment-custom-usage" style="width: 16px; height: 16px;" onclick="toggleAttachmentUsageSection('custom', this)">
                                        <span style="color: #e1e1e1; font-size: 14px;">사용량</span>
                                    </label>
                                </div>

                                <!-- 사용량 첨부 설정 (공통, 선택된 섹션 아래로 이동하여 표시) -->
                                <div id="usage-attachment-settings" style="display: none; margin-top: 12px; width: 100%;">
                                    
                                    <!-- 기간 설정 -->
                                    <div style="display: flex; gap: 16px; align-items: center;">
                                        <div style="min-width: 80px; color: #b1b1b1; font-size: 14px;">기간</div>
                                        <div class="chart-controls" id="usage-attachment-period-buttons" style="gap: 8px;">
                                            <button type="button" class="chart-btn" onclick="selectUsageAttachmentPeriod('1')">1d</button>
                                            <button type="button" class="chart-btn" onclick="selectUsageAttachmentPeriod('7')">7d</button>
                                            <button type="button" class="chart-btn" onclick="selectUsageAttachmentPeriod('30')">30d</button>
                                            <button type="button" class="chart-btn" onclick="selectUsageAttachmentPeriod('custom')">직접입력</button>
                                        </div>
                                        <div id="usage-attachment-custom-date" class="chart-controls" style="display: none; gap: 8px; align-items: center;">
                                            <div class="filter-period-display">
                                                <span id="usage-attachment-period-text">기간을 선택하세요</span>
                                            </div>
                                            <div class="date-picker">
                                                <input type="date" id="usage-attachment-start-date" />
                                                <span>~</span>
                                                <input type="date" id="usage-attachment-end-date" />
                                                <button type="button" class="analytics-btn" onclick="applyUsageAttachmentDateRange()">적용</button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- 수신자 그룹 -->
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">수신자 그룹</div>
                                    <div class="setting-description">리포트를 받을 대상을 설정합니다</div>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="admin-checkbox" checked style="width: 16px; height: 16px;" onchange="updateRecipientCount()">
                                        <span style="color: #e1e1e1; font-size: 14px;">관리자</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="all-members-checkbox" style="width: 16px; height: 16px;" onchange="updateRecipientCount()">
                                        <span style="color: #e1e1e1; font-size: 14px;">전체 멤버</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="inactive-members-checkbox" style="width: 16px; height: 16px;" onchange="updateRecipientCount()">
                                        <span style="color: #e1e1e1; font-size: 14px;">비활성 멤버</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 5px;">
                                        <input type="checkbox" id="custom-email-checkbox" style="width: 16px; height: 16px;" onclick="toggleCustomEmailInput(this)" onchange="updateRecipientCount()">
                                        <span style="color: #e1e1e1; font-size: 14px;">직접 입력</span>
                                    </label>
                                </div>
                                
                            </div>
                            
                            <!-- 직접 입력 영역 -->
                            <div id="custom-email-input" style="display: none; margin-top: 10px;">
                                <div style="margin-bottom: 15px;">
                                    <div class="setting-label">직접 입력 이메일 주소</div>
                                    <div class="setting-description">쉼표로 구분하여 이메일 주소를 직접 입력하세요</div>
                                </div>
                                <div style="
                                    position: relative;
                                    background-color: #1a1a1a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    transition: all 0.2s ease;
                                    width: 100%;
                                    max-width: 800px;
                                ">
                                    <textarea
                                        id="custom-emails"
                                        placeholder="email을 직접 입력 하세요.(example1@samsung.com, example2@samsung.com)"
                                        style="
                                            width: 100%;
                                            height: 120px;
                                            padding: 12px;
                                            border: none;
                                            background: transparent;
                                            color: #ff9800;
                                            font-size: 14px;
                                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                            line-height: 1.5;
                                            outline: none;
                                            resize: vertical;
                                            min-height: 120px;
                                            max-height: 200px;
                                            box-sizing: border-box;
                                        "
                                        onfocus="this.parentElement.style.backgroundColor='#2a2a2a'; this.parentElement.style.borderColor='#4a9eff'"
                                        onblur="this.parentElement.style.backgroundColor='#1a1a1a'; this.parentElement.style.borderColor='#3a3a3a'"
                                    ></textarea>
                                </div>
                            </div>
                            
                            <!-- 하단 버튼 -->
                            <div class="setting-item" style="margin-top: 20px;">
                                <div>
                                    <div class="setting-label">설정 관리</div>
                                    <div class="setting-description">현재 설정을 확인하고 저장합니다</div>
                                </div>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items:center;">
                                    <button class="analytics-btn" onclick="showEmailSettingsList()">설정 리스트</button>
                                    <button class="analytics-btn" onclick="showEmailScheduleList()">예약 리스트</button>
                                    <button class="analytics-btn" onclick="showEmailRecipients()">수신자 보기</button>
                                    <button class="analytics-btn" onclick="saveEmailSettings()">설정 저장</button>
                                    
                                </div>
                            </div>


                        </div>
                    </div>

                    <!-- Export Documents 설정 -->
                    <div class="settings-section">
                        <div class="accordion-header" onclick="toggleAccordion(this)">
                            <div class="accordion-title">Export Documents 설정</div>
                            <div class="accordion-arrow">▼</div>
                        </div>
                        <div class="accordion-content">
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">자동 백업</div>
                                    <div class="setting-description">데이터를 정기적으로 자동 백업합니다</div>
                                </div>
                                <div class="toggle-switch off" onclick="toggleSwitch(this)"></div>
                            </div>
                            <div class="setting-item" id="backup-frequency-setting" style="display: none;">
                                <div>
                                    <div class="setting-label">백업 주기</div>
                                    <div class="setting-description">백업을 수행할 주기를 선택하세요</div>
                                </div>
                                <select class="setting-select" id="backup-frequency-select" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                    <option value="daily" selected>매일</option>
                                    <option value="weekly">매주</option>
                                    <option value="monthly">매월</option>
                                </select>
                            </div>
                            <div class="setting-item" id="backup-time-setting" style="display: none;">
                                <div>
                                    <div class="setting-label">백업 시간</div>
                                    <div class="setting-description">백업을 실행할 구체적인 시간을 설정하세요</div>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select id="backup-hour-select" style="
                                        background-color: transparent;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 8px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        font-family: inherit;
                                        transition: background-color 0.2s ease;
                                        min-width: 120px;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="updateBackupTimeInput()">
                                        <option value="00">오전 12시</option>
                                        <option value="01">오전 1시</option>
                                        <option value="02" selected>오전 2시</option>
                                        <option value="03">오전 3시</option>
                                        <option value="04">오전 4시</option>
                                        <option value="05">오전 5시</option>
                                        <option value="06">오전 6시</option>
                                        <option value="07">오전 7시</option>
                                        <option value="08">오전 8시</option>
                                        <option value="09">오전 9시</option>
                                        <option value="10">오전 10시</option>
                                        <option value="11">오전 11시</option>
                                        <option value="12">오후 12시</option>
                                        <option value="13">오후 1시</option>
                                        <option value="14">오후 2시</option>
                                        <option value="15">오후 3시</option>
                                        <option value="16">오후 4시</option>
                                        <option value="17">오후 5시</option>
                                        <option value="18">오후 6시</option>
                                        <option value="19">오후 7시</option>
                                        <option value="20">오후 8시</option>
                                        <option value="21">오후 9시</option>
                                        <option value="22">오후 10시</option>
                                        <option value="23">오후 11시</option>
                                    </select>
                                    <select id="backup-minute-select" style="
                                        background-color: transparent;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 8px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        font-family: inherit;
                                        transition: background-color 0.2s ease;
                                        min-width: 80px;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'" onchange="updateBackupTimeInput()">
                                        <option value="00" selected>00분</option>
                                        <option value="05">05분</option>
                                        <option value="10">10분</option>
                                        <option value="15">15분</option>
                                        <option value="20">20분</option>
                                        <option value="25">25분</option>
                                        <option value="30">30분</option>
                                        <option value="35">35분</option>
                                        <option value="40">40분</option>
                                        <option value="45">45분</option>
                                        <option value="50">50분</option>
                                        <option value="55">55분</option>
                                    </select>
                                    <input type="time" id="backup-time-input" value="02:00" style="display: none;">
                                </div>
                            </div>
                            <div class="setting-item" id="backup-location-setting" style="display: none;">
                                <div>
                                    <div class="setting-label">백업 위치</div>
                                    <div class="setting-description">백업 파일이 저장될 위치를 입력하세요</div>
                                </div>
                                <input type="text" id="backup-location-input" class="search-box" placeholder="예: C:\\Backups\\Dashboard 또는 /backups/dashboard" style="min-width: 300px;" />
                            </div>
                            <!-- Export 종류 → Export 범위(조건) → Export 형식 순서 -->
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">Export 종류</div>
                                    <div class="setting-description">내보낼 데이터의 종류를 선택합니다</div>
                                </div>
                                <div style="display:flex; gap: 12px; flex-wrap: wrap; align-items:center;">
                                    <label style="display:flex; align-items:center; gap:6px;">
                                        <input type="checkbox" id="export-type-summary" value="summary" onclick="handleExportTypeCheckboxChange()" style="width:16px; height:16px;">
                                        <span style="color:#e1e1e1; font-size:14px;">요약 리포트</span>
                                    </label>
                                    <label style="display:flex; align-items:center; gap:6px;">
                                        <input type="checkbox" id="export-type-raw" value="raw-events" onclick="handleExportTypeCheckboxChange()" style="width:16px; height:16px;">
                                        <span style="color:#e1e1e1; font-size:14px;">사용 이벤트 원본</span>
                                    </label>
                                    <label style="display:flex; align-items:center; gap:6px;">
                                        <input type="checkbox" id="export-type-members" value="members" onclick="handleExportTypeCheckboxChange()" style="width:16px; height:16px;">
                                        <span style="color:#e1e1e1; font-size:14px;">멤버 목록</span>
                                    </label>
                                    <label style="display:flex; align-items:center; gap:6px;">
                                        <input type="checkbox" id="export-type-all" value="all" onclick="handleExportTypeCheckboxChange()" style="width:16px; height:16px;">
                                        <span style="color:#e1e1e1; font-size:14px;">전체 (요약 + 원본)</span>
                                    </label>
                                </div>
                            </div>
                            <div class="setting-item" id="export-range-setting">
                                <div>
                                    <div class="setting-label">Export 범위</div>
                                    <div class="setting-description">내보낼 데이터의 기간을 설정합니다</div>
                                </div>
                                <select class="setting-select">
                                    <option>최근 7일</option>
                                    <option selected>최근 30일</option>
                                    <option>최근 90일</option>
                                    <option>전체 기간</option>
                                    <option>사용자 지정</option>
                                </select>
                            </div>
                            <div class="setting-item">
                                <div>
                                    <div class="setting-label">Export 형식</div>
                                    <div class="setting-description">문서를 내보낼 파일 형식을 선택합니다</div>
                                </div>
                                <select id="export-format-select" class="setting-select" style="background-color: transparent;" onchange="handleExportFormatChange(this.value)" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                    <option value="csv">CSV</option>
                                    <option value="xlsx" selected>Excel (XLSX)</option>
                                    <option value="pdf">PDF</option>
                                    <option value="json">JSON</option>
                                </select>
                            </div>
                            
                            <!-- 형식별 세부 옵션 -->
                            <div id="export-format-options" style="margin-top: 6px;">
                                <!-- CSV 옵션 -->
                                <div id="csv-options" style="display: none;">
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">CSV 구분자</div>
                                            <div class="setting-description">필드 간 값을 구분하는 문자</div>
                                        </div>
                                        <select class="setting-select" id="csv-delimiter" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="," selected>콤마 (,)</option>
                                            <option value="\t">탭 (\t)</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">인코딩</div>
                                            <div class="setting-description">엑셀 호환을 위해 UTF-8 with BOM 권장</div>
                                        </div>
                                        <select class="setting-select" id="csv-encoding" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="utf8">UTF-8</option>
                                            <option value="utf8-bom" selected>UTF-8 with BOM</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">헤더 포함</div>
                                            <div class="setting-description">첫 행에 필드명을 포함</div>
                                        </div>
                                        <select class="setting-select" id="csv-include-header" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="yes" selected>예</option>
                                            <option value="no">아니오</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">날짜/시간 포맷</div>
                                            <div class="setting-description">표시 형식</div>
                                        </div>
                                        <select class="setting-select" id="csv-datetime-format" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="YYYY-MM-DD">YYYY-MM-DD</option>
                                            <option value="YYYY-MM-DD HH:mm" selected>YYYY-MM-DD HH:mm</option>
                                            <option value="ISO8601">ISO 8601</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">줄바꿈</div>
                                            <div class="setting-description">운영체제별 줄바꿈 문자</div>
                                        </div>
                                        <select class="setting-select" id="csv-newline" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="LF">LF (Unix)</option>
                                            <option value="CRLF" selected>CRLF (Windows)</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- XLSX 옵션 -->
                                <div id="xlsx-options" style="display: none;">
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">시트 구성</div>
                                            <div class="setting-description">요약/멤버/원본 데이터 분리 저장</div>
                                        </div>
                                        <select class="setting-select" id="xlsx-sheets" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="single">단일 시트</option>
                                            <option value="multi" selected>다중 시트 (권장)</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">헤더 고정</div>
                                            <div class="setting-description">스크롤 시 헤더 행 고정</div>
                                        </div>
                                        <select class="setting-select" id="xlsx-freeze-header" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="yes" selected>예</option>
                                            <option value="no">아니오</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">열 너비 자동 맞춤</div>
                                            <div class="setting-description">내용에 맞춰 열 너비 조정</div>
                                        </div>
                                        <select class="setting-select" id="xlsx-autofit" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="yes" selected>예</option>
                                            <option value="no">아니오</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- PDF 옵션 -->
                                <div id="pdf-options" style="display: none;">
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">용지/방향</div>
                                            <div class="setting-description">PDF 페이지 크기 및 방향</div>
                                        </div>
                                        <select class="setting-select" id="pdf-page" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="A4-portrait" selected>A4 - 세로</option>
                                            <option value="A4-landscape">A4 - 가로</option>
                                            <option value="Letter-portrait">Letter - 세로</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">머리말/바닥글</div>
                                            <div class="setting-description">제목/페이지 번호/날짜 표시</div>
                                        </div>
                                        <select class="setting-select" id="pdf-header-footer" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="yes" selected>예</option>
                                            <option value="no">아니오</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- JSON 옵션 -->
                                <div id="json-options" style="display: none;">
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">구조</div>
                                            <div class="setting-description">출력 JSON 형식</div>
                                        </div>
                                        <select class="setting-select" id="json-structure" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="array">배열 (Array)</option>
                                            <option value="ndjson" selected>NDJSON (줄 단위)</option>
                                        </select>
                                    </div>
                                    <div class="setting-item">
                                        <div>
                                            <div class="setting-label">들여쓰기</div>
                                            <div class="setting-description">가독성을 위한 Pretty 출력</div>
                                        </div>
                                        <select class="setting-select" id="json-indent" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                            <option value="minify">미니파이</option>
                                            <option value="2" selected>2칸</option>
                                            <option value="4">4칸</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <!-- 공통 옵션 -->
                            <div id="export-common-options" style="margin-top: 6px;">
                                <div class="setting-item">
                                    <div>
                                        <div class="setting-label">압축(Zip)</div>
                                        <div class="setting-description">대용량 파일 전송을 위해 권장</div>
                                    </div>
                                    <select class="setting-select" id="export-zip" style="background-color: transparent;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                        <option value="yes">예</option>
                                        <option value="no" selected>아니오</option>
                                    </select>
                                </div>
                            </div>
                            <div class="setting-item" style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #3a3a3a; justify-content: flex-end;">
                                <div></div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="analytics-btn" onclick="showExportSettingsList()">설정 리스트</button>
                                    <button class="analytics-btn" onclick="handleExportNow()">지금 Export 하기</button>
                                    <button class="analytics-btn" onclick="saveExportSettings()">설정 저장</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // html2pdf.js CDN (원클릭 PDF 저장용)
        (function injectHtml2Pdf(){
            const existing = document.querySelector('script[data-lib="html2pdf"]');
            if (existing) return;
            const s = document.createElement('script');
            s.src = 'https://cdn.jsdelivr.net/npm/html2pdf.js@0.10.1/dist/html2pdf.bundle.min.js';
            s.defer = true;
            s.setAttribute('data-lib','html2pdf');
            document.head.appendChild(s);
        })();
        // 멤버 활동 데이터
        const memberData = {
            total: [
                { date: "25년 7월 25일 (오늘)", email: "greenmold@samsung.com", type: "active", kind: "Chat Request", request: "3", spend: "$0.05" },
                { date: "25년 7월 25일 (오늘)", email: "ck9104.lee@samsung.com", type: "active", kind: "Code Generation", request: "2", spend: "$0.03" },
                { date: "25년 7월 25일 (오늘)", email: "by07.so@samsung.com", type: "active", kind: "Analysis", request: "5", spend: "$0.08" },
                { date: "25년 7월 24일 (1일전)", email: "dynamic.choi@samsung.com", type: "inactive", kind: "Chat Request", request: "1", spend: "$0.01" },
                { date: "25년 7월 24일 (1일전)", email: "darney.jeon@samsung.com", type: "inactive", kind: "Code Review", request: "2", spend: "$0.02" },
                { date: "25년 7월 24일 (1일전)", email: "j0117.lee@samsung.com", type: "active", kind: "Documentation", request: "4", spend: "$0.04" },
                { date: "25년 7월 24일 (1일전)", email: "kaeul.kim@samsung.com", type: "active", kind: "Chat Request", request: "6", spend: "$0.06" },
                { date: "25년 7월 24일 (1일전)", email: "nw.aioffice@samsung.com", type: "inactive", kind: "Analysis", request: "1", spend: "$0.01" },
                { date: "25년 7월 24일 (1일전)", email: "sh.ryan.park@samsung.com", type: "active", kind: "Code Generation", request: "7", spend: "$0.07" },
                { date: "25년 7월 24일 (1일전)", email: "sejin.seo@samsung.com", type: "active", kind: "Chat Request", request: "3", spend: "$0.03" },
                { date: "25년 7월 23일 (2일전)", email: "sol22.lee@samsung.com", type: "inactive", kind: "Documentation", request: "2", spend: "$0.02" },
                { date: "25년 7월 23일 (2일전)", email: "shee.lim@samsung.com", type: "inactive", kind: "Analysis", request: "1", spend: "$0.01" },
                { date: "25년 7월 23일 (2일전)", email: "joseph2.jeon@samsung.com", type: "active", kind: "Code Review", request: "5", spend: "$0.05" },
                { date: "25년 7월 23일 (2일전)", email: "taewoo.bang@samsung.com", type: "inactive", kind: "Chat Request", request: "1", spend: "$0.01" },
                { date: "25년 7월 23일 (2일전)", email: "baewj@samsung.com", type: "inactive", kind: "Code Generation", request: "3", spend: "$0.03" },
                { date: "25년 7월 22일 (3일전)", email: "yj7.park@samsung.com", type: "active", kind: "Analysis", request: "4", spend: "$0.04" },
                { date: "25년 7월 22일 (3일전)", email: "nemo.kim@samsung.com", type: "active", kind: "Chat Request", request: "6", spend: "$0.06" },
                { date: "25년 7월 22일 (3일전)", email: "ms0402.kim@samsung.com", type: "active", kind: "Documentation", request: "3", spend: "$0.03" },
                { date: "25년 7월 21일 (4일전)", email: "shx.kim@samsung.com", type: "active", kind: "Code Review", request: "5", spend: "$0.05" },
                { date: "25년 7월 21일 (4일전)", email: "greenmold@samsung.com", type: "active", kind: "Analysis", request: "8", spend: "$0.08" }
            ]
        };

        // 활성/비활성 멤버 활동 분류
        memberData.active = memberData.total.filter(activity => activity.type === "active");
        memberData.inactive = memberData.total.filter(activity => activity.type === "inactive");

        // 멤버 리스트 렌더링
        function renderMemberList(type) {
            const memberList = document.getElementById('member-list');
            const memberListTitle = document.getElementById('member-list-title');
            if (!memberList || !memberListTitle) {
                console.warn('renderMemberList: 대상 요소를 찾을 수 없어 초기 렌더를 건너뜁니다. (member-list / member-list-title)');
                return;
            }
           
            let activities = [];
            let title = "";
            let icon = "";
           
            switch(type) {
                case 'active':
                    activities = memberData.active;
                    title = "활성 멤버 활동 리스트";
                    icon = "🟢";
                    break;
                case 'inactive':
                    activities = memberData.inactive;
                    title = "비활성 멤버 활동 리스트";
                    icon = "🟠";
                    break;
                default:
                    activities = memberData.total;
                    title = "전체 활동 리스트";
                    icon = "📊";
            }
           
            memberListTitle.textContent = `${icon} ${title}`;
           
            memberList.innerHTML = `
                <div class="member-list-header">
                    <div>DATE</div>
                    <div>EMAIL</div>
                    <div>TYPE</div>
                    <div>KIND</div>
                    <div>REQUEST</div>
                    <div>SPEND</div>
                </div>
                ${activities.map(activity => `
                    <div class="member-item">
                        <div class="member-date">${activity.date}</div>
                        <div class="member-email">${activity.email}</div>
                        <div class="member-type ${activity.type}">${activity.type === 'active' ? '활성' : '비활성'}</div>
                        <div class="member-kind">${activity.kind}</div>
                        <div class="member-request">${activity.request}</div>
                        <div class="member-spend">${activity.spend}</div>
                    </div>
                `).join('')}
            `;
        }

        // 통계 박스 클릭 이벤트
        function initOverviewStats() {
            const statBoxes = document.querySelectorAll('.overview-stat-box');
           
            statBoxes.forEach(box => {
                box.addEventListener('click', function() {
                    // 모든 박스에서 selected 클래스 제거
                    statBoxes.forEach(b => b.classList.remove('selected'));
                   
                    // 클릭된 박스에 selected 클래스 추가
                    this.classList.add('selected');
                   
                    // 해당 타입의 멤버 리스트 표시
                    const type = this.getAttribute('data-type');
                    renderMemberList(type);
                });
            });
           
            // 초기 로드 시 전체 멤버 리스트 표시
            renderMemberList('total');
        }

        // 현재 필터 상태를 가져오는 함수
        function getCurrentFilterState() {
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
            
            return {
                dateRange: dateRange,
                filterType: currentFilterType,
                members: currentMembers,
                rawEventsData: currentRawEventsData
            };
        }
        
        // 필터 상태가 동일한지 비교하는 함수
        function isFilterStateEqual(filter1, filter2) {
            if (!filter1 || !filter2) return false;
            
            return filter1.dateRange.startDate.getTime() === filter2.dateRange.startDate.getTime() &&
                   filter1.dateRange.endDate.getTime() === filter2.dateRange.endDate.getTime() &&
                   filter1.filterType === filter2.filterType &&
                   filter1.members.length === filter2.members.length &&
                   filter1.rawEventsData.length === filter2.rawEventsData.length;
        }
        
        // 캐시된 차트를 캔버스에 복원하는 함수
        function restoreCachedChart(chartType) {
            const cachedChart = chartCache[chartType];
            if (!cachedChart.data) return false;
            
            const canvas = getCanvasForChartType(chartType);
            if (!canvas) return false;
            
            const ctx = canvas.getContext('2d');
            
            // 캔버스 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            // 캐시된 이미지 데이터 복원
            ctx.putImageData(cachedChart.data, 0, 0);
            
            console.log(`📊 캐시된 차트 복원 완료: ${chartType}`);
            return true;
        }
        
        // 차트 타입에 따른 캔버스 요소 반환
        function getCanvasForChartType(chartType) {
            const canvasIds = {
                'activity-trend': 'overviewChart',
                'model-distribution': 'modelDistributionChart',
                'cost-trend': 'costTrendChart',
                'activity-type': 'activityTypeChart',
                'user-heatmap': 'userHeatmapChart',
                'cost-efficiency': 'costEfficiencyChart',
                'model-preference': 'modelPreferenceChart',
                'user-performance': 'userPerformanceChart',
                'activity-type-detailed': 'activityTypeDetailedChart'
            };
            
            return document.getElementById(canvasIds[chartType]);
        }
        
        // 차트 데이터를 캐시에 저장하는 함수
        function cacheChartData(chartType) {
            const canvas = getCanvasForChartType(chartType);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            chartCache[chartType].data = imageData;
            console.log(`📊 차트 데이터 캐시 저장: ${chartType}`);
        }
        
        // 차트에 필요한 데이터가 있는지 확인하는 함수
        async function checkAndLoadDataForChart(chartType) {
            console.log(`🔍 ${chartType} 차트 데이터 상태 확인 중...`);
            
            // 통합 데이터 저장소 우선 확인
            const currentFilter = getCurrentFilterState();
            if (chartDataStore.isDataValid(currentFilter)) {
                console.log(`✅ 통합 데이터 저장소에서 ${chartType} 차트에 필요한 데이터를 찾았습니다.`);
                return true;
            }
            
            // 통합 데이터 저장소에 데이터가 없으면 현재 전역 변수 확인
            const members = currentMembersData || [];
            const rawEvents = currentRawEventsData || [];
            
            console.log(`📊 전역 변수 데이터 상태 - 멤버: ${members.length}명, 이벤트: ${rawEvents.length}개`);
            
            // 모델 분포 차트는 이벤트 데이터만 있으면 됨
            if (chartType === 'model-distribution') {
                if (rawEvents.length === 0) {
                    console.log('❌ 모델 분포 차트: 사용 가능한 이벤트 데이터가 없습니다. 데이터 로딩을 시도합니다.');
                    // 데이터가 없으면 Overview 데이터를 다시 로드
                    return false;
                }
                console.log('✅ 모델 분포 차트: 이벤트 데이터 확인 완료');
                return true;
            }
            
            if (members.length === 0) {
                console.log('❌ 사용 가능한 멤버 데이터가 없습니다.');
                return false;
            }
            
            if (rawEvents.length === 0) {
                console.log('❌ 사용 가능한 이벤트 데이터가 없습니다.');
                return false;
            }
            
            // 특정 차트별 추가 데이터 확인
            if (chartType === 'cost-trend' || chartType === 'cost-efficiency') {
                // 비용 관련 차트는 cost 데이터가 필요
                const hasCostData = rawEvents.some(event => 
                    event.requestsCosts !== undefined && event.requestsCosts !== null
                );
                if (!hasCostData) {
                    console.log('❌ 비용 데이터가 없습니다.');
                    return false;
                }
            }
            
            console.log(`✅ ${chartType} 차트에 필요한 데이터가 모두 있습니다.`);
            return true;
        }
        
        // 차트를 위한 데이터 새로고침 함수
        async function refreshDataForChart(chartType) {
            console.log(`🔄 ${chartType} 차트를 위한 데이터 새로고침 시작...`);
            
            try {
                // 로딩 상태 표시
                showLoadingStatus(true);
                
                // 기본 데이터 새로고침
                await Promise.all([
                    updateMembersWithRealData(),
                    updateOverviewWithRealData()
                ]);
                
                console.log(`✅ ${chartType} 차트 데이터 새로고침 완료`);
                return true;
            } catch (error) {
                console.error(`❌ ${chartType} 차트 데이터 새로고침 실패:`, error);
                showErrorMessage(`차트 데이터를 불러오는 중 오류가 발생했습니다: ${error.message}`);
                return false;
            } finally {
                // 로딩 상태 해제
                showLoadingStatus(false);
            }
        }
        
        // 차트 변경 이벤트 핸들러
        function handleChartChange(chartType) {
            console.log(`🔄 차트 변경 요청: ${chartType}`);
            
            // 모든 차트에서 검색창 숨김
            const searchContainer = document.getElementById('chart-search-container');
            if (searchContainer) {
                searchContainer.style.display = 'none';
                // 검색창 초기화
                const searchInput = document.getElementById('chart-search-input');
                if (searchInput) {
                    searchInput.value = '';
                    clearChartSearch('chart-search-input');
                }
            }
            
            // 특별 처리가 필요한 차트들 (activity-trend 제외)
            if (chartType !== 'activity-trend') {
                // 사용자 활동 히트맵과 모델 선호도에 검색창 표시
                if (chartType === 'user-heatmap' || chartType === 'model-preference') {
                    const searchContainer = document.getElementById('chart-search-container');
                    if (searchContainer) {
                        searchContainer.style.display = 'block';
                        const searchInput = document.getElementById('chart-search-input');
                        if (searchInput) {
                            if (chartType === 'user-heatmap') {
                                searchInput.placeholder = '사용자 ID 검색...';
                                // 히트맵용 이메일 드롭다운 생성
                                populateHeatmapEmailDropdown();
                            } else if (chartType === 'model-preference') {
                                searchInput.placeholder = '사용자 ID 검색...';
                                // 모델 선호도용 이메일 드롭다운 생성
                                populateModelPreferenceDropdown();
                            }
                        }
                    }
                } else {
                    const searchContainer = document.getElementById('chart-search-container');
                    if (searchContainer) {
                        searchContainer.style.display = 'none';
                        const searchInput = document.getElementById('chart-search-input');
                        if (searchInput) {
                            searchInput.value = '';
                            clearChartSearch('chart-search-input');
                        }
                    }
                }
                console.log(`🎯 특별 처리 차트: ${chartType}`);
                
                // 먼저 차트 컨테이너 표시
                document.querySelectorAll('.chart-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                const chartId = `${chartType}-chart`;
                const selectedChart = document.getElementById(chartId);
                if (selectedChart) {
                    selectedChart.classList.add('active');
                    console.log(`✅ ${chartType} 차트 컨테이너 활성화 완료`);
                } else {
                    console.error(`❌ ${chartId} 요소를 찾을 수 없습니다!`);
                    return;
                }
                
                // 데이터 확인 및 로딩
                const hasMembersData = currentMembersData && currentMembersData.length > 0;
                const hasEventsData = currentRawEventsData && currentRawEventsData.length > 0;
                
                console.log(`📊 데이터 상태 확인: 멤버데이터=${hasMembersData}, 이벤트데이터=${hasEventsData}`);
                
                // 데이터 요구사항별 확인
                let needsData = false;
                if (chartType === 'model-distribution') {
                    needsData = !hasEventsData;
                } else if (chartType === 'user-performance') {
                    needsData = !hasMembersData || !hasEventsData;
                } else if (chartType === 'cost-trend' || chartType === 'cost-efficiency') {
                    needsData = !hasEventsData; // 비용 관련 차트는 이벤트 데이터만 필요
                } else {
                    needsData = !hasMembersData || !hasEventsData; // 기타 차트는 둘 다 필요
                }
                
                if (needsData) {
                    console.log(`🔄 ${chartType} 차트를 위한 데이터 로딩 시작...`);
                    
                    // 로딩 메시지 표시 - 차트별 캔버스 ID 매핑
                    const canvasIdMap = {
                        'user-performance': 'userPerformanceChart',
                        'model-distribution': 'modelDistributionChart',
                        'cost-trend': 'costTrendChart',
                        'activity-type': 'activityTypeChart',
                        'user-heatmap': 'userHeatmapChart',
                        'cost-efficiency': 'costEfficiencyChart',
                        'model-preference': 'modelPreferenceChart',
                        'activity-type-detailed': 'activityTypeDetailedChart'
                    };
                    const canvasId = canvasIdMap[chartType] || 'overviewChart';
                    const canvas = document.getElementById(canvasId);
                    if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        canvas.width = rect.width;
                        canvas.height = 300;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = '#7a7a7a';
                        ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('데이터를 불러오는 중...', canvas.width / 2, canvas.height / 2);
                    }
                    
                    updateOverviewWithCurrentFilter(30).then(() => {
                        console.log('✅ 데이터 로딩 완료, 차트 생성 시작');
                        // 차트별 생성 함수 호출
                        if (chartType === 'user-performance') {
                            createUserPerformanceChart();
                        } else if (chartType === 'model-distribution') {
                            createModelDistributionChart();
                        } else if (chartType === 'cost-trend') {
                            createCostTrendChart();
                        } else if (chartType === 'activity-type') {
                            createActivityTypeChart();
                        } else if (chartType === 'user-heatmap') {
                            createUserHeatmapChart();
                        } else if (chartType === 'cost-efficiency') {
                            createCostEfficiencyChart();
                        } else if (chartType === 'model-preference') {
                            createModelPreferenceChart();
                        } else if (chartType === 'activity-type-detailed') {
                            createActivityTypeDetailedChart();
                        }
                    }).catch(error => {
                        console.error('데이터 로딩 실패:', error);
                        const canvas = document.getElementById(canvasId);
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = '#1a1a1a';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                            ctx.fillStyle = '#f44336';
                            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText('데이터 로딩 실패', canvas.width / 2, canvas.height / 2);
                        }
                    });
                    return;
                } else {
                    // 데이터가 이미 있으면 바로 차트 생성
                    console.log('✅ 데이터가 이미 존재함, 바로 차트 생성');
                    if (chartType === 'user-performance') {
                        createUserPerformanceChart();
                    } else if (chartType === 'model-distribution') {
                        createModelDistributionChart();
                    } else if (chartType === 'cost-trend') {
                        createCostTrendChart();
                    } else if (chartType === 'activity-type') {
                        createActivityTypeChart();
                    } else if (chartType === 'user-heatmap') {
                        createUserHeatmapChart();
                    } else if (chartType === 'cost-efficiency') {
                        createCostEfficiencyChart();
                    } else if (chartType === 'model-preference') {
                        createModelPreferenceChart();
                    } else if (chartType === 'activity-type-detailed') {
                        createActivityTypeDetailedChart();
                    }
                    return;
                }
            }
            
            // 다른 차트들은 switchChart 함수 사용
            console.log(`🔄 다른 차트 처리: ${chartType}`);
            switchChart(chartType).catch(error => {
                console.error('차트 전환 중 오류가 발생했습니다:', error);
                showErrorMessage('차트를 불러오는 중 오류가 발생했습니다.');
            });
        }
        
        // 차트 전환 함수 (데이터 로딩 포함)
        async function switchChart(chartType) {
            console.log(`📊 switchChart 호출: ${chartType}`);
            
            // 모든 차트 내용 숨기기
            document.querySelectorAll('.chart-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 선택된 차트 내용 표시
            const selectedChart = document.getElementById(`${chartType}-chart`);
            if (selectedChart) {
                selectedChart.classList.add('active');
                console.log(`✅ ${chartType} 차트 컨테이너 활성화 완료`);
            } else {
                console.error(`❌ ${chartType}-chart 요소를 찾을 수 없습니다!`);
                return;
            }
            
            // 현재 필터 상태 가져오기
            const currentFilter = getCurrentFilterState();
            
            // 캐시된 차트가 있고 필터가 동일한지 확인
            const cachedChart = chartCache[chartType];
            const shouldUseCache = cachedChart.rendered && cachedChart.data && isFilterStateEqual(cachedChart.filter, currentFilter);
            
            if (shouldUseCache) {
                console.log(`📊 캐시된 차트 사용: ${chartType}`);
                if (restoreCachedChart(chartType)) {
                    return;
                }
            }
            
            // 데이터가 있는지 확인 (통합 데이터 저장소 우선 사용)
            const hasRequiredData = await checkAndLoadDataForChart(chartType);
            if (!hasRequiredData) {
                console.log(`⚠️ ${chartType} 차트에 필요한 데이터가 없습니다. Overview 초기 로딩을 먼저 완료해주세요.`);
                // 데이터가 없으면 차트에 메시지를 표시하고 리턴
                const canvas = getCanvasForChartType(chartType);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width;
                    canvas.height = 300;
                    
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.fillStyle = '#7a7a7a';
                    ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('데이터를 불러오는 중...', canvas.width / 2, canvas.height / 2);
                }
                return;
            }
            
            // 새로운 차트 생성 또는 업데이트
            console.log(`📊 차트 새로 생성/업데이트: ${chartType}`);
            
            // 차트 타입에 따라 적절한 차트 렌더링
            console.log(`📊 차트 타입 "${chartType}" 렌더링 시작...`);
            
            if (chartType === 'activity-trend') {
                console.log('📈 일별 활동 추이 차트 생성');
                createOverviewChart();
            } else if (chartType === 'model-distribution') {
                console.log('📊 모델 사용 분포 차트 생성');
                createModelDistributionChart();
            } else if (chartType === 'cost-trend') {
                console.log('💰 비용 추이 차트 생성');
                createCostTrendChart();
            } else if (chartType === 'activity-type') {
                console.log('📊 활동 유형 분포 차트 생성');
                createActivityTypeChart();
            } else if (chartType === 'user-heatmap') {
                console.log('🔥 사용자 활동 히트맵 차트 생성');
                createUserHeatmapChart();
            } else if (chartType === 'cost-efficiency') {
                console.log('📊 비용 효율성 분석 차트 생성');
                createCostEfficiencyChart();
            } else if (chartType === 'model-preference') {
                console.log('🎯 모델 선호도 차트 생성');
                createModelPreferenceChart();
            } else if (chartType === 'user-performance') {
                console.log('🏆 사용자별 성과 차트 생성');
                
                // 사용자별 성과 차트를 위한 데이터 확인 및 로딩
                const hasMembersData = currentMembersData && currentMembersData.length > 0;
                const hasEventsData = currentRawEventsData && currentRawEventsData.length > 0;
                
                console.log(`📊 사용자별 성과 차트 데이터 상태: 멤버 ${hasMembersData ? currentMembersData.length : 0}명, 이벤트 ${hasEventsData ? currentRawEventsData.length : 0}개`);
                
                if (!hasMembersData || !hasEventsData) {
                    console.log('⚠️ 사용자별 성과 차트에 필요한 데이터가 없습니다. 데이터를 먼저 로드해주세요.');
                    // 데이터가 없으면 메시지 표시
                    const canvas = document.getElementById('userPerformanceChart');
                    if (canvas) {
                        const ctx = canvas.getContext('2d');
                        const width = canvas.width;
                        const height = canvas.height;
                        
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(0, 0, width, height);
                        
                        ctx.fillStyle = '#7a7a7a';
                        ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                    }
                    return;
                }
                
                createUserPerformanceChart();
            } else if (chartType === 'activity-type-detailed') {
                console.log('📈 활동 유형 상세 차트 생성');
                createActivityTypeDetailedChart();
            } else {
                console.log('❌ 알 수 없는 차트 타입:', chartType);
            }
            
            // 차트 렌더링 완료 후 캐시에 저장
            setTimeout(() => {
                cacheChartData(chartType);
                chartCache[chartType].filter = currentFilter;
                chartCache[chartType].rendered = true;
            }, 100);
            
            console.log(`📊 차트 전환 완료: ${chartType}`);
        }

        // 모델 사용 분포 막대 차트 생성
        function createModelDistributionChart() {
            console.log('🔍 createModelDistributionChart 시작...');
            console.log('🔍 전역 변수 상태 확인:');
            console.log('- currentRawEventsData:', currentRawEventsData);
            console.log('- currentRawEventsData 길이:', currentRawEventsData ? currentRawEventsData.length : 'undefined');
            console.log('- chartDataStore.rawEvents 길이:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 'undefined');
            
            const canvas = document.getElementById('modelDistributionChart');
            if (!canvas) {
                console.error('❌ modelDistributionChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            console.log('✅ 캔버스 찾음:', canvas);
            
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            console.log('📏 캔버스 크기 설정:', canvas.width, 'x', canvas.height);
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            console.log('✅ 배경 설정 완료');
            
            // 모델 사용 데이터 생성
            console.log('📊 모델 데이터 생성 시작...');
            const modelData = generateModelDistributionData();
            console.log('📊 생성된 모델 데이터:', modelData);
            
            if (modelData.length === 0) {
                console.log('⚠️ 모델 데이터가 비어있어 빈 차트를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            // 막대 차트 그리기
            console.log('📊 막대 차트 그리기 시작...');
            drawModelDistributionBarChart(ctx, width, height, modelData);
            console.log('✅ 모델 분포 차트 생성 완료');
        }

        // 모델 사용 분포 데이터 생성
        function generateModelDistributionData() {
            console.log('🔍 generateModelDistributionData 시작...');
            
            const modelUsage = new Map();
            
            // 전역 변수에서 데이터 가져오기 (chartDataStore 우선, 없으면 전역 변수 사용)
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            console.log('📊 데이터 소스 확인:');
            console.log('- chartDataStore.rawEvents:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 0);
            console.log('- currentRawEventsData:', currentRawEventsData ? currentRawEventsData.length : 0);
            console.log('- 사용할 rawEvents.length:', rawEvents ? rawEvents.length : 0);
            
            if (rawEvents && rawEvents.length > 0) {
                console.log('🎯 이벤트 데이터 샘플 (처음 3개):');
                rawEvents.slice(0, 3).forEach((event, index) => {
                    console.log(`이벤트 ${index}:`, {
                        model: event.model,
                        timestamp: event.timestamp,
                        userEmail: event.userEmail || event.email,
                        kind: event.kind,
                        전체: event
                    });
                });
                
                // 모델별 사용 횟수 집계
                rawEvents.forEach((event, index) => {
                    const model = event.model || 'unknown';
                    modelUsage.set(model, (modelUsage.get(model) || 0) + 1);
                    
                    // 처음 5개 이벤트의 모델 정보 로그
                    if (index < 5) {
                        console.log(`- 이벤트 ${index}: model="${model}", 전체 이벤트:`, event);
                    }
                });
                
                console.log('📊 모델별 사용 횟수 집계 결과:');
                modelUsage.forEach((count, model) => {
                    console.log(`- ${model}: ${count}회`);
                });
                console.log('📊 modelUsage Map 크기:', modelUsage.size);
            } else {
                console.log('⚠️ generateModelDistributionData: 사용 가능한 이벤트 데이터가 없습니다.');
                console.log('⚠️ rawEvents 값:', rawEvents);
                return [];
            }
            
            // 데이터를 배열로 변환하고 색상 추가
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0', '#00bcd4'];
            const data = [];
            let colorIndex = 0;
            
            modelUsage.forEach((count, model) => {
                data.push({
                    label: model,
                    value: count,
                    color: colors[colorIndex % colors.length]
                });
                colorIndex++;
            });
            
            console.log(`📊 모델 분포 데이터 생성 완료: ${data.length}개 모델 (데이터 소스: ${rawEvents.length}개 이벤트)`);
            console.log('📊 최종 데이터:', data);
            return data;
        }

        // 파이 차트 그리기
        function drawPieChart(ctx, width, height, data) {
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) / 3;
            
            let total = data.reduce((sum, item) => sum + item.value, 0);
            let currentAngle = 0;
            
            data.forEach(item => {
                const sliceAngle = (item.value / total) * 2 * Math.PI;
                
                // 파이 슬라이스 그리기
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = item.color;
                ctx.fill();
                
                // 테두리 그리기
                ctx.strokeStyle = '#1a1a1a';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // 레이블 그리기
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + (radius * 0.7) * Math.cos(labelAngle);
                const labelY = centerY + (radius * 0.7) * Math.sin(labelAngle);
                
                ctx.fillStyle = '#fff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${item.label} (${item.value})`, labelX, labelY);
                
                currentAngle += sliceAngle;
            });
            
            // 범례 그리기
            drawPieChartLegend(ctx, width, height, data);
        }

        // 모델 사용 분포 막대 차트 그리기
        function drawModelDistributionBarChart(ctx, width, height, data) {
            console.log('🔍 drawModelDistributionBarChart 시작...');
            console.log('📊 입력 데이터:', data);
            console.log('📏 캔버스 크기:', width, 'x', height);
            
            if (data.length === 0) {
                console.log('⚠️ 데이터가 비어있어 로딩 메시지를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 60;
            const chartWidth = width - (padding * 2);
            const chartHeight = height - (padding * 2);
            const barWidth = chartWidth / data.length * 0.8;
            const barSpacing = chartWidth / data.length * 0.2;
            
            // 최대값 계산
            const maxValue = Math.max(...data.map(d => d.value));
            
            // Y축 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // X축 그리기
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Y축 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (chartHeight / ySteps) * i;
                const value = Math.round((maxValue / ySteps) * (ySteps - i));
                ctx.fillText(value.toString(), padding - 10, y);
            }
            
            // 막대 그리기
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0', '#00bcd4'];
            
            data.forEach((item, index) => {
                const x = padding + (chartWidth / data.length) * index + barSpacing / 2;
                const barHeight = (item.value / maxValue) * chartHeight;
                const y = height - padding - barHeight;
                
                // 막대 그리기
                ctx.fillStyle = colors[index % colors.length];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 막대 위에 값 표시
                ctx.fillStyle = '#e1e1e1';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.value.toString(), x + barWidth / 2, y - 10);
                
                // X축 레이블 (모델명)
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.label, x + barWidth / 2, height - padding + 20);
            });
            
            // 제목
            ctx.fillStyle = '#e1e1e1';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('AI 모델별 사용 분포', width / 2, 25);
        }
        
        // 파이 차트 범례 그리기
        function drawPieChartLegend(ctx, width, height, data) {
            const legendX = 20;
            const legendY = height - 100;
            const itemHeight = 20;
            
            data.forEach((item, index) => {
                const y = legendY + index * itemHeight;
                
                // 색상 박스
                ctx.fillStyle = item.color;
                ctx.fillRect(legendX, y, 15, 15);
                
                // 텍스트
                ctx.fillStyle = '#fff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(`${item.label}: ${item.value}회`, legendX + 20, y + 10);
            });
        }

        // 비용 추이 라인 차트 생성
        function createCostTrendChart() {
            console.log('💰 createCostTrendChart 시작...');
            console.log('💰 전역 변수 상태 확인:');
            console.log('- currentRawEventsData:', currentRawEventsData ? currentRawEventsData.length : 'undefined');
            console.log('- chartDataStore.rawEvents:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 'undefined');
            
            const canvas = document.getElementById('costTrendChart');
            if (!canvas) {
                console.error('❌ costTrendChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            console.log('✅ 캔버스 찾음:', canvas);
            
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 비용 데이터 생성
            const costData = generateCostTrendData();
            console.log('💰 생성된 비용 데이터:', costData);
            
            if (costData.length === 0) {
                console.log('⚠️ 비용 데이터가 없습니다. 빈 차트를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('비용 데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            // 라인 차트 그리기
            drawLineChart(ctx, width, height, costData);
            console.log('✅ 비용 추이 차트 생성 완료');
        }

        // 비용 추이 데이터 생성
        function generateCostTrendData() {
            console.log('💰 generateCostTrendData 시작...');
            const dailyCosts = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            console.log('💰 데이터 소스 확인:');
            console.log('- chartDataStore.rawEvents:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 0);
            console.log('- currentRawEventsData:', currentRawEventsData ? currentRawEventsData.length : 0);
            console.log('- 사용할 rawEvents.length:', rawEvents ? rawEvents.length : 0);
            
            if (rawEvents && rawEvents.length > 0) {
                rawEvents.forEach(event => {
                    const eventDate = new Date(parseInt(event.timestamp));
                    const dateKey = eventDate.toISOString().split('T')[0];
                    const cost = (event.requestsCosts || 0) / 100; // cents to dollars
                    
                    if (dailyCosts.has(dateKey)) {
                        dailyCosts.set(dateKey, dailyCosts.get(dateKey) + cost);
                    } else {
                        dailyCosts.set(dateKey, cost);
                    }
                });
            } else {
                console.log('⚠️ generateCostTrendData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            // 날짜순으로 정렬
            const sortedDates = Array.from(dailyCosts.keys()).sort();
            const data = sortedDates.map(date => ({
                date: date,
                cost: dailyCosts.get(date)
            }));
            
            console.log(`📊 비용 추이 데이터 생성 완료: ${data.length}일간의 데이터 (데이터 소스: ${rawEvents.length}개 이벤트)`);
            return data;
        }

        // 라인 차트 그리기
        function drawLineChart(ctx, width, height, data) {
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 40;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            
            // Y축 최대값 계산
            const maxCost = Math.max(...data.map(d => d.cost));
            const minCost = Math.min(...data.map(d => d.cost));
            const costRange = maxCost - minCost;
            
            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            
            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // 세로 그리드
            for (let i = 0; i <= data.length - 1; i++) {
                const x = padding + (chartWidth / (data.length - 1)) * i;
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
            }
            
            // 라인 그리기
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            data.forEach((point, index) => {
                const x = padding + (chartWidth / (data.length - 1)) * index;
                const y = height - padding - ((point.cost - minCost) / costRange) * chartHeight;
                
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            
            ctx.stroke();
            
            // 데이터 포인트 그리기
            data.forEach((point, index) => {
                const x = padding + (chartWidth / (data.length - 1)) * index;
                const y = height - padding - ((point.cost - minCost) / costRange) * chartHeight;
                
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // 축 레이블 그리기
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            
            // X축 레이블 (날짜)
            data.forEach((point, index) => {
                const x = padding + (chartWidth / (data.length - 1)) * index;
                const date = new Date(point.date);
                const dateStr = `${date.getMonth() + 1}/${date.getDate()}`;
                ctx.fillText(dateStr, x, height - 10);
            });
            
            // Y축 레이블 (비용)
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                const cost = maxCost - (costRange / 5) * i;
                ctx.fillText(`$${cost.toFixed(2)}`, 10, y + 4);
            }
        }

        // 활동 유형 분포 바 차트 생성
        function createActivityTypeChart() {
            console.log('📊 createActivityTypeChart 시작...');
            const canvas = document.getElementById('activityTypeChart');
            if (!canvas) {
                console.error('❌ activityTypeChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            console.log('✅ 캔버스 찾음:', canvas);
            
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 활동 유형 데이터 생성
            const activityData = generateActivityTypeData();
            console.log('📊 생성된 활동 유형 데이터:', activityData);
            
            if (activityData.length === 0) {
                console.log('⚠️ 활동 유형 데이터가 없습니다. 빈 차트를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('활동 데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            // 바 차트 그리기
            drawBarChart(ctx, width, height, activityData);
            console.log('✅ 활동 유형 분포 차트 생성 완료');
        }

        // 활동 유형 데이터 생성
        function generateActivityTypeData() {
            console.log('📊 generateActivityTypeData 시작...');
            const activityTypes = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            console.log('📊 데이터 소스 확인:');
            console.log('- chartDataStore.rawEvents:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 0);
            console.log('- currentRawEventsData:', currentRawEventsData ? currentRawEventsData.length : 0);
            console.log('- 사용할 rawEvents.length:', rawEvents ? rawEvents.length : 0);
            
            if (rawEvents && rawEvents.length > 0) {
                rawEvents.forEach(event => {
                    const type = event.kind || 'unknown';
                    activityTypes.set(type, (activityTypes.get(type) || 0) + 1);
                });
            } else {
                console.log('⚠️ generateActivityTypeData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            // 데이터를 배열로 변환하고 색상 추가
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0'];
            const data = [];
            let colorIndex = 0;
            
            activityTypes.forEach((count, type) => {
                data.push({
                    label: type,
                    value: count,
                    color: colors[colorIndex % colors.length]
                });
                colorIndex++;
            });
            
            console.log(`📊 활동 유형 데이터 생성 완룉: ${data.length}개 유형 (데이터 소스: ${rawEvents.length}개 이벤트)`);
            return data;
        }

        // 바 차트 그리기
        function drawBarChart(ctx, width, height, data) {
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / data.length;
            const maxValue = Math.max(...data.map(d => d.value));
            
            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            
            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // 바 그리기
            data.forEach((item, index) => {
                const x = padding + barWidth * index + barWidth * 0.1;
                const barHeight = (item.value / maxValue) * chartHeight;
                const y = height - padding - barHeight;
                
                // 바 그리기
                ctx.fillStyle = item.color;
                ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // 값 텍스트
                ctx.fillStyle = '#fff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.value.toString(), x + barWidth * 0.4, y - 10);
                
                // 레이블
                ctx.fillStyle = '#7a7a7a';
                ctx.fillText(item.label, x + barWidth * 0.4, height - 10);
            });
            
            // Y축 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                const value = maxValue - (maxValue / 5) * i;
                ctx.fillText(value.toString(), padding - 10, y + 4);
            }
        }

        // 사용자 활동 히트맵 차트 생성 (막대 그래프)
        function createUserHeatmapChart() {
            console.log('🔥 createUserHeatmapChart 시작...');
            const canvas = document.getElementById('userHeatmapChart');
            if (!canvas) {
                console.error('❌ userHeatmapChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            console.log('✅ 캔버스 찾음:', canvas);
            
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 히트맵 데이터 생성 (막대 그래프용)
            const heatmapData = generateHeatmapBarData();
            console.log('🔥 생성된 히트맵 데이터:', heatmapData);
            
            if (heatmapData.length === 0) {
                console.log('⚠️ 히트맵 데이터가 없습니다. 빈 차트를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('활동 데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            // 막대 그래프 그리기
            drawHeatmapBarChart(ctx, width, height, heatmapData);
            console.log('✅ 사용자 활동 히트맵 차트 생성 완료');
        }

        // 히트맵 막대 그래프용 데이터 생성
        function generateHeatmapBarData() {
            console.log('🔥 generateHeatmapBarData 시작...');
            const userActivityMap = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            console.log('🔥 데이터 소스 확인:');
            console.log('- chartDataStore.members:', chartDataStore.members ? chartDataStore.members.length : 0);
            console.log('- currentMembers:', currentMembers ? currentMembers.length : 0);
            console.log('- chartDataStore.rawEvents:', chartDataStore.rawEvents ? chartDataStore.rawEvents.length : 0);
            console.log('- currentRawEventsData:', currentRawEventsData ? currentRawEventsData.length : 0);
            
            if (!members || members.length === 0) {
                console.log('⚠️ generateHeatmapBarData: 사용 가능한 멤버 데이터가 없습니다.');
                return [];
            }
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateHeatmapBarData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            // 사용자별 활동 수 계산
            members.forEach((member, userIndex) => {
                const userEmail = member.email;
                const userName = member.name;
                const userId = userEmail.split('@')[0]; // ID 추출
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail || event.email === userEmail
                );
                
                const totalActivity = userEvents.length;
                
                userActivityMap.set(userIndex, {
                    name: userName,
                    email: userEmail,
                    id: userId,
                    totalActivity: totalActivity
                });
            });
            
            // 활동 수로 정렬하여 상위 20명 선택
            const sortedUsers = Array.from(userActivityMap.entries())
                .sort((a, b) => b[1].totalActivity - a[1].totalActivity)
                .slice(0, 20);
            
            const data = sortedUsers.map(([userIndex, userData]) => ({
                userId: userData.id,
                userName: userData.name,
                email: userData.email,
                activity: userData.totalActivity
            }));
            
            console.log(`🔥 히트맵 막대 데이터 생성 완료: ${data.length}명의 사용자 (데이터 소스: ${members.length}명, ${rawEvents.length}개 이벤트)`);
            console.log('🔥 최종 데이터:', data);
            return data;
        }

        // 기존 히트맵 데이터 생성 (참고용)
        function generateHeatmapData() {
            const userActivityMap = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const members = chartDataStore.members.length > 0 ? chartDataStore.members : currentMembers;
            const rawEvents = chartDataStore.rawEvents.length > 0 ? chartDataStore.rawEvents : currentRawEventsData;
            
            if (!members || members.length === 0) {
                console.log('⚠️ generateHeatmapData: 사용 가능한 멤버 데이터가 없습니다.');
                return [];
            }
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateHeatmapData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            members.forEach((member, userIndex) => {
                const userEmail = member.email;
                const userName = member.name;
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail
                );
                
                const dailyActivity = new Map();
                
                userEvents.forEach(event => {
                    const eventDate = new Date(parseInt(event.timestamp));
                    const dateKey = eventDate.toISOString().split('T')[0];
                    
                    if (dailyActivity.has(dateKey)) {
                        dailyActivity.set(dateKey, dailyActivity.get(dateKey) + 1);
                    } else {
                        dailyActivity.set(dateKey, 1);
                    }
                });
                
                userActivityMap.set(userIndex, {
                    name: userName,
                    email: userEmail,
                    dailyActivity: dailyActivity
                });
            });
            
            const data = [];
            const days = 7;
            
            for (let userIndex = 0; userIndex < Math.min(userActivityMap.size, 5); userIndex++) {
                const userData = userActivityMap.get(userIndex);
                if (!userData) continue;
                
                for (let dayIndex = 0; dayIndex < days; dayIndex++) {
                    const targetDate = new Date();
                    targetDate.setDate(targetDate.getDate() - (days - 1 - dayIndex));
                    const dateKey = targetDate.toISOString().split('T')[0];
                    
                    const activity = userData.dailyActivity.get(dateKey) || 0;
                    
                    data.push({
                        user: userIndex,
                        day: dayIndex,
                        activity: activity,
                        userName: userData.name
                    });
                }
            }
            
            console.log(`📊 히트맵 데이터 생성 완료: ${data.length}개 셀 (데이터 소스: ${members.length}명, ${rawEvents.length}개 이벤트)`);
            return data;
        }

        // 히트맵 그리기
        function drawHeatmap(ctx, width, height, data) {
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const cellWidth = (width - 100) / 7;
            const cellHeight = (height - 80) / 5;
            const startX = 80;
            const startY = 20;
            const cellSpacing = 8; // 셀 간격 추가
            
            const maxActivity = Math.max(...data.map(d => d.activity));
            
            data.forEach(item => {
                const x = startX + item.day * cellWidth;
                const y = startY + item.user * cellHeight;
                
                const intensity = item.activity / maxActivity;
                const color = getHeatmapColor(intensity);
                
                ctx.fillStyle = color;
                // 셀 간격을 고려하여 크기 조정
                ctx.fillRect(x + cellSpacing/2, y + cellSpacing/2, cellWidth - cellSpacing, cellHeight - cellSpacing);
                
                if (item.activity > 0) {
                    ctx.fillStyle = intensity > 0.5 ? '#000' : '#fff';
                    ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(item.activity.toString(), x + cellWidth/2, y + cellHeight/2);
                }
            });
        }

        // 히트맵 막대 그래프 그리기
        function drawHeatmapBarChart(ctx, width, height, data) {
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / data.length;
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0'];
            
            // 최대 활동 수 찾기
            const maxActivity = Math.max(...data.map(item => item.activity));
            
            // Y축 레이블 그리기
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (chartHeight / ySteps) * i;
                const value = Math.round((maxActivity / ySteps) * (ySteps - i));
                ctx.fillText(value.toString(), padding - 10, y);
            }
            
            // 막대 그리기
            data.forEach((item, index) => {
                const x = padding + (chartWidth / data.length) * index + barWidth * 0.1;
                const barHeight = (item.activity / maxActivity) * chartHeight;
                const y = height - padding - barHeight;
                
                // 막대 그리기
                ctx.fillStyle = colors[index % colors.length];
                ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // 막대 위에 값 표시
                ctx.fillStyle = '#e1e1e1';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.activity.toString(), x + barWidth * 0.4, y - 10);
                
                // X축 레이블 (사용자 ID)
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.userId.substring(0, 15), x + barWidth * 0.4, height - padding + 20);
            });
            
            // 제목
            ctx.fillStyle = '#e1e1e1';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('사용자별 활동 히트맵 (상위 20명)', width / 2, 25);
        }

        // 히트맵 색상 계산
        function getHeatmapColor(intensity) {
            const r = Math.floor(255 * intensity);
            const g = Math.floor(100 * (1 - intensity));
            const b = Math.floor(255 * (1 - intensity));
            return `rgb(${r}, ${g}, ${b})`;
        }

        // 히트맵 레이블 그리기
        function drawHeatmapLabels(ctx, width, height) {
            const users = [];
            if (currentMembers && currentMembers.length > 0) {
                currentMembers.slice(0, 5).forEach(member => {
                    users.push(member.name);
                });
            }
            
            const days = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dayName = date.toLocaleDateString('ko-KR', { weekday: 'short' });
                days.push(dayName);
            }
            
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            
            const cellHeight = (height - 80) / 5;
            users.forEach((user, index) => {
                const y = 20 + index * cellHeight + cellHeight/2;
                const displayName = user.length > 8 ? user.substring(0, 8) + '...' : user;
                ctx.fillText(displayName, 40, y);
            });
            
            const cellWidth = (width - 100) / 7;
            days.forEach((day, index) => {
                const x = 80 + index * cellWidth + cellWidth/2;
                ctx.fillText(day, x, 10);
            });
        }

        // 비용 효율성 분석 차트 생성
        function createCostEfficiencyChart() {
            const canvas = document.getElementById('costEfficiencyChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            const efficiencyData = generateCostEfficiencyData();
            drawScatterPlot(ctx, width, height, efficiencyData);
        }

        // 비용 효율성 데이터 생성
        function generateCostEfficiencyData() {
            const userEfficiency = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const members = chartDataStore.members.length > 0 ? chartDataStore.members : currentMembers;
            const rawEvents = chartDataStore.rawEvents.length > 0 ? chartDataStore.rawEvents : currentRawEventsData;
            
            if (!members || members.length === 0) {
                console.log('⚠️ generateCostEfficiencyData: 사용 가능한 멤버 데이터가 없습니다.');
                return [];
            }
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateCostEfficiencyData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            members.forEach(member => {
                const userEmail = member.email;
                const userName = member.name;
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail
                );
                
                const totalRequests = userEvents.length;
                const totalCost = userEvents.reduce((sum, event) => 
                    sum + (event.requestsCosts || 0), 0) / 100;
                
                if (totalRequests > 0) {
                    userEfficiency.set(userName, {
                        requests: totalRequests,
                        cost: totalCost,
                        efficiency: totalCost / totalRequests
                    });
                }
            });
            
            const result = Array.from(userEfficiency.values());
            console.log(`📊 비용 효율성 데이터 생성 완룉: ${result.length}명의 사용자 (데이터 소스: ${members.length}명, ${rawEvents.length}개 이벤트)`);
            return result;
        }

        // 스캐터 플롯 그리기
        function drawScatterPlot(ctx, width, height, data) {
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 60;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            
            const maxRequests = Math.max(...data.map(d => d.requests));
            const maxCost = Math.max(...data.map(d => d.cost));
            
            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const x = padding + (chartWidth / 5) * i;
                const y = padding + (chartHeight / 5) * i;
                
                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, height - padding);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // 데이터 포인트 그리기
            data.forEach(item => {
                const x = padding + (item.requests / maxRequests) * chartWidth;
                const y = height - padding - (item.cost / maxCost) * chartHeight;
                
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#fff';
                ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${item.requests}`, x, y - 10);
            });
            
            // 축 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('요청 수', width / 2, height - 10);
            
            ctx.save();
            ctx.translate(10, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('비용 ($)', 0, 0);
            ctx.restore();
        }

        // 모델 선호도 차트 생성
        function createModelPreferenceChart() {
            const canvas = document.getElementById('modelPreferenceChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            const preferenceData = generateModelPreferenceData();
            drawStackedBarChart(ctx, width, height, preferenceData);
        }

        // 모델 선호도 데이터 생성 (활동 기준 상위 20명, 활동 없는 사용자 제외)
        function generateModelPreferenceData() {
            // 통합 데이터 저장소에서 데이터 가져오기
            const members = chartDataStore.members.length > 0 ? chartDataStore.members : currentMembers;
            const rawEvents = chartDataStore.rawEvents.length > 0 ? chartDataStore.rawEvents : currentRawEventsData;
            
            if (!members || members.length === 0) {
                console.log('⚠️ generateModelPreferenceData: 사용 가능한 멤버 데이터가 없습니다.');
                return new Map();
            }
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateModelPreferenceData: 사용 가능한 이벤트 데이터가 없습니다.');
                return new Map();
            }
            
            // 사용자별 활동 및 모델 사용량 계산
            const userActivityData = [];
            members.forEach(member => {
                const userEmail = member.email;
                const userName = member.name;
                const userId = userEmail.split('@')[0];
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail || event.email === userEmail
                );
                
                // 활동이 없는 사용자는 제외
                if (userEvents.length === 0) {
                    return;
                }
                
                const modelUsage = new Map();
                userEvents.forEach(event => {
                    const model = event.model || 'unknown';
                    modelUsage.set(model, (modelUsage.get(model) || 0) + 1);
                });
                
                userActivityData.push({
                    userName: userName,
                    userId: userId,
                    email: userEmail,
                    totalActivity: userEvents.length,
                    modelUsage: modelUsage
                });
            });
            
            // 활동 수로 정렬하여 상위 20명 선택
            const sortedUsers = userActivityData
                .sort((a, b) => b.totalActivity - a.totalActivity)
                .slice(0, 20);
            
            // Map 형태로 변환 (기존 코드와의 호환성을 위해)
            const userModelPreference = new Map();
            sortedUsers.forEach(user => {
                userModelPreference.set(user.userId, user.modelUsage); // userId로 키 변경
            });
            
            console.log(`📊 모델 선호도 데이터 생성 완료: ${userModelPreference.size}명의 활성 사용자 (전체 ${members.length}명 중 상위 20명, ${rawEvents.length}개 이벤트)`);
            return userModelPreference;
        }

        // 스택 바 차트 그리기
        function drawStackedBarChart(ctx, width, height, data) {
            if (data.size === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / data.size;
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0'];
            
            let userIndex = 0;
            data.forEach((modelUsage, userName) => {
                const x = padding + barWidth * userIndex + barWidth * 0.1;
                const totalUsage = Array.from(modelUsage.values()).reduce((sum, count) => sum + count, 0);
                
                // 사용자 ID (userName이 이미 userId로 설정됨)
                const userId = userName;
                
                let currentY = height - padding;
                let colorIndex = 0;
                
                modelUsage.forEach((count, model) => {
                    const barHeight = (count / totalUsage) * chartHeight;
                    currentY -= barHeight;
                    
                    ctx.fillStyle = colors[colorIndex % colors.length];
                    ctx.fillRect(x, currentY, barWidth * 0.8, barHeight);
                    
                    if (barHeight > 20) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(model, x + barWidth * 0.4, currentY + barHeight / 2);
                    }
                    
                    colorIndex++;
                });
                
                // 사용자 ID (X축) - 최대 15자로 제한
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(userId.substring(0, 15), x + barWidth * 0.4, height - 10);
                
                userIndex++;
            });
        }

        // 사용자별 성과 차트 생성
        function createUserPerformanceChart() {
            console.log('🏆 createUserPerformanceChart 시작');
            
            const canvas = document.getElementById('userPerformanceChart');
            if (!canvas) {
                console.error('❌ userPerformanceChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            console.log(`📏 캔버스 크기: ${width}x${height}`);
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            const performanceData = generateUserPerformanceData();
            console.log(`📊 성과 데이터 생성 완료: ${performanceData.length}명의 사용자`);
            
            if (performanceData.length === 0) {
                console.log('⚠️ 성과 데이터가 없습니다. 로딩 메시지를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            console.log('🔄 차트 그리기 시작...', performanceData);
            drawPerformanceChart(ctx, width, height, performanceData);
            console.log('✅ 사용자별 성과 차트 생성 완료');
        }

        // 필터링된 사용자 활동 히트맵 차트 생성 (요일별 막대 그래프)
        function createFilteredUserHeatmapChart(searchTerm) {
            console.log('🔥 createFilteredUserHeatmapChart 시작:', searchTerm);
            const canvas = document.getElementById('userHeatmapChart');
            if (!canvas) {
                console.error('❌ userHeatmapChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 검색된 사용자의 요일별 활동 데이터 생성
            const weeklyData = generateWeeklyActivityData(searchTerm);
            console.log('🔥 생성된 요일별 데이터:', weeklyData);
            
            if (!weeklyData || !weeklyData.data || weeklyData.data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`검색 결과가 없습니다: "${searchTerm}"`, width / 2, height / 2);
                return;
            }
            
            // 요일별 막대 그래프 그리기
            drawWeeklyBarChart(ctx, width, height, weeklyData.data, weeklyData.userName);
            console.log('✅ 필터링된 사용자 활동 히트맵 차트 생성 완료');
        }

        // 요일별 활동 데이터 생성
        function generateWeeklyActivityData(searchTerm) {
            console.log('🔥 generateWeeklyActivityData 시작:', searchTerm);
            
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            if (!members || members.length === 0 || !rawEvents || rawEvents.length === 0) {
                console.log('⚠️ 데이터가 부족합니다.');
                return [];
            }
            
            // 검색어와 일치하는 사용자 찾기 (ID 기반)
            const matchedUser = members.find(member => {
                const emailId = member.email.split('@')[0];
                return emailId.toLowerCase() === searchTerm.toLowerCase();
            });
            
            if (!matchedUser) {
                console.log('⚠️ 검색된 사용자를 찾을 수 없습니다.');
                return null;
            }
            
            // 해당 사용자의 이벤트 필터링
            const userEvents = rawEvents.filter(event => 
                event.userEmail === matchedUser.email || event.email === matchedUser.email
            );
            
            // 요일별 활동 수 계산
            const weeklyActivity = new Map();
            const dayNames = ['일', '월', '화', '수', '목', '금', '토'];
            
            userEvents.forEach(event => {
                const eventDate = new Date(parseInt(event.timestamp));
                const dayOfWeek = eventDate.getDay();
                const dayName = dayNames[dayOfWeek];
                
                weeklyActivity.set(dayName, (weeklyActivity.get(dayName) || 0) + 1);
            });
            
            // 모든 요일에 대해 데이터 생성 (활동이 없는 요일은 0)
            const data = dayNames.map(dayName => ({
                day: dayName,
                activity: weeklyActivity.get(dayName) || 0
            }));
            
            console.log(`🔥 요일별 활동 데이터 생성 완료: ${matchedUser.name} (${data.length}일)`);
            console.log('🔥 최종 데이터:', data);
            return {
                data: data,
                userName: matchedUser.name,
                userEmail: matchedUser.email
            };
        }

        // 요일별 막대 그래프 그리기
        function drawWeeklyBarChart(ctx, width, height, data, userName) {
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / data.length;
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0', '#00bcd4', '#ff5722'];
            
            // 최대 활동 수 찾기
            const maxActivity = Math.max(...data.map(item => item.activity));
            
            // Y축 레이블 그리기 (히트수)
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (chartHeight / ySteps) * i;
                const value = Math.round((maxActivity / ySteps) * (ySteps - i));
                ctx.fillText(value.toString(), padding - 10, y);
            }
            
            // Y축 제목 (히트수)
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('히트수', 0, 0);
            ctx.restore();
            
            // 막대 그리기
            data.forEach((item, index) => {
                const x = padding + (chartWidth / data.length) * index + barWidth * 0.1;
                const barHeight = maxActivity > 0 ? (item.activity / maxActivity) * chartHeight : 0;
                const y = height - padding - barHeight;
                
                // 막대 그리기
                ctx.fillStyle = colors[index % colors.length];
                ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // 막대 위에 값 표시
                ctx.fillStyle = '#e1e1e1';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.activity.toString(), x + barWidth * 0.4, y - 10);
                
                // X축 레이블 (요일)
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.day, x + barWidth * 0.4, height - padding + 20);
            });
            
            // 제목
            ctx.fillStyle = '#e1e1e1';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${userName}의 요일별 히트수`, width / 2, 25);
        }

        // 필터링된 사용자별 성과 차트 생성
        function createFilteredUserPerformanceChart(searchTerm) {
            const canvas = document.getElementById('userPerformanceChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 전체 성과 데이터에서 검색어와 일치하는 사용자만 필터링
            const allPerformanceData = generateUserPerformanceData();
            const filteredData = allPerformanceData.filter(user => 
                user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                user.email.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            if (filteredData.length === 0) {
                // 검색 결과가 없을 때 메시지 표시
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`검색 결과가 없습니다: "${searchTerm}"`, width / 2, height / 2);
                return;
            }
            
            // 필터링된 데이터로 차트 그리기
            drawPerformanceChart(ctx, width, height, filteredData);
            
            console.log(`✅ 필터링된 사용자별 성과 차트 생성 완료: "${searchTerm}" - ${filteredData.length}명의 사용자`);
        }

        // 필터링된 사용자 활동 히트맵 차트 생성 (요일별 히트수)
        function createFilteredUserHeatmapChart(searchTerm) {
            console.log('🔥 createFilteredUserHeatmapChart 시작:', searchTerm);
            const canvas = document.getElementById('userHeatmapChart');
            if (!canvas) {
                console.error('❌ userHeatmapChart 캔버스를 찾을 수 없습니다.');
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 검색된 사용자의 요일별 활동 데이터 생성
            const weeklyData = generateWeeklyActivityData(searchTerm);
            console.log('🔥 생성된 요일별 데이터:', weeklyData);
            
            if (!weeklyData || !weeklyData.data || weeklyData.data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`검색 결과가 없습니다: "${searchTerm}"`, width / 2, height / 2);
                return;
            }
            
            // 요일별 막대 그래프 그리기
            drawWeeklyBarChart(ctx, width, height, weeklyData.data, weeklyData.userName);
            console.log('✅ 필터링된 사용자 활동 히트맵 차트 생성 완료');
        }

        // 필터링된 모델 선호도 차트 생성
        function createFilteredModelPreferenceChart(searchTerm) {
            const canvas = document.getElementById('modelPreferenceChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 검색 결과가 없을 때 메시지 표시
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`모델 선호도 검색 기능 준비 중...`, width / 2, height / 2);
            
            console.log(`✅ 필터링된 모델 선호도 차트 생성 완료: "${searchTerm}"`);
        }

        // 사용자별 성과 데이터 생성
        function generateUserPerformanceData() {
            const userPerformance = [];
            
            // 현재 데이터에서 가져오기 (chartDataStore 우선, 없으면 전역 변수 사용)
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembersData || []);
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            console.log(`🔍 사용자별 성과 데이터 생성 시작: 멤버 ${members.length}명, 이벤트 ${rawEvents.length}개`);
            
            if (!members || members.length === 0) {
                console.log('⚠️ generateUserPerformanceData: 사용 가능한 멤버 데이터가 없습니다.');
                return [];
            }
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateUserPerformanceData: 사용 가능한 이벤트 데이터가 없습니다.');
                return [];
            }
            
            members.forEach(member => {
                const userEmail = member.email;
                const userName = member.name;
                
                // 이메일 필드명 확인 (userEmail 또는 email)
                const userEvents = rawEvents.filter(event => {
                    const eventEmail = event.userEmail || event.email;
                    return eventEmail === userEmail;
                });
                
                const totalRequests = userEvents.length;
                const totalCost = userEvents.reduce((sum, event) => 
                    sum + (event.requestsCosts || 0), 0) / 100;
                const uniqueDays = new Set(userEvents.map(event => 
                    new Date(parseInt(event.timestamp)).toDateString())).size;
                
                if (totalRequests > 0) {
                    userPerformance.push({
                        name: userName,
                        email: userEmail,
                        requests: totalRequests,
                        cost: totalCost,
                        activeDays: uniqueDays,
                        efficiency: totalRequests / uniqueDays || 0
                    });
                }
            });
            
            const result = userPerformance.sort((a, b) => b.requests - a.requests).slice(0, 50);
            console.log(`📊 사용자별 성과 데이터 생성 완료: ${result.length}명의 사용자 (상위 50명, 전체: ${userPerformance.length}명)`);
            return result;
        }

        // 성과 차트 그리기
        function drawPerformanceChart(ctx, width, height, data) {
            console.log(`🎨 차트 그리기 시작: 데이터 ${data.length}개, 캔버스 크기 ${width}x${height}`);
            
            if (data.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = Math.max(4, chartWidth / data.length); // 최소 4px 너비 보장
            const maxRequests = Math.max(...data.map(d => d.requests));
            
            console.log(`📊 차트 설정: 패딩=${padding}, 차트크기=${chartWidth}x${chartHeight}, 바너비=${barWidth}, 최대요청=${maxRequests}`);
            
            // 배경 지우기
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 그리드
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= 5; i++) {
                const y = padding + (chartHeight / 5) * i;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
                
                // Y축 라벨
                const value = Math.round((maxRequests * (5 - i)) / 5);
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(value.toString(), padding - 10, y + 4);
            }
            
            // 바 차트
            data.forEach((user, index) => {
                const x = padding + barWidth * index + barWidth * 0.1;
                const barHeight = Math.max(1, (user.requests / maxRequests) * chartHeight);
                const y = height - padding - barHeight;
                
                // 바 그리기
                ctx.fillStyle = '#4a9eff';
                ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // 요청 수 (바 위에)
                if (barHeight > 20) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(user.requests.toString(), x + barWidth * 0.4, y - 5);
                }
                
                // 이메일 ID (X축 아래) - @samsung.com 제외
                if (barWidth > 20) {
                    ctx.fillStyle = '#7a7a7a';
                    ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.save();
                    ctx.translate(x + barWidth * 0.4, height - 15);
                    ctx.rotate(-Math.PI / 4);
                    const emailId = user.email.split('@')[0]; // @samsung.com 제외하고 ID만 추출
                    ctx.fillText(emailId.substring(0, 8), 0, 0); // 최대 8글자까지 표시
                    ctx.restore();
                }
            });
            
            // 범례 그리기 (오른쪽 상단)
            drawPerformanceLegend(ctx, width, height);
            
            console.log('✅ 차트 그리기 완료');
        }

        // 성과 차트 범례 그리기
        function drawPerformanceLegend(ctx, width, height) {
            const legendX = width - 200;
            const legendY = 30;
            const itemHeight = 18;
            const itemSpacing = 5;
            
            // 범례 배경
            ctx.fillStyle = 'rgba(26, 26, 26, 0.9)';
            ctx.fillRect(legendX - 10, legendY - 10, 190, 120);
            
            // 범례 테두리
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            ctx.strokeRect(legendX - 10, legendY - 10, 190, 120);
            
            // 범례 제목
            ctx.fillStyle = '#e1e1e1';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('📊 계산 지표', legendX, legendY);
            
            // 범례 항목들
            const legendItems = [
                { label: '총 요청 수', description: '사용자별 이벤트 개수' },
                { label: '총 비용', description: 'requestsCosts 합계 ÷ 100' },
                { label: '활동 일수', description: '고유한 활동 날짜 수' },
                { label: '효율성', description: '총 요청 수 ÷ 활동 일수' },
                { label: '정렬 기준', description: '요청 수 내림차순' }
            ];
            
            legendItems.forEach((item, index) => {
                const y = legendY + 20 + (itemHeight + itemSpacing) * index;
                
                // 라벨
                ctx.fillStyle = '#4a9eff';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText(item.label, legendX, y);
                
                // 설명
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.fillText(item.description, legendX, y + 12);
            });
        }

        // 활동 유형 상세 차트 생성
        function createActivityTypeDetailedChart() {
            const canvas = document.getElementById('activityTypeDetailedChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            const detailedData = generateActivityTypeDetailedData();
            drawDetailedBarChart(ctx, width, height, detailedData);
        }

        // 활동 유형 상세 데이터 생성
        function generateActivityTypeDetailedData() {
            const activityDetails = new Map();
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const rawEvents = chartDataStore.rawEvents.length > 0 ? chartDataStore.rawEvents : currentRawEventsData;
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateActivityTypeDetailedData: 사용 가능한 이벤트 데이터가 없습니다.');
                return new Map();
            }
            
            rawEvents.forEach(event => {
                const type = event.kind || 'unknown';
                const model = event.model || 'unknown';
                const cost = (event.requestsCosts || 0) / 100;
                
                if (!activityDetails.has(type)) {
                    activityDetails.set(type, {
                        count: 0,
                        totalCost: 0,
                        models: new Map(),
                        users: new Set()
                    });
                }
                
                const details = activityDetails.get(type);
                details.count++;
                details.totalCost += cost;
                details.models.set(model, (details.models.get(model) || 0) + 1);
                details.users.add(event.userEmail);
            });
            
            console.log(`📊 활동 유형 상세 데이터 생성 완룉: ${activityDetails.size}개 유형 (데이터 소스: ${rawEvents.length}개 이벤트)`);
            return activityDetails;
        }

        // 상세 바 차트 그리기
        function drawDetailedBarChart(ctx, width, height, data) {
            if (data.size === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 80;
            const chartWidth = width - 2 * padding;
            const chartHeight = height - 2 * padding;
            const barWidth = chartWidth / data.size;
            const maxCount = Math.max(...Array.from(data.values()).map(d => d.count));
            
            let index = 0;
            data.forEach((details, type) => {
                const x = padding + barWidth * index + barWidth * 0.1;
                const barHeight = (details.count / maxCount) * chartHeight;
                const y = height - padding - barHeight;
                
                // 메인 바
                ctx.fillStyle = '#4a9eff';
                ctx.fillRect(x, y, barWidth * 0.8, barHeight);
                
                // 정보 텍스트
                ctx.fillStyle = '#fff';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(details.count.toString(), x + barWidth * 0.4, y - 10);
                
                // 활동 유형
                ctx.fillStyle = '#7a7a7a';
                ctx.fillText(type, x + barWidth * 0.4, height - 10);
                
                // 추가 정보
                ctx.fillStyle = '#ff9800';
                ctx.fillText(`$${details.totalCost.toFixed(2)}`, x + barWidth * 0.4, height - 25);
                ctx.fillStyle = '#4caf50';
                ctx.fillText(`${details.users.size}명`, x + barWidth * 0.4, height - 40);
                
                index++;
            });
        }

        // 차트 생성 (Overview용)
        function createOverviewChart() {
            const canvas = document.getElementById('overviewChart');
            if (!canvas) return;
           
            // Canvas 크기 설정
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
           
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
           
            // 배경 설정
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 현재 필터 상태 확인
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
            
            // 일별 활동 데이터 생성
            const dailyData = generateDailyActivityData(dateRange);
            
            if (dailyData.length === 0) {
                // 데이터가 없을 때 메시지 표시
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
           
            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
           
            // 세로 그리드
            for (let i = 0; i <= dailyData.length; i++) {
                const x = (width / dailyData.length) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
           
            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // 최대값 계산
            const maxValue = Math.max(...dailyData.map(d => d.value));
            
            // 데이터 포인트 생성
            const dataPoints = dailyData.map((data, index) => ({
                x: (width / dailyData.length) * index + (width / dailyData.length / 2),
                y: height - (height * (data.value / maxValue)) - 20
            }));
           
            // 선 그래프 그리기
            ctx.strokeStyle = '#4a9eff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(dataPoints[0].x, dataPoints[0].y);
           
            for (let i = 1; i < dataPoints.length; i++) {
                ctx.lineTo(dataPoints[i].x, dataPoints[i].y);
            }
            ctx.stroke();
           
            // 데이터 포인트 원 그리기
            dataPoints.forEach(point => {
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });
           
            // 날짜 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
           
            dailyData.forEach((data, index) => {
                const x = (width / dailyData.length) * index + (width / dailyData.length / 2);
                ctx.fillText(data.date, x, height - 10);
            });
        }
        
        // 일별 활동 데이터 생성 함수
        function generateDailyActivityData(dateRange) {
            const dailyData = [];
            
            // 통합 데이터 저장소에서 데이터 가져오기
            const rawEvents = chartDataStore.rawEvents.length > 0 ? chartDataStore.rawEvents : currentRawEventsData;
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ generateDailyActivityData: 사용 가능한 이벤트 데이터가 없습니다.');
                return dailyData;
            }
            
            // 날짜별 활동 수 집계
            const dailyActivity = new Map();
            
            rawEvents.forEach(event => {
                const eventDate = new Date(parseInt(event.timestamp));
                const dateKey = eventDate.toISOString().split('T')[0];
                
                if (eventDate >= dateRange.startDate && eventDate <= dateRange.endDate) {
                    dailyActivity.set(dateKey, (dailyActivity.get(dateKey) || 0) + 1);
                }
            });
            
            // 날짜 범위 내 모든 날짜에 대해 데이터 생성
            const startDate = new Date(dateRange.startDate);
            const endDate = new Date(dateRange.endDate);
            
            for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                const dateKey = d.toISOString().split('T')[0];
                const dateStr = `${d.getMonth() + 1}/${d.getDate()}`;
                
                dailyData.push({
                    date: dateStr,
                    value: dailyActivity.get(dateKey) || 0
                });
            }
            
            return dailyData;
        }

        // 스크롤 위치 관리 객체
        const scrollPositions = {
            overview: 0,
            members: 0,
            usage: 0,
            settings: 0
        };
        
        // 섹션별 최초 방문 여부 추적
        const sectionVisited = {
            overview: false,
            members: false,
            usage: false,
            settings: false
        };

        // 메뉴 클릭 이벤트 처리
        document.querySelectorAll('.menu-item').forEach(item => {
            item.addEventListener('click', function(e) {
                e.preventDefault();
               
                // 현재 활성 섹션의 스크롤 위치 저장
                const currentActiveSection = document.querySelector('.content-section.active');
                if (currentActiveSection) {
                    const currentSectionName = currentActiveSection.id;
                    scrollPositions[currentSectionName] = currentActiveSection.scrollTop;
                }
               
                // 모든 메뉴 아이템에서 active 클래스 제거
                document.querySelectorAll('.menu-item').forEach(menu => {
                    menu.classList.remove('active');
                });
               
                // 클릭된 메뉴에 active 클래스 추가
                this.classList.add('active');
               
                // 모든 콘텐츠 섹션 숨기기
                document.querySelectorAll('.content-section').forEach(section => {
                    section.classList.remove('active');
                });
               
                // 선택된 섹션 표시
                const sectionName = this.getAttribute('data-section');
                const targetSection = document.getElementById(sectionName);
                if (targetSection) {
                    targetSection.classList.add('active');
                    
                    // 스크롤 위치 설정
                    setTimeout(() => {
                        if (!sectionVisited[sectionName]) {
                            // 최초 방문 시 상단으로 스크롤
                            targetSection.scrollTop = 0;
                            sectionVisited[sectionName] = true;
                            console.log(`${sectionName} 섹션 최초 방문 - 상단으로 스크롤`);
                        } else {
                            // 이후 방문 시 이전 스크롤 위치로 복원
                            targetSection.scrollTop = scrollPositions[sectionName];
                            console.log(`${sectionName} 섹션 재방문 - 이전 위치로 스크롤: ${scrollPositions[sectionName]}px`);
                        }
                    }, 50);
                }
               
                // 헤더 제목 업데이트
                const pageTitle = document.getElementById('page-title');
               
                switch(sectionName) {
                    case 'overview':
                        pageTitle.textContent = 'Dashboard Overview';
                        // Overview 메뉴 클릭 시 현재 필터 상태 유지하면서 데이터만 새로고침
                        setTimeout(async () => {
                            console.log('=== Overview 메뉴 클릭 시 자동 실제 API 데이터 새로고침 시작 ===');
                            await refreshAllRealData(); // 자동 새로고침 (현재 필터 상태 유지)
                        }, 100);
                        break;
                    case 'members':
                        pageTitle.textContent = 'Dashboard Members';
                        // Members 메뉴 클릭 시 자동 새로고침
                        setTimeout(async () => {
                            console.log('=== Members 메뉴 클릭 시 자동 실제 API 데이터 새로고침 시작 ===');
                            await updateMembersWithRealData();
                        }, 100);
                        break;
                    case 'usage':
                        pageTitle.textContent = 'Usage Analytics';
                        // Usage 메뉴 클릭 시 조건부 데이터 로딩
                        setTimeout(async () => {
                            if (!isUsageDataLoaded) {
                                console.log('=== Usage 메뉴 첫 번째 클릭 - 데이터 로딩 시작 ===');
                                // 초기 필터 기간 표시 설정 (30일)
                                const initialDateRange = getDateRange(30);
                                updateUsageFilterPeriodDisplay(initialDateRange.startDate, initialDateRange.endDate);
                                await updateUsageWithCurrentFilter(30, true); // 첫 번째 로딩
                            } else {
                                console.log('=== Usage 메뉴 재클릭 - 백그라운드 데이터 갱신 ===');
                                updateUsageWithCurrentFilter(30, false); // 백그라운드 로딩
                            }
                        }, 100);
                        break;
                    case 'settings':
                        pageTitle.textContent = 'Settings';
                        break;
                    default:
                        pageTitle.textContent = sectionName.charAt(0).toUpperCase() + sectionName.slice(1);
                }
            });
        });

        // 아코디언 토글 함수
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const arrow = header.querySelector('.accordion-arrow');
           
            // 다른 모든 아코디언 닫기
            document.querySelectorAll('.accordion-content').forEach(otherContent => {
                if (otherContent !== content) {
                    otherContent.classList.remove('active');
                    otherContent.previousElementSibling.querySelector('.accordion-arrow').textContent = '▼';
                }
            });
           
            // 현재 아코디언 토글
            if (content.classList.contains('active')) {
                content.classList.remove('active');
                arrow.textContent = '▼';
            } else {
                content.classList.add('active');
                arrow.textContent = '▲';
            }
        }

        // 예약 메일 발송 활성화 상태
        let emailSchedulerActive = false;

        // 토글 스위치 함수
        function toggleSwitch(toggle) {
            toggle.classList.toggle('off');
            
            // 예약 메일 발송 관리 토글인지 확인
            const settingItem = toggle.closest('.setting-item');
            if (settingItem) {
                const label = settingItem.querySelector('.setting-label');
                if (label && label.textContent === '예약 메일 발송 관리') {
                    const isActive = !toggle.classList.contains('off');
                    handleEmailSchedulerToggle(isActive);
                }
                // 자동 백업 토글인지 확인
                if (label && label.textContent === '자동 백업') {
                    const isBackupActive = !toggle.classList.contains('off');
                    handleBackupToggle(isBackupActive);
                }
            }
        }

        // 예약 메일 발송 활성화 토글 처리
        function handleEmailSchedulerToggle(isActive) {
            emailSchedulerActive = isActive;
            
            if (isActive) {
                console.log('✅ 예약 메일 발송 활성화됨 - 백그라운드 체크 시작');
                startEmailScheduler();
                // 설정 UI 표시
                const freqEl = document.getElementById('email-frequency-setting');
                const timeEl = document.getElementById('email-time-setting');
                if (freqEl) freqEl.style.display = '';
                if (timeEl) timeEl.style.display = '';
            } else {
                console.log('❌ 예약 메일 발송 비활성화됨 - 백그라운드 체크 중지');
                stopEmailScheduler();
                // 설정 UI 숨김
                const freqEl = document.getElementById('email-frequency-setting');
                const timeEl = document.getElementById('email-time-setting');
                if (freqEl) freqEl.style.display = 'none';
                if (timeEl) timeEl.style.display = 'none';
            }
        }

        // 자동 백업 토글 처리
        function handleBackupToggle(isActive) {
            const freqEl = document.getElementById('backup-frequency-setting');
            const timeEl = document.getElementById('backup-time-setting');
            const locEl = document.getElementById('backup-location-setting');

            if (isActive) {
                if (freqEl) freqEl.style.display = '';
                if (timeEl) timeEl.style.display = '';
                if (locEl) locEl.style.display = '';
                // 초기 시간 드롭다운 동기화
                initializeBackupTimeDropdowns();
            } else {
                if (freqEl) freqEl.style.display = 'none';
                if (timeEl) timeEl.style.display = 'none';
                if (locEl) locEl.style.display = 'none';
            }
        }

        // 백업 시간 드롭다운 → 숨겨진 time input 동기화
        function updateBackupTimeInput() {
            const hourSelect = document.getElementById('backup-hour-select');
            const minuteSelect = document.getElementById('backup-minute-select');
            const timeInput = document.getElementById('backup-time-input');
            if (hourSelect && minuteSelect && timeInput) {
                const hour = String(hourSelect.value).padStart(2, '0');
                const minute = String(minuteSelect.value).padStart(2, '0');
                timeInput.value = `${hour}:${minute}`;
                console.log(`⏰ 백업 시간 드롭다운 업데이트: ${timeInput.value}`);
            }
        }

        // 페이지 로드 시 백업 시간 드롭다운 초기화
        function initializeBackupTimeDropdowns() {
            const timeInput = document.getElementById('backup-time-input');
            const hourSelect = document.getElementById('backup-hour-select');
            const minuteSelect = document.getElementById('backup-minute-select');
            if (timeInput && hourSelect && minuteSelect && timeInput.value.includes(':')) {
                const [hours, minutes] = timeInput.value.split(':');
                hourSelect.value = hours;
                minuteSelect.value = minutes;
                console.log(`⏰ 백업 시간 드롭다운 초기화: ${hours}:${minutes}`);
            }
        }

        // 예약 리스트 변경 시 스케줄러 상태 재확인
        function checkSchedulerStatus() {
            if (!emailSchedulerActive) {
                return; // 토글이 비활성화되어 있으면 무시
            }

            // 예약된 메일이 없거나 활성 상태인 예약이 없으면 스케줄러 중지
            if (!window.emailScheduleList || window.emailScheduleList.length === 0) {
                console.log('📭 예약된 메일이 없어 스케줄러를 중지합니다.');
                stopEmailScheduler();
                return;
            }

            const activeSchedules = window.emailScheduleList.filter(schedule => 
                schedule.status === '활성'
            );

            if (activeSchedules.length === 0) {
                console.log('📭 활성 상태인 예약된 메일이 없어 스케줄러를 중지합니다.');
                stopEmailScheduler();
                return;
            }

            // 활성 예약이 있지만 스케줄러가 실행 중이 아니면 시작
            if (!isSchedulerRunning) {
                console.log(`📅 활성 예약이 발견되어 스케줄러를 시작합니다. (활성 예약: ${activeSchedules.length}개)`);
                startEmailScheduler();
            }
        }

        // 첨부 파일 - 사용량 토글 처리
        function handleUsageAttachmentToggle(checkbox) {
            const settings = document.getElementById('usage-attachment-settings');
            if (!settings) return;
            settings.style.display = checkbox && checkbox.checked ? '' : 'none';
        }
        // 첨부 파일 - 타겟 토글 처리 (전체/비활성/직접입력)
        function handleAttachmentTargetToggle(target, checkbox) {
            const allSec = document.getElementById('attachment-all-section');
            const inactiveSec = document.getElementById('attachment-inactive-section');
            const customSec = document.getElementById('attachment-custom-section');
            const usageSettings = document.getElementById('usage-attachment-settings');
            if (!allSec || !inactiveSec || !customSec || !usageSettings) return;

            // 섹션 열기/닫기
            if (target === 'all') {
                allSec.style.display = checkbox.checked ? '' : 'none';
                if (!checkbox.checked) document.getElementById('attachment-all-usage').checked = false;
            } else if (target === 'inactive') {
                inactiveSec.style.display = checkbox.checked ? '' : 'none';
                if (!checkbox.checked) document.getElementById('attachment-inactive-usage').checked = false;
            } else if (target === 'custom') {
                customSec.style.display = checkbox.checked ? '' : 'none';
                if (!checkbox.checked) document.getElementById('attachment-custom-usage').checked = false;
            }

            // 사용량 설정 패널은 전역 1개를 상황에 따라 이동/표시
            if (checkbox && checkbox.checked) {
                window._lastAttachmentTarget = target;
                setActiveUsageTarget(target);
            } else {
                // 선택 해제 시 마지막 대상이었으면 대체 타겟 선택: custom > inactive > all
                const allChecked = !!document.getElementById('attachment-all-members')?.checked;
                const inactiveChecked = !!document.getElementById('attachment-inactive-members')?.checked;
                const customChecked = !!document.getElementById('attachment-custom')?.checked;
                let next = null;
                if (customChecked) next = 'custom';
                else if (inactiveChecked) next = 'inactive';
                else if (allChecked) next = 'all';
                setActiveUsageTarget(next);
            }
            refreshUsageAttachmentSettingsPlacement();
            enforceAttachmentSectionOrder();
        }

        // 사용량 체크박스별로 설정 패널 표시 위치/상태 갱신
        function toggleAttachmentUsageSection(target, checkbox) {
            const usageSettings = document.getElementById('usage-attachment-settings');
            if (!usageSettings) return;
            // 체크되었을 때만 패널 표시. 해당 섹션의 "사용량" 라벨 바로 아래로 이동
            const map = { all: 'attachment-all-usage', inactive: 'attachment-inactive-usage', custom: 'attachment-custom-usage' };
            const usageInput = document.getElementById(map[target]);
            if (checkbox && checkbox.checked && usageInput) {
                const labelEl = usageInput.closest('label');
                if (labelEl && labelEl.parentNode) {
                    labelEl.parentNode.insertBefore(usageSettings, labelEl.nextSibling);
                }
                usageSettings.style.display = '';
                enforceAttachmentSectionOrder();

                // 사용량 활성 시 기간 기본값을 30d로 설정 (미설정/기본 문구인 경우)
                const periodTextEl = document.getElementById('usage-attachment-period-text');
                if (periodTextEl && (!periodTextEl.textContent || periodTextEl.textContent.trim() === '' || periodTextEl.textContent.trim() === '기간을 선택하세요')) {
                    // 버튼 active 상태도 30d로 설정
                    selectUsageAttachmentPeriod('30');
                }
                // 테이블 업데이트
                updateAttachmentUsageTable();
            } else {
                usageSettings.style.display = 'none';
            }
        }

        // 현재 체크 상태를 기반으로 패널 재배치
        function refreshUsageAttachmentSettingsPlacement() {
            const usageSettings = document.getElementById('usage-attachment-settings');
            if (!usageSettings) return;
            const allUsage = document.getElementById('attachment-all-usage');
            const inactiveUsage = document.getElementById('attachment-inactive-usage');
            const customUsage = document.getElementById('attachment-custom-usage');
            // 고정 순서: 전체 멤버 → 비활성 멤버 → 직접 입력
            const order = [allUsage, inactiveUsage, customUsage];
            const checkedInput = order.find(inp => inp && inp.checked);
            if (checkedInput) {
                const labelEl = checkedInput.closest('label');
                if (labelEl && labelEl.parentNode) {
                    labelEl.parentNode.insertBefore(usageSettings, labelEl.nextSibling);
                }
                usageSettings.style.display = '';
                enforceAttachmentSectionOrder();
                // 기본 기간 30d 보장 및 테이블 갱신
                const periodTextEl = document.getElementById('usage-attachment-period-text');
                if (periodTextEl && (!periodTextEl.textContent || periodTextEl.textContent.trim() === '' || periodTextEl.textContent.trim() === '기간을 선택하세요')) {
                    selectUsageAttachmentPeriod('30');
                }
                updateAttachmentUsageTable();
            } else {
                usageSettings.style.display = 'none';
            }
        }

        // 첨부 파일 섹션(전체 → 비활성 → 직접 입력) DOM 순서를 항상 강제
        function enforceAttachmentSectionOrder() {
            try {
                const allSec = document.getElementById('attachment-all-section');
                const inactiveSec = document.getElementById('attachment-inactive-section');
                const customSec = document.getElementById('attachment-custom-section');
                if (!allSec || !inactiveSec || !customSec) return;
                const parent = allSec.parentNode;
                if (!parent) return;
                // 원하는 순서로 재배치 (appendChild는 기존 노드를 이동시킴)
                parent.appendChild(allSec);
                parent.appendChild(inactiveSec);
                parent.appendChild(customSec);
            } catch (_) {}
        }

        // 사용량 체크박스는 한 섹션에만 노출되도록 제어
        function setActiveUsageTarget(target) {
            const map = {
                all: document.getElementById('attachment-all-usage')?.closest('label'),
                inactive: document.getElementById('attachment-inactive-usage')?.closest('label'),
                custom: document.getElementById('attachment-custom-usage')?.closest('label')
            };
            // 모두 숨김
            Object.values(map).forEach(lbl => { if (lbl) lbl.style.display = 'none'; });
            // 모두 체크 해제 (한 곳만 사용량 사용하도록 강제)
            const allU = document.getElementById('attachment-all-usage');
            const inU = document.getElementById('attachment-inactive-usage');
            const cuU = document.getElementById('attachment-custom-usage');
            if (allU) allU.checked = false;
            if (inU) inU.checked = false;
            if (cuU) cuU.checked = false;
            
            if (target && map[target]) {
                map[target].style.display = 'flex';
            }
        }

        // 첨부 리스트 렌더링 (검색/정렬/페이지네이션 + 비활성 N일 기준)
        function renderAttachmentMemberLists() {
            try {
                const allList = document.getElementById('attachment-all-list');
                const inactiveList = document.getElementById('attachment-inactive-list');
                if (!allList || !inactiveList) return;

                const baseMembers = (originalMembersData && originalMembersData.length ? originalMembersData : currentMembersData) || [];
                if (!baseMembers || baseMembers.length === 0) {
                    allList.innerHTML = '<div style="color:#7a7a7a;">표시할 멤버가 없습니다.</div>';
                    inactiveList.innerHTML = '<div style="color:#7a7a7a;">표시할 멤버가 없습니다.</div>';
                    return;
                }

                // 주의: allowedEvents/lastEventMap은 렌더 시마다 최신 전역 데이터로 재계산해야 함(초기 빈 데이터 캡쳐 방지)

                // 상태 초기화
                window.attachmentAllState = window.attachmentAllState || { page: 1, pageSize: 20, search: '', sort: 'name_asc' };
                window.attachmentInactiveState = window.attachmentInactiveState || { page: 1, pageSize: 20, search: '', sort: 'name_asc', days: 14 };

                function renderList(type) {
                    const state = type === 'all' ? window.attachmentAllState : window.attachmentInactiveState;

                    // 최신 이벤트로 lastEventMap/allowedEvents 재계산 (전역 let과 window 프로퍼티 모두 대응)
                    const rawEventsNow = (typeof currentRawEventsData !== 'undefined' && Array.isArray(currentRawEventsData) ? currentRawEventsData : (window.currentRawEventsData || []));
                    const allowedEventsNow = rawEventsNow.filter(ev => ev && ev.userEmail && typeof ev.requestsCosts === 'number' && ev.requestsCosts > 0 && !isNaN(parseInt(ev.timestamp)));
                    const lastEventMapNow = {};
                    for (const ev of allowedEventsNow) {
                        const email = ev.userEmail;
                        const ts = parseInt(ev.timestamp);
                        if (!lastEventMapNow[email] || ts > lastEventMapNow[email]) {
                            lastEventMapNow[email] = ts;
                        }
                    }

                    // 진단 로그: 렌더 타이밍 데이터 상태
                    try {
                        const tsValues = rawEventsNow.map(e => parseInt(e.timestamp)).filter(v => !isNaN(v));
                        const minTs = tsValues.length ? Math.min(...tsValues) : null;
                        const maxTs = tsValues.length ? Math.max(...tsValues) : null;
                        console.group(`[첨부파일/비활성] 렌더 진단 (${type})`);
                        console.log('멤버 수:', baseMembers.length);
                        console.log('Raw 이벤트 수:', rawEventsNow.length, '범위:', minTs ? new Date(minTs).toISOString() : '-', '~', maxTs ? new Date(maxTs).toISOString() : '-');
                        console.log('활동 인정(>0) 이벤트 수:', allowedEventsNow.length);
                        console.groupEnd();
                    } catch (e) {}

                    let members = baseMembers.map(m => ({
                        ...m,
                        lastActivityTimestamp: lastEventMapNow[m.email] || 0
                    }));

                    // 비활성 기준: 최근 N일 무활동 (Overview와 동일한 활동 정의로 계산)
                    if (type === 'inactive') {
                        const cutoff = Date.now() - (state.days * 24 * 60 * 60 * 1000);
                        const activeEmails = new Set();
                        let eventsWithinCutoff = 0;
                        for (const ev of allowedEventsNow) {
                            const ts = parseInt(ev.timestamp);
                            if (ts >= cutoff) { activeEmails.add(ev.userEmail); eventsWithinCutoff++; }
                        }
                        members = members.filter(m => !activeEmails.has(m.email));
                        // 제목에 현재 비활성 수 표기
                        try {
                            const titleEl = document.getElementById('attachment-inactive-title');
                            if (titleEl) {
                                titleEl.textContent = `비활성 멤버 리스트 (${members.length})`;
                            }
                        } catch (e) {
                            // no-op
                        }
                        // 진단 로그: 필터 결과
                        try {
                            console.group('[첨부파일/비활성] 필터 결과');
                            console.log('선택 N일:', state.days);
                            console.log('컷오프 시각:', new Date(cutoff).toISOString());
                            console.log('컷오프 내 이벤트 수:', eventsWithinCutoff);
                            console.log('활성 이메일 수(N일 내):', activeEmails.size);
                            console.log('비활성 결과 멤버 수:', members.length);
                            console.groupEnd();
                        } catch (e) {}
                    }

                    // 검색
                    if (state.search && state.search.trim()) {
                        const q = state.search.trim().toLowerCase();
                        members = members.filter(m => (m.name || '').toLowerCase().includes(q) || (m.email || '').toLowerCase().includes(q));
                    }

                    // 정렬
                    const [field, dir] = state.sort.split('_');
                    members.sort((a, b) => {
                        if (field === 'last') {
                            const at = a.lastActivityTimestamp || 0;
                            const bt = b.lastActivityTimestamp || 0;
                            return dir === 'asc' ? at - bt : bt - at;
                        }
                        const av = field === 'email' ? (a.email || '') : (a.name || '');
                        const bv = field === 'email' ? (b.email || '') : (b.name || '');
                        return dir === 'asc' ? av.localeCompare(bv) : bv.localeCompare(av);
                    });

                    // 페이지네이션
                    const total = members.length;
                    const totalPages = Math.max(1, Math.ceil(total / state.pageSize));
                    if (state.page > totalPages) state.page = totalPages;
                    const start = (state.page - 1) * state.pageSize;
                    const pageData = members.slice(start, start + state.pageSize);

                    // 렌더링
                    const listEl = document.getElementById(type === 'all' ? 'attachment-all-list' : 'attachment-inactive-list');
                    listEl.innerHTML = pageData.map(m => `<div style=\"display:flex; justify-content:space-between; padding:6px 8px; border-bottom:1px solid #2a2a2a;\"><span>${m.name || m.email}</span><span style=\"color:#7a7a7a;\">${m.email || ''}</span></div>`).join('');
                    if (pageData.length === 0) {
                        listEl.innerHTML = '<div style=\"color:#7a7a7a;\">표시할 멤버가 없습니다.</div>';
                    }

                    const pagEl = document.getElementById(type === 'all' ? 'attachment-all-pagination' : 'attachment-inactive-pagination');
                    if (pagEl) {
                        pagEl.innerHTML = renderAttachmentPagination(type, state.page, totalPages);
                    }
                }

                renderList('all');
                renderList('inactive');
                window._renderAttachmentList = renderList;
            } catch (e) {
                console.error('첨부 리스트 렌더링 실패:', e);
            }
        }

        // (삭제됨) 첨부 파일 - 사용량 대상 변경 처리: 대상 UI 제거에 따라 비활성화

        // 검색
        function filterAttachmentList(type, query) {
            const state = type === 'all' ? window.attachmentAllState : window.attachmentInactiveState;
            state.search = query || '';
            state.page = 1;
            window._renderAttachmentList && window._renderAttachmentList(type);
        }

        // 정렬
        function sortAttachmentList(type, sortValue) {
            const state = type === 'all' ? window.attachmentAllState : window.attachmentInactiveState;
            state.sort = sortValue;
            window._renderAttachmentList && window._renderAttachmentList(type);
        }

        // 페이지 사이즈 변경
        function changeAttachmentPageSize(type, pageSize) {
            const state = type === 'all' ? window.attachmentAllState : window.attachmentInactiveState;
            state.pageSize = parseInt(pageSize, 10) || 20;
            state.page = 1;
            window._renderAttachmentList && window._renderAttachmentList(type);
        }

        // 페이지 이동
        function changeAttachmentPage(type, page) {
            const state = type === 'all' ? window.attachmentAllState : window.attachmentInactiveState;
            state.page = Math.max(1, page);
            window._renderAttachmentList && window._renderAttachmentList(type);
        }

        // 비활성 기준 기간 변경
        function setInactiveDaysFilter(days) {
            const state = window.attachmentInactiveState || (window.attachmentInactiveState = { page: 1, pageSize: 20, search: '', sort: 'name_asc', days: 14 });
            state.days = parseInt(days, 10) || 14;
            state.page = 1;
            if (window._renderAttachmentList) {
                window._renderAttachmentList('inactive');
            } else {
                // 초기 렌더러가 아직 준비되지 않은 경우 즉시 초기화 후 렌더링 보장
                try {
                    renderAttachmentMemberLists();
                    // 렌더러 바인딩 후 즉시 갱신
                    setTimeout(() => {
                        window._renderAttachmentList && window._renderAttachmentList('inactive');
                    }, 0);
                } catch (e) {
                    console.error('비활성 기간 변경 즉시 반영 실패:', e);
                }
            }
        }

        // 페이지네이션 HTML 렌더링
        function renderAttachmentPagination(type, current, total) {
            const prev = Math.max(1, current - 1);
            const next = Math.min(total, current + 1);
            return `
                <button class="page-btn" onclick="changeAttachmentPage('${type}', 1)">First</button>
                <button class="page-btn" onclick="changeAttachmentPage('${type}', ${prev})">‹</button>
                <span style="color:#b1b1b1; font-size: 12px;">${current} / ${total}</span>
                <button class="page-btn" onclick="changeAttachmentPage('${type}', ${next})">›</button>
                <button class="page-btn" onclick="changeAttachmentPage('${type}', ${total})">Last</button>
            `;
        }

        // 첨부 파일 - 사용량 기간 선택
        function selectUsageAttachmentPeriod(value) {
            const customInput = document.getElementById('usage-attachment-custom-days-input');
            const customDateBox = document.getElementById('usage-attachment-custom-date');
            const periodButtons = document.getElementById('usage-attachment-period-buttons');
            // 버튼 active 상태 업데이트
            const container = periodButtons || (customInput ? customInput.parentElement : null);
            if (container) {
                container.querySelectorAll('.chart-btn').forEach(btn => btn.classList.remove('active'));
            }
            
            if (value === 'custom') {
                // usage 섹션과 동일하게 기간 필터를 노출
                if (customInput) customInput.style.display = 'none';
                if (customDateBox) customDateBox.style.display = '';
                // 마지막 버튼을 active 처리
                if (container) {
                    const btns = container.querySelectorAll('.chart-btn');
                    if (btns.length) btns[btns.length - 1].classList.add('active');
                }
                // 커스텀은 직접 적용 버튼으로 텍스트가 설정됨
                window.__usageAttachmentSelectedDays = undefined;
            } else {
                if (customInput) { customInput.style.display = 'none'; customInput.value = ''; }
                if (customDateBox) customDateBox.style.display = 'none';
                // 해당 값의 버튼 active 처리
                if (container) {
                    const map = { '1': 0, '7': 1, '30': 2 };
                    const idx = map[value];
                    const btns = container.querySelectorAll('.chart-btn');
                    if (idx !== undefined && btns[idx]) btns[idx].classList.add('active');
                }

                // 선택된 일수 기준으로 오늘 기준 날짜 범위를 텍스트에 즉시 반영
                const days = parseInt(value, 10);
                if (!isNaN(days)) {
                    const toDateStr = (d) => {
                        const yyyy = d.getFullYear();
                        const mm = String(d.getMonth() + 1).padStart(2, '0');
                        const dd = String(d.getDate()).padStart(2, '0');
                        return `${yyyy}-${mm}-${dd}`;
                    };
                    const end = new Date();
                    const start = new Date();
                    start.setDate(start.getDate() - days);
                    const textEl = document.getElementById('usage-attachment-period-text');
                    if (textEl) {
                        textEl.textContent = `${toDateStr(start)} ~ ${toDateStr(end)}`;
                    }
                    window.__usageAttachmentSelectedDays = days;
                }
                // 기간 변경 시 테이블 갱신
                updateAttachmentUsageTable();
            }
        }

        // 첨부 사용량 테이블 (NAME, EMAIL, ROLE, REQUEST, SPEND, LAST ACT)
        async function updateAttachmentUsageTable() {
            try {
                const containerId = 'usage-attachment-table-container';
                let container = document.getElementById(containerId);
                if (!container) {
                    // usage settings 아래에 테이블 컨테이너 생성
                    const usageSettings = document.getElementById('usage-attachment-settings');
                    if (!usageSettings) return;
                    container = document.createElement('div');
                    container.id = containerId;
                    container.style.marginTop = '12px';
                    container.style.background = '#1a1a1a';
                    container.style.border = '1px solid #3a3a3a';
                    container.style.borderRadius = '6px';
                    container.style.padding = '12px';
                    usageSettings.parentNode.insertBefore(container, usageSettings.nextSibling);
                }

                // 캐시 상태 확인 후 로딩 표시 (캐시 없을 때만)
                (function showLoadingIfNoCache(){
                    try {
                        const periodText = (document.getElementById('usage-attachment-period-text')?.textContent || '').trim();
                        const m = periodText.match(/(\d{4}-\d{2}-\d{2})\s*~\s*(\d{4}-\d{2}-\d{2})/);
                        let startDate = null, endDate = null;
                        if (m) { startDate = m[1]; endDate = m[2]; }
                        const membersCached = !!(window.__membersCache && window.__membersCache.data && (Date.now() - (window.__membersCache.fetchedAt || 0) < 10*60*1000));
                        let eventsCached = false;
                        if (startDate && endDate && window.__eventsCache) {
                            const key = `${startDate}_${endDate}`;
                            const cached = window.__eventsCache.get(key);
                            eventsCached = !!(cached && cached.data && (Date.now() - (cached.fetchedAt || 0) < 5*60*1000));
                        }
                        if (!(membersCached && eventsCached)) {
                            container.innerHTML = '<div style="padding: 12px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">데이터를 불러오는 중...</div>';
                        }
                    } catch (_) {}
                })();

                // 현재 선택된 그룹의 이메일 수집
                const allOn = !!document.getElementById('attachment-all-members')?.checked;
                const inactiveOn = !!document.getElementById('attachment-inactive-members')?.checked;
                const customOn = !!document.getElementById('attachment-custom')?.checked;

                if (!allOn && !inactiveOn && !customOn) {
                    container.innerHTML = '<div style="color:#7a7a7a;">선택된 수신자 그룹이 없습니다.</div>';
                    return;
                }

                // 멤버 로드(캐시 사용)
                const membersData = await getTeamMembers();
                const members = membersData?.teamMembers || [];

                let targetEmails = new Set();
                if (allOn) members.forEach(m => m.email && targetEmails.add(m.email));

                if (inactiveOn) {
                    // 첨부 섹션과 동일 기준: 최근 N일 무활동
                    const inactivityDays = (window.attachmentInactiveState && window.attachmentInactiveState.days)
                        || parseInt(document.getElementById('attachment-inactive-days')?.value)
                        || 14;
                    const rawEventsNow = (typeof currentRawEventsData !== 'undefined' && Array.isArray(currentRawEventsData)
                        ? currentRawEventsData
                        : (window.currentRawEventsData || []));
                    const allowed = rawEventsNow.filter(ev => ev && ev.userEmail && typeof ev.requestsCosts === 'number' && ev.requestsCosts > 0 && !isNaN(parseInt(ev.timestamp)));
                    const cutoff = Date.now() - (inactivityDays * 24 * 60 * 60 * 1000);
                    const activeSet = new Set();
                    for (const ev of allowed) { const ts = parseInt(ev.timestamp); if (ts >= cutoff) activeSet.add(ev.userEmail); }
                    members.filter(m => m.email && !activeSet.has(m.email)).forEach(m => targetEmails.add(m.email));
                }

                if (customOn) {
                    const customList = (document.getElementById('attachment-custom-emails')?.value || '')
                        .split(',').map(s => s.trim()).filter(Boolean);
                    customList.forEach(e => targetEmails.add(e));
                }

                // 이메일이 없으면 종료
                const emailList = Array.from(targetEmails);
                if (emailList.length === 0) {
                    container.innerHTML = '<div style="color:#7a7a7a;">표시할 이메일이 없습니다.</div>';
                    return;
                }

                // 기간 텍스트 파싱 (없으면 30d로 기본 설정됨)
                const periodText = (document.getElementById('usage-attachment-period-text')?.textContent || '').trim();
                const m = periodText.match(/(\d{4}-\d{2}-\d{2})\s*~\s*(\d{4}-\d{2}-\d{2})/);
                let startDate = null, endDate = null;
                if (m) { startDate = m[1]; endDate = m[2]; }

                // 이벤트/지출 데이터 로드 (캐시 사용)
                const [eventsData, spendingData] = await Promise.all([
                    (startDate && endDate) ? getFilteredEvents(startDate, endDate) : Promise.resolve({ usageEvents: [] }),
                    getTeamSpendingData()
                ]);

                // 집계: Usage 섹션 로직 재사용
                const memberSpendMap = {};
                if (spendingData && spendingData.teamMemberSpend) {
                    spendingData.teamMemberSpend.forEach(spendInfo => {
                        memberSpendMap[spendInfo.email] = {
                            premiumRequests: spendInfo.fastPremiumRequests || 0,
                            spend: (spendInfo.spendCents || 0) / 100,
                            hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                        };
                    });
                }

                const userPeriodStats = {};
                if (eventsData && eventsData.usageEvents) {
                    eventsData.usageEvents.forEach(event => {
                        const userEmail = event.userEmail;
                        const timestamp = parseInt(event.timestamp);
                        if (!userPeriodStats[userEmail]) userPeriodStats[userEmail] = { lastTimestamp: timestamp, periodRequests: 0 };
                        if (timestamp > userPeriodStats[userEmail].lastTimestamp) userPeriodStats[userEmail].lastTimestamp = timestamp;
                        userPeriodStats[userEmail].periodRequests += (event.requestsCosts || 0);
                    });
                }

                const emailSet = new Set(emailList);
                const rows = members
                    .filter(m => m.email && emailSet.has(m.email))
                    .map(member => {
                        const spendData = memberSpendMap[member.email] || {};
                        const stats = userPeriodStats[member.email] || {};
                        const lastTs = stats.lastTimestamp || 0;
                        let lastAct = 'No Activity';
                        if (lastTs) {
                            const d = new Date(lastTs);
                            const yyyy = d.getFullYear();
                            const mm = String(d.getMonth()+1).padStart(2,'0');
                            const dd = String(d.getDate()).padStart(2,'0');
                            const hh = String(d.getHours()).padStart(2,'0');
                            const mi = String(d.getMinutes()).padStart(2,'0');
                            lastAct = `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
                        }
                        return {
                            name: member.name || 'Unnamed',
                            email: member.email,
                            role: member.role === 'owner' ? 'Admin' : 'Member',
                            request: stats.periodRequests || 0,
                            spend: spendData.spend || 0,
                            lastAct,
                            lastTs
                        };
                    });

                // 정렬 및 페이지 상태 저장
                rows.sort((a, b) => (b.lastTs||0) - (a.lastTs||0) || (b.request||0) - (a.request||0));
                window.__attachmentUsageRows = rows;
                window.__attachmentUsagePage = 1;
                window.__attachmentUsagePageSize = window.__attachmentUsagePageSize || 20;
                renderAttachmentUsageTablePage();
            } catch (e) {
                console.warn('첨부 사용량 테이블 업데이트 실패:', e);
            }
        }

        function renderAttachmentUsageTablePage() {
            const container = document.getElementById('usage-attachment-table-container');
            if (!container) return;
            const rows = window.__attachmentUsageRows || [];
            const pageSize = window.__attachmentUsagePageSize || 20;
            const page = window.__attachmentUsagePage || 1;
            const total = rows.length;
            const totalPages = Math.max(1, Math.ceil(total / pageSize));
            const start = (page - 1) * pageSize;
            const pageRows = rows.slice(start, start + pageSize);

            const header = `
                <div style="display:grid; grid-template-columns: 2fr 3fr 1fr 1fr 1fr 1fr; gap:12px; padding:8px 0; border-bottom:1px solid #3a3a3a; color:#e1e1e1;">
                    <div>NAME</div><div>EMAIL</div><div>ROLE</div><div>REQUEST</div><div>SPEND</div><div>LAST ACT</div>
                </div>`;
            const body = pageRows.length ? pageRows.map(r => `
                <div style="display:grid; grid-template-columns: 2fr 3fr 1fr 1fr 1fr 1fr; gap:12px; padding:6px 0; border-bottom:1px solid #2a2a2a; color:#b1b1b1;">
                    <div>${r.name}</div>
                    <div>${r.email}</div>
                    <div><span class="role-badge ${r.role==='Admin'?'admin':''}">${r.role}</span></div>
                    <div style="font-weight:600; color:#fff;">${r.request}</div>
                    <div>$${(r.spend||0).toFixed(2)}</div>
                    <div>${r.lastAct}</div>
                </div>`).join('') : '<div style="color:#7a7a7a; padding:8px 0;">표시할 데이터가 없습니다.</div>';
            const pagination = renderAttachmentUsagePagination(totalPages);
            container.innerHTML = header + body + pagination;
        }

        function renderAttachmentUsagePagination(totalPages) {
            const page = window.__attachmentUsagePage || 1;
            let html = '<div style="display:flex; justify-content:flex-end; gap:4px; margin-top:8px;">';
            if (page > 1) html += `<button class="page-btn" onclick="changeAttachmentUsagePage(${page-1})">‹</button>`;
            let start = Math.max(1, page - 2);
            let end = Math.min(totalPages, page + 2);
            if (start > 1) {
                html += `<button class="page-btn" onclick="changeAttachmentUsagePage(1)">1</button>`;
                if (start > 2) html += `<span style="color:#7a7a7a; padding:0 4px;">...</span>`;
            }
            for (let i = start; i <= end; i++) {
                const active = i === page;
                html += `<button class="page-btn" onclick="changeAttachmentUsagePage(${i})" style="background:${active?'#4a9eff':'#3a3a3a'}; border:1px solid ${active?'#4a9eff':'#4a4a4a'}; color:${active?'#fff':'#e1e1e1'}">${i}</button>`;
            }
            if (end < totalPages) {
                if (end < totalPages - 1) html += `<span style="color:#7a7a7a; padding:0 4px;">...</span>`;
                html += `<button class="page-btn" onclick="changeAttachmentUsagePage(${totalPages})">${totalPages}</button>`;
            }
            if (page < totalPages) html += `<button class="page-btn" onclick="changeAttachmentUsagePage(${page+1})">›</button>`;
            html += '</div>';
            return html;
        }

        function changeAttachmentUsagePage(page) {
            window.__attachmentUsagePage = page;
            renderAttachmentUsageTablePage();
        }

        // 첨부 파일 - 사용량 기간 직접입력 적용
        function applyUsageAttachmentDateRange() {
            const startInput = document.getElementById('usage-attachment-start-date');
            const endInput = document.getElementById('usage-attachment-end-date');
            const text = document.getElementById('usage-attachment-period-text');
            if (!startInput || !endInput || !text) return;
            if (!startInput.value || !endInput.value) {
                showSimpleAlert('⚠️ 기간 시작일과 종료일을 모두 선택하세요.', 'warning');
                return;
            }
            text.textContent = `${startInput.value} ~ ${endInput.value}`;
            console.log(`📅 사용량 첨부 기간 설정: ${text.textContent}`);
        }

        // Export Documents - 지금 Export 하기
        function handleExportNow() {
            try {
                const selFormatEl = document.getElementById('export-format-select');
                const format = selFormatEl ? selFormatEl.value : 'xlsx';
                const exportMembersChecked = document.getElementById('export-type-members')?.checked || document.getElementById('export-type-all')?.checked;

                if (exportMembersChecked) {
                    if (!currentMembersData || currentMembersData.length === 0) {
                        showSimpleAlert('⚠️ 내보낼 멤버 데이터가 없습니다.', 'warning');
                        return;
                    }
                    const dateStr = new Date().toISOString().split('T')[0];
                    let filename = '';
                    if (format === 'csv') {
                        filename = `members_export_${dateStr}.csv`;
                        exportMembersToCSV(filename);
                    } else if (format === 'json') {
                        filename = `members_export_${dateStr}.json`;
                        exportMembersToJSON(filename);
                    } else if (format === 'pdf') {
                        filename = `members_export_${dateStr}.pdf`;
                        exportMembersToPDF(filename);
                    } else {
                        // 기본: Excel 형식(HTML 테이블 기반 .xls)로 내보내기
                        filename = `members_export_${dateStr}.xls`;
                        exportMembersToExcelHTML(filename);
                    }
                    const hint = getDownloadLocationHint(filename);
                    console.log(`멤버 목록 Export 완료: ${hint}`);
                    return;
                }

                showSimpleAlert('ℹ️ 선택된 Export 종류가 아직 지원되지 않습니다. (멤버 목록만 우선 지원)', 'info');
            } catch (e) {
                console.error('Export 실패:', e);
                showSimpleAlert('❌ Export 처리 중 오류가 발생했습니다.', 'error');
            }
        }

        // Export Documents - 설정 저장
        function saveExportSettings() {
            try {
                showSimpleAlert('✅ Export 설정이 저장되었습니다.', 'success');
            } catch (e) {
                console.error('Export 설정 저장 실패:', e);
                showSimpleAlert('❌ Export 설정 저장 중 오류가 발생했습니다.', 'error');
            }
        }

        // Export 종류 선택에 따라 Export 범위 표시/숨김
        function handleExportTypeChange(value) {
            const rangeItem = document.getElementById('export-range-setting');
            if (!rangeItem) return;
            if (value === 'members') {
                rangeItem.style.display = 'none';
            } else {
                rangeItem.style.display = '';
            }
        }

        // 체크박스형 Export 종류 변경 처리
        function handleExportTypeCheckboxChange() {
            const summary = document.getElementById('export-type-summary').checked;
            const raw = document.getElementById('export-type-raw').checked;
            const members = document.getElementById('export-type-members').checked;
            const all = document.getElementById('export-type-all').checked;

            // 유효성: "전체"가 선택되면 나머지 자동 선택/동기화
            if (all) {
                document.getElementById('export-type-summary').checked = true;
                document.getElementById('export-type-raw').checked = true;
                document.getElementById('export-type-members').checked = true;
            }

            // 범위 표시 규칙: 멤버만 단독 선택 시 범위 숨김, 그 외는 표시
            const rangeItem = document.getElementById('export-range-setting');
            if (rangeItem) {
                const selectedCount = (summary?1:0) + (raw?1:0) + (members?1:0) + (all?1:0);
                const onlyMembers = members && !summary && !raw && !all && selectedCount === 1;
                rangeItem.style.display = onlyMembers ? 'none' : '';
            }
        }

        // Export 형식 선택에 따라 세부 옵션 표시
        function handleExportFormatChange(value) {
            const csv = document.getElementById('csv-options');
            const xlsx = document.getElementById('xlsx-options');
            const pdf = document.getElementById('pdf-options');
            const json = document.getElementById('json-options');
            if (!csv || !xlsx || !pdf || !json) return;
            csv.style.display = 'none';
            xlsx.style.display = 'none';
            pdf.style.display = 'none';
            json.style.display = 'none';
            if (value === 'csv') csv.style.display = '';
            else if (value === 'xlsx') xlsx.style.display = '';
            else if (value === 'pdf') pdf.style.display = '';
            else if (value === 'json') json.style.display = '';
        }

        // 설정 리스트(Email Report)
        function showEmailSettingsList() {
            showSimpleAlert('ℹ️ 설정 리스트 표시 (준비 중)', 'info');
        }

        // 설정 리스트(Export Documents)
        function showExportSettingsList() {
            showSimpleAlert('ℹ️ Export 설정 리스트 표시 (준비 중)', 'info');
        }

        // 예약 메일 발송 스케줄러 시작 (토글용)
        function startEmailScheduler() {
            if (isSchedulerRunning) {
                console.log('📅 이메일 스케줄러가 이미 실행 중입니다.');
                return;
            }

            // 예약된 메일이 있는지 먼저 확인
            if (!window.emailScheduleList || window.emailScheduleList.length === 0) {
                console.log('📭 예약된 메일이 없어 스케줄러를 시작하지 않습니다.');
                return;
            }

            // 활성 상태인 예약이 있는지 확인
            const activeSchedules = window.emailScheduleList.filter(schedule => 
                schedule.status === '활성'
            );

            if (activeSchedules.length === 0) {
                console.log('📭 활성 상태인 예약된 메일이 없어 스케줄러를 시작하지 않습니다.');
                return;
            }

            console.log(`✅ 예약 메일 발송 활성화됨 - 백그라운드 체크 시작 (활성 예약: ${activeSchedules.length}개)`);
            isSchedulerRunning = true;

            // 즉시 한 번 검사
            checkAndSendScheduledEmails();
            
            // 1분마다 검사
            emailSchedulerInterval = setInterval(() => {
                checkAndSendScheduledEmails();
            }, 60000);
        }

        // 예약 메일 발송 스케줄러 중지 (토글용)
        function stopEmailScheduler() {
            if (emailSchedulerInterval) {
                clearInterval(emailSchedulerInterval);
                emailSchedulerInterval = null;
                isSchedulerRunning = false;
                console.log('❌ 예약 메일 발송 비활성화됨 - 백그라운드 체크 중지');
            }
        }



        // Overview 통계 카드 클릭 시 멤버 타입별 필터링
        function filterOverviewMembersByType(type) {
            console.log(`=== Overview 통계 카드 클릭: ${type} ===`);
            
            // 선택 상태 업데이트
            updateOverviewSelection(type);
            currentFilterType = type;
            
            // 멤버 데이터 필터링 및 표시
            filterAndDisplayMembers(type);
            
            console.log(`통계 카드 선택 완료: ${type} - 필터링된 데이터 표시`);
        }

        // 멤버 데이터를 타입별로 필터링하고 표시
        function filterAndDisplayMembers(type) {
            console.log(`=== 멤버 데이터 필터링 시작: ${type} ===`);
            
            if (!originalMembersData || originalMembersData.length === 0) {
                console.log('필터링할 멤버 데이터가 없습니다.');
                return;
            }
            
            let filteredMembers = [];
            
            if (type === 'total') {
                // 전체 멤버 표시
                filteredMembers = [...originalMembersData];
                console.log(`전체 멤버 표시: ${filteredMembers.length}명`);
            } else if (type === 'active') {
                // 활성 멤버만 필터링 (Premium Requests가 있는 멤버)
                filteredMembers = originalMembersData.filter(member => 
                    member.spendData.premiumRequests > 0
                );
                console.log(`활성 멤버 필터링: ${filteredMembers.length}명`);
            } else if (type === 'inactive') {
                // 비활성 멤버만 필터링 (Premium Requests가 없는 멤버)
                filteredMembers = originalMembersData.filter(member => 
                    member.spendData.premiumRequests === 0
                );
                console.log(`비활성 멤버 필터링: ${filteredMembers.length}명`);
            }
            
            // 필터링된 데이터로 테이블 업데이트
            if (filteredMembers.length > 0) {
                currentMembersData = filteredMembers;
                currentMembersPage = 1; // 페이지 리셋
                renderMembersTableWithPagination(filteredMembers);
            } else {
                // 데이터가 없을 경우 빈 테이블 표시
                const container = document.getElementById('members-table-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            ${type === 'active' ? '활성 멤버가 없습니다.' : 
                              type === 'inactive' ? '비활성 멤버가 없습니다.' : 
                              '멤버 데이터가 없습니다.'}
                        </div>
                    `;
                }
            }
            
            // 활동 리스트도 함께 업데이트
            updateActivityListByType(type);
            
            console.log(`=== 멤버 데이터 필터링 완료: ${type} ===`);
        }

        // 활동 리스트를 타입별로 필터링하고 업데이트
        function updateActivityListByType(type) {
            console.log(`=== 활동 리스트 필터링 시작: ${type} ===`);
            
            if (!currentActivities || currentActivities.length === 0) {
                console.log('필터링할 활동 데이터가 없습니다.');
                updateActivityList([]);
                return;
            }
            
            let filteredActivities = [];
            
            if (type === 'total') {
                // 전체 활동 표시
                filteredActivities = [...currentActivities];
                console.log(`전체 활동 표시: ${filteredActivities.length}개`);
            } else if (type === 'active') {
                // 활성 활동만 필터링
                filteredActivities = currentActivities.filter(activity => 
                    activity.type === 'active'
                );
                console.log(`활성 활동 필터링: ${filteredActivities.length}개`);
            } else if (type === 'inactive') {
                // 비활성 활동만 필터링
                filteredActivities = currentActivities.filter(activity => 
                    activity.type === 'inactive'
                );
                console.log(`비활성 활동 필터링: ${filteredActivities.length}개`);
            }
            
            // 필터링된 활동 데이터로 리스트 업데이트
            updateActivityList(filteredActivities);
            
            console.log(`=== 활동 리스트 필터링 완료: ${type} ===`);
        }

        // Overview 통계 카드 선택 상태 업데이트
        function updateOverviewSelection(type) {
            // 모든 통계 카드에서 selected 클래스 제거
            document.querySelectorAll('.overview-stat-box').forEach(box => {
                box.classList.remove('selected');
            });
            
            // 클릭된 카드에 selected 클래스 추가
            const targetBox = document.querySelector(`.overview-stat-box[data-type="${type}"]`);
            if (targetBox) {
                targetBox.classList.add('selected');
            }
            
            console.log(`통계 카드 선택 상태 업데이트: ${type}`);
        }

        // 타입별 멤버 데이터를 실제 API에서 가져와서 표시
        async function updateMembersByTypeWithRealData(type) {
            console.log(`=== ${type} 멤버 실제 API 데이터 로드 시작 ===`);
            console.log(`요청된 타입: ${type}, 현재 필터 타입: ${currentFilterType}`);
           
            // 현재 필터 기간 결정
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
           
            console.log(`필터 기간: ${new Date(dateRange.startDate).toLocaleDateString()} ~ ${new Date(dateRange.endDate).toLocaleDateString()}`);
           
            // 실제 API 데이터 가져오기
            const [membersData, eventsData] = await Promise.all([
                getTeamMembers(),
                getFilteredEvents(dateRange.startDate, dateRange.endDate)
            ]);
           
            if (!membersData || !membersData.teamMembers) {
                throw new Error('멤버 데이터를 가져올 수 없습니다.');
            }
           
            console.log(`API 응답: 멤버 ${membersData.teamMembers.length}명, 이벤트 ${eventsData?.usageEvents?.length || 0}개`);
           
            if (type === 'inactive') {
                // 비활성 멤버 처리
                await showInactiveMembersWithData(membersData, eventsData);
            } else if (type === 'active') {
                // 활성 멤버 처리
                await showActiveMembersWithData(membersData, eventsData, 'active');
            } else if (type === 'total') {
                // 전체 멤버 처리
                await showActiveMembersWithData(membersData, eventsData, 'total');
            } else {
                console.error(`알 수 없는 타입: ${type}`);
                currentActivityPage = 1; // 페이지네이션 초기화
                updateActivityList([]);
                // 제목은 동적으로 생성됨
            }
           
            console.log(`=== ${type} 멤버 실제 API 데이터 로드 완료 ===`);
        }

        // 활성 멤버 또는 전체 멤버 표시
        async function showActiveMembersWithData(membersData, eventsData, type) {
            console.log(`=== ${type} 멤버 데이터 표시 시작 ===`);
           
            if (!eventsData || !eventsData.usageEvents) {
                console.log('활동 이벤트 데이터가 없습니다.');
                currentActivityPage = 1; // 페이지네이션 초기화
                updateActivityList([]);
                // 제목은 동적으로 생성됨
                return;
            }
           
            // 지출 데이터 가져오기
            const spendingData = await getTeamSpendingData();
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
           
            // 실제 활동 리스트 생성
            const activities = createActivityListWithLastActivity(eventsData.usageEvents, membersData.teamMembers, memberSpendMap);
            console.log(`생성된 활동 리스트: ${activities.length}명`);
           
            let filteredActivities;
            if (type === 'active') {
                // 활성 멤버: request > 0인 멤버만
                filteredActivities = activities.filter(activity => activity.request > 0);
            } else if (type === 'total') {
                // 전체 멤버: 실제 활동이 있는 모든 멤버
                filteredActivities = activities;
            } else {
                // 기본값: 전체 멤버
                filteredActivities = activities;
                console.log(`기본 전체 멤버 표시: ${filteredActivities.length}명`);
            }
           
            console.log(`${type} 멤버 최종 데이터: ${filteredActivities.length}명`);
            console.log('표시될 멤버 목록:', filteredActivities.map(a => `${a.email} (${a.request} requests)`));
           
            updateActivityList(filteredActivities);
            // 제목은 동적으로 생성됨
           
            console.log(`=== ${type} 멤버 데이터 표시 완료 ===`);
        }

        // 비활성 멤버 표시 함수 (데이터와 함께)
        async function showInactiveMembersWithData(membersData, eventsData) {
            console.log('=== 비활성 멤버 표시 시작 ===');
           
            // 지출 데이터 가져오기
            const spendingData = await getTeamSpendingData();
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
           
            // 활동이 있는 사용자 목록 생성
            const activeUserEmails = new Set();
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    if (event.userEmail && event.requestsCosts > 0) {
                        activeUserEmails.add(event.userEmail);
                    }
                });
            }
           
            // 비활성 멤버 필터링
            const inactiveMembers = membersData.teamMembers.filter(member =>
                !activeUserEmails.has(member.email)
            );
           
            console.log(`비활성 멤버: ${inactiveMembers.length}명`);
            console.log('비활성 멤버 목록:', inactiveMembers.map(m => m.email));
           
            // 비활성 멤버를 활동 리스트 형태로 변환
            const inactiveActivities = inactiveMembers.map(member => {
                const spendData = memberSpendMap[member.email] || {};
                const actualSpend = spendData.spend || 0; // 실제 지출 데이터 사용
                const premiumRequests = spendData.premiumRequests || 0;
                const hardLimit = spendData.hardLimitOverride || 0;
                const limitDisplay = hardLimit > 0 ? `$${hardLimit}` : '$0';
               
                return {
                    date: 'No Activity',
                    timestamp: 0,
                    email: member.email,
                    name: member.name || 'Unnamed',
                    type: 'inactive',
                    kind: 'No Activity',
                    request: premiumRequests, // Premium Requests 사용
                    spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                    limit: limitDisplay
                };
            });
           
            currentActivityPage = 1; // 페이지네이션 초기화
            updateActivityList(inactiveActivities);
            // 제목은 동적으로 생성됨
        }

        // 비활성 멤버 표시 함수 (기존 호환성 유지)
        async function showInactiveMembers() {
            try {
                console.log('=== 비활성 멤버 표시 시작 (기존 함수) ===');
               
                // 현재 필터 기간의 이벤트 데이터 가져오기
                let dateRange;
                if (currentDateRange) {
                    dateRange = currentDateRange;
                } else {
                    const filterDays = getCurrentFilterDays();
                    dateRange = getDateRange(filterDays);
                }
               
                const [membersData, eventsData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(dateRange.startDate, dateRange.endDate)
                ]);
               
                if (!membersData || !membersData.teamMembers) {
                    console.error('멤버 데이터를 가져올 수 없습니다.');
                    return;
                }
               
                await showInactiveMembersWithData(membersData, eventsData);
               
            } catch (error) {
                console.error('❌ 비활성 멤버 표시 실패:', error);
            }
        }

        // 활동 데이터를 타입별로 필터링 (실제 활동 기준) - 사용 중단됨
        // 이제 각 통계 카드 클릭 시 실제 API 데이터를 새로 가져와서 표시함
        function filterActivitiesByType(activities, type) {
            console.log(`⚠️ filterActivitiesByType 사용 중단됨. 대신 updateMembersByTypeWithRealData 사용`);
            console.log(`필터링 요청: ${type}, 전체 활동 수: ${activities.length}`);
           
            let filteredActivities;
            switch (type) {
                case 'active':
                    filteredActivities = activities.filter(activity => activity.type === 'active' && activity.request > 0);
                    break;
                case 'inactive':
                    // 비활성 멤버도 표시하도록 수정
                    filteredActivities = activities.filter(activity => activity.type === 'inactive');
                    break;
                case 'total':
                default:
                    filteredActivities = activities;
                    break;
            }
           
            console.log(`필터링 결과: ${filteredActivities.length}명`);
            return filteredActivities;
        }

        // Overview 활동리스트 제목 업데이트 (동적으로 헤더에 포함됨)
        function updateOverviewActivityTitle(type, count, totalCount) {
            // 제목은 renderOverviewActivityTableWithPagination에서 동적으로 생성됨
            let title, emoji;
            switch (type) {
                case 'active':
                    title = '활성 멤버 활동 리스트';
                    emoji = '✅';
                    break;
                case 'inactive':
                    title = '비활성 멤버 활동 리스트';
                    emoji = '💤';
                    break;
                case 'total':
                default:
                    title = '전체 활동 리스트';
                    emoji = '📊';
                    break;
            }
           
            // 동적으로 생성되는 제목에 사용될 기본 정보 반환
            return { title, emoji };
        }

        // 현재 Overview 필터 기간을 텍스트로 반환
        function getCurrentOverviewPeriodText() {
            let dateRange;
            if (currentDateRange) {
                dateRange = currentDateRange;
            } else {
                const filterDays = getCurrentFilterDays();
                dateRange = getDateRange(filterDays);
            }
            
            const startDate = new Date(dateRange.startDate).toLocaleDateString('ko-KR');
            const endDate = new Date(dateRange.endDate).toLocaleDateString('ko-KR');
            
            // 날짜 끝의 "." 제거
            const cleanStartDate = startDate.replace(/\.$/, '');
            const cleanEndDate = endDate.replace(/\.$/, '');
            
            return `${cleanStartDate} ~ ${cleanEndDate}`;
        }

        // 차트 버튼 클릭 이벤트 (즉시 반응)
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('chart-btn')) {
                // 즉시 시각적 피드백
                e.target.style.transform = 'scale(0.95)';
                setTimeout(() => {
                    e.target.style.transform = '';
                }, 150);
                
                // 현재 섹션의 차트 버튼들만 처리
                const parentSection = e.target.closest('.content-section');
                if (parentSection) {
                    // 즉시 버튼 상태 변경
                    parentSection.querySelectorAll('.chart-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    e.target.classList.add('active');
                   
                    // Overview 섹션의 필터 버튼인 경우
                    if (parentSection.id === 'overview') {
                        const days = e.target.getAttribute('data-days') || 1;
                        console.log(`Overview 필터 버튼 클릭: ${days}일`);
                        
                        // 차트 캐시 초기화 (필터가 변경되었으므로)
                        clearChartCache();
                        
                        // 즉시 필터 기간 표시 업데이트 (데이터 로딩 전)
                        const dateRange = getDateRange(parseInt(days));
                        updateFilterPeriodDisplay(dateRange.startDate, dateRange.endDate);
                        
                        // 비동기로 데이터 업데이트
                        setTimeout(() => {
                            updateOverviewWithCurrentFilter();
                        }, 10);
                    }
                    // Usage 섹션의 필터 버튼인 경우
                    else if (parentSection.id === 'usage') {
                        const days = e.target.getAttribute('data-days') || 30;
                        console.log(`Usage 필터 버튼 클릭: ${days}일`);
                        
                        // 즉시 필터 기간 표시 업데이트 (데이터 로딩 전)
                        const dateRange = getDateRange(parseInt(days));
                        updateUsageFilterPeriodDisplay(dateRange.startDate, dateRange.endDate);
                        
                        // 비동기로 데이터 업데이트
                        setTimeout(() => {
                            updateUsageWithCurrentFilter(days);
                        }, 10);
                    }
                }
            }
        });

        // 날짜 필터 적용 함수
        async function applyDateFilter() {
            const startDateInput = document.getElementById('start-date');
            const endDateInput = document.getElementById('end-date');
           
            if (!startDateInput.value || !endDateInput.value) {
                alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
                return;
            }
           
            const startDate = new Date(startDateInput.value).getTime();
            const endDate = new Date(endDateInput.value).getTime() + (24 * 60 * 60 * 1000 - 1); // 하루 끝까지
           
            if (startDate > endDate) {
                alert('시작 날짜는 종료 날짜보다 빠를 수 없습니다.');
                return;
            }
           
            console.log(`Overview 사용자 정의 날짜 범위 적용: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()}`);
           
            // 현재 날짜 범위 저장
            currentDateRange = { startDate, endDate };
           
            // 차트 캐시 초기화 (필터가 변경되었으므로)
            clearChartCache();
           
            // 즉시 필터 기간 표시 업데이트
            updateFilterPeriodDisplay(startDate, endDate);
           
            // 버튼 active 상태 제거
            document.querySelectorAll('#overview .chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
           
            // 비동기로 Overview 업데이트
            setTimeout(async () => {
                await updateOverviewWithCurrentFilter();
            }, 10);
        }

        // Usage 날짜 필터 적용 함수
        async function applyUsageDateFilter() {
            const startDateInput = document.getElementById('usage-start-date');
            const endDateInput = document.getElementById('usage-end-date');
           
            if (!startDateInput.value || !endDateInput.value) {
                alert('시작 날짜와 종료 날짜를 모두 선택해주세요.');
                return;
            }
           
            const startDate = new Date(startDateInput.value).getTime();
            const endDate = new Date(endDateInput.value).getTime() + (24 * 60 * 60 * 1000 - 1); // 하루 끝까지
           
            if (startDate > endDate) {
                alert('시작 날짜는 종료 날짜보다 빠를 수 없습니다.');
                return;
            }
           
            console.log(`Usage 사용자 정의 날짜 범위 적용: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()}`);
           
            // 현재 날짜 범위 저장
            currentUsageDateRange = { startDate, endDate };
           
            // 즉시 필터 기간 표시 업데이트
            updateUsageFilterPeriodDisplay(startDate, endDate);
           
            // 버튼 active 상태 제거
            document.querySelectorAll('#usage .chart-btn').forEach(btn => {
                btn.classList.remove('active');
            });
           
            // 비동기로 Usage 업데이트
            setTimeout(async () => {
                await updateUsageWithDateRange(startDate, endDate);
            }, 10);
        }

        // 현재 필터 설정으로 Overview 업데이트
        async function updateOverviewWithCurrentFilter() {
            try {
                console.log('=== 현재 필터로 Overview 업데이트 시작 ===');
               
                // 차트가 초기화되지 않은 경우에만 기본 차트 생성
                if (!window.overviewChartInitialized) {
                    console.log('차트가 초기화되지 않아 기본 차트 생성');
                    createOverviewChart();
                    window.overviewChartInitialized = true;
                }
               
                // 날짜 범위 결정
                let dateRange;
                if (currentDateRange) {
                    dateRange = currentDateRange;
                    console.log('사용자 정의 날짜 범위 사용');
                } else {
                    const filterDays = getCurrentFilterDays();
                    dateRange = getDateRange(filterDays);
                    console.log(`기본 필터 기간 사용: ${filterDays}일`);
                }
                
                // 필터 기간 표시 업데이트
                updateFilterPeriodDisplay(dateRange.startDate, dateRange.endDate);
               
                // 팀원 정보 가져오기
                const membersData = await getTeamMembers();
                if (!membersData || !membersData.teamMembers) {
                    console.error('팀원 데이터를 가져올 수 없습니다.');
                    return;
                }
                currentMembers = membersData.teamMembers;
               
                // 활동 이벤트 가져오기
                const eventsData = await getFilteredEvents(dateRange.startDate, dateRange.endDate);
               
                // 지출 데이터로 통계 계산 (선택된 기간)
                const spendingData = await getTeamSpendingData();
               
                // 지출 데이터 매핑
                const memberSpendMap = {};
                if (spendingData && spendingData.teamMemberSpend) {
                    console.log('🔍 원본 지출 데이터:', spendingData.teamMemberSpend);
                    spendingData.teamMemberSpend.forEach(spendInfo => {
                        memberSpendMap[spendInfo.email] = {
                            premiumRequests: spendInfo.fastPremiumRequests || 0,
                            spend: (spendInfo.spendCents || 0) / 100,
                            hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                        };
                        console.log(`💰 ${spendInfo.email}: requests=${spendInfo.fastPremiumRequests}, spend=$${((spendInfo.spendCents || 0) / 100).toFixed(2)}, limit=$${spendInfo.hardLimitOverrideDollars || 0}`);
                    });
                    console.log('📊 최종 지출 데이터 맵:', memberSpendMap);
                }
               
                if (eventsData && eventsData.usageEvents) {
                    console.log(`✅ ${eventsData.usageEvents.length}건의 활동 이벤트를 가져왔습니다.`);
                    currentActivities = createActivityListWithLastActivity(eventsData.usageEvents, membersData.teamMembers, memberSpendMap);
                    
                    // 현재 Raw Events 데이터 업데이트
                    currentRawEventsData = eventsData.usageEvents;
                    console.log('🔄 currentRawEventsData 업데이트 완료:', currentRawEventsData.length, '개 이벤트');
                    // 첨부파일 비활성 리스트 즉시 갱신 시도
                    try {
                        const inactiveSec = document.getElementById('attachment-inactive-section');
                        const isInactiveVisible = inactiveSec && inactiveSec.style.display !== 'none';
                        console.log('📣 [첨부파일/비활성] 이벤트 업데이트 감지. 섹션 표시 상태:', isInactiveVisible);
                        if (window._renderAttachmentList) {
                            window._renderAttachmentList('inactive');
                        } else if (typeof renderAttachmentMemberLists === 'function') {
                            renderAttachmentMemberLists();
                        }
                    } catch (e) {
                        console.warn('첨부파일 비활성 리스트 자동 갱신 실패:', e);
                    }
                    
                    // 통합 차트 데이터 저장소 업데이트
                    const currentFilter = getCurrentFilterState();
                    chartDataStore.updateData(
                        membersData.teamMembers,
                        eventsData.usageEvents,
                        spendingData,
                        null, // usageData는 별도 호출됨
                        currentFilter
                    );
                   
                    // 선택된 기간 내 실제 활성 멤버 계산
                    const periodActiveMembers = calculatePeriodActiveMembers(eventsData.usageEvents);
                    const totalMembers = membersData.teamMembers.length;
                    const inactiveMembers = totalMembers - periodActiveMembers;
                   
                    console.log(`통계 계산 결과: 전체 ${totalMembers}명, 활성 ${periodActiveMembers}명, 비활성 ${inactiveMembers}명`);
                    console.log(`활동 리스트에 실제 표시될 멤버 수: ${currentActivities.length}명`);
                   
                    // 통계 카드 업데이트
                    updateStatsCards(totalMembers, periodActiveMembers, inactiveMembers);
                   
                    // 현재 선택된 타입에 따라 필터링
                    const filteredActivities = filterActivitiesByType(currentActivities, currentFilterType);
                    currentActivityPage = 1; // 페이지네이션 초기화
                    updateActivityList(filteredActivities);
                    // 제목은 동적으로 생성됨
                    
                    // Overview 섹션의 사용량 카드 업데이트 (현재 필터 기간 사용)
                    console.log('Overview 섹션 사용량 카드 업데이트 중...');
                    const overviewUsageData = await getUsageData(dateRange.startDate, dateRange.endDate);
                    updateUsageCards(overviewUsageData, eventsData);
                    console.log('✅ Overview 섹션 사용량 카드 업데이트 완료');
                    
                    // 차트 업데이트 (선택된 필터 기간 기준)
                    console.log('Overview 차트 업데이트 중...');
                    if (overviewUsageData && overviewUsageData.data) {
                        const chartData = createChartData(overviewUsageData.data);
                        updateChart(chartData);
                        console.log(`✅ ${overviewUsageData.data.length}건의 차트 데이터를 처리했습니다.`);
                    }
                    console.log('✅ Overview 차트 업데이트 완료');
                } else {
                    console.log('활동 이벤트 데이터가 없습니다.');
                    currentActivities = [];
                    const totalMembers = membersData ? membersData.teamMembers.length : 0;
                    updateStatsCards(totalMembers, 0, totalMembers);
                    currentActivityPage = 1; // 페이지네이션 초기화
                    updateActivityList([]);
                    
                    // Overview 섹션의 사용량 카드 업데이트 (현재 필터 기간 사용)
                    console.log('Overview 섹션 사용량 카드 업데이트 중...');
                    const overviewUsageData = await getUsageData(dateRange.startDate, dateRange.endDate);
                    updateUsageCards(overviewUsageData, eventsData);
                    console.log('✅ Overview 섹션 사용량 카드 업데이트 완료');
                    
                    // 현재 활성화된 차트 업데이트
                    console.log('현재 활성화된 차트 업데이트 중...');
                    const activeChart = document.querySelector('.chart-content.active');
                    if (activeChart) {
                        const chartSelect = document.getElementById('chartSelect');
                        const currentChartType = chartSelect ? chartSelect.value : 'activity-trend';
                        
                        console.log(`현재 활성화된 차트: ${currentChartType}`);
                        
                        // 캐시를 무시하고 차트를 새로 생성
                        chartCache[currentChartType] = { data: null, filter: null, rendered: false };
                        
                        // 차트 타입에 따라 적절한 차트 렌더링
                        if (currentChartType === 'activity-trend') {
                            createOverviewChart();
                        } else if (currentChartType === 'model-distribution') {
                            createModelDistributionChart();
                        } else if (currentChartType === 'cost-trend') {
                            createCostTrendChart();
                        } else if (currentChartType === 'activity-type') {
                            createActivityTypeChart();
                        } else if (currentChartType === 'user-heatmap') {
                            createUserHeatmapChart();
                        } else if (currentChartType === 'cost-efficiency') {
                            createCostEfficiencyChart();
                        } else if (currentChartType === 'model-preference') {
                            createModelPreferenceChart();
                        } else if (currentChartType === 'user-performance') {
                            createUserPerformanceChart();
                        } else if (currentChartType === 'activity-type-detailed') {
                            createActivityTypeDetailedChart();
                        }
                        
                        // 차트 렌더링 완료 후 캐시에 저장
                        setTimeout(() => {
                            cacheChartData(currentChartType);
                            chartCache[currentChartType].filter = getCurrentFilterState();
                            chartCache[currentChartType].rendered = true;
                        }, 100);
                        
                        console.log(`✅ ${currentChartType} 차트 업데이트 완료`);
                    } else {
                        console.log('활성화된 차트가 없음');
                    }
                }
               
                console.log('=== 현재 필터로 Overview 업데이트 완료 ===');
            } catch (error) {
                console.error('❌ Overview 업데이트 실패:', error);
            }
        }

        // 선택된 기간 내 활성 멤버 수 계산 (실제 활동 기준)
        function calculatePeriodActiveMembers(events) {
            const activeUsers = new Set();
            events.forEach(event => {
                // 실제 활동이 있는 사용자만 카운트 (요청 비용이 0보다 크거나 토큰 기반 호출)
                if (event.userEmail && event.requestsCosts > 0) {
                    activeUsers.add(event.userEmail);
                }
            });
            console.log(`선택된 기간 내 활성 멤버: ${activeUsers.size}명`, Array.from(activeUsers));
            return activeUsers.size;
        }

        // Overview 활동 리스트만 업데이트 (기존 함수 호환성 유지)
        async function updateOverviewActivityList() {
            await updateOverviewWithCurrentFilter();
        }

        // 전체 실제 API 데이터 새로고침
        async function refreshAllRealData() {
            // 로딩 상태 표시
            showLoadingStatus(true);
            
            // 데이터가 새로 로드되므로 차트 캐시 초기화
            clearChartCache();
           
            // Overview와 Members를 동시에 로드하여 시간 단축
            await Promise.all([
                updateOverviewWithRealData(),
                updateMembersWithRealData()
            ]);
           
            // 로딩 상태 해제
            showLoadingStatus(false);
        }

        // 최적화된 로딩 상태 표시/해제
        function showLoadingStatus(isLoading) {
            const pageTitle = document.getElementById('page-title');
           
            if (isLoading) {
                // Overview 섹션에서는 로딩 메시지를 표시하지 않음
                if (pageTitle.textContent === 'Overview' || pageTitle.textContent === 'Dashboard Overview') {
                    return;
                }
                pageTitle.innerHTML = '🔄 Loading Real API Data...';
            } else {
                // 원래 제목으로 복원
                if (pageTitle.textContent === '🔄 Loading Real API Data...') {
                    pageTitle.textContent = 'Dashboard Overview';
                }
            }
        }

        // 전역 변수
        let currentFilterType = 'total'; // 현재 선택된 필터 타입
        let currentActivities = []; // 현재 활동 데이터
        let currentMembers = []; // 현재 멤버 데이터
        let currentDateRange = null; // 현재 선택된 날짜 범위 (Overview용)
        let currentUsageDateRange = null; // 현재 선택된 날짜 범위 (Usage용)
        let currentRawEventsData = []; // 현재 Raw Events 전체 데이터
        let currentRawEventsPage = 1; // 현재 Raw Events 페이지
        let currentRawEventsPageSize = 10; // 현재 Raw Events 페이지 크기
        
        // 통합 차트 데이터 저장소
        let chartDataStore = {
            members: [], // 팀 멤버 데이터
            rawEvents: [], // 원시 이벤트 데이터
            spendingData: null, // 지출 데이터
            usageData: null, // 사용량 데이터
            lastUpdated: null, // 마지막 업데이트 시간
            currentFilter: null, // 현재 적용된 필터 상태
            
            // 데이터 업데이트 함수
            updateData: function(members, rawEvents, spendingData, usageData, filterState) {
                this.members = members || [];
                this.rawEvents = rawEvents || [];
                this.spendingData = spendingData;
                this.usageData = usageData;
                this.currentFilter = filterState;
                this.lastUpdated = new Date();
                console.log(`📊 통합 차트 데이터 저장소 업데이트 완료: ${this.members.length}명, ${this.rawEvents.length}개 이벤트`);
            },
            
            // 데이터 유효성 확인
            isDataValid: function(filterState) {
                if (!this.members.length || !this.rawEvents.length || !this.lastUpdated) {
                    return false;
                }
                
                // 필터 상태가 동일한지 확인
                if (filterState && this.currentFilter) {
                    return isFilterStateEqual(this.currentFilter, filterState);
                }
                
                return true;
            },
            
            // 데이터 초기화
            clearData: function() {
                this.members = [];
                this.rawEvents = [];
                this.spendingData = null;
                this.usageData = null;
                this.lastUpdated = null;
                this.currentFilter = null;
                console.log('📊 통합 차트 데이터 저장소 초기화');
            }
        };
        
        // Usage 데이터 로딩 상태 추적
        let isUsageDataLoaded = false; // Usage 데이터가 한 번이라도 로드되었는지 확인
        let isUsageLoading = false; // Usage 데이터 로딩 중인지 확인
        
        // 활동리스트 페이지네이션 변수
        let currentActivityPage = 1; // 현재 활동리스트 페이지
        let currentActivityPageSize = 20; // 현재 활동리스트 페이지 크기
        
        // 차트 캐싱 시스템
        let chartCache = {
            'activity-trend': { data: null, filter: null, rendered: false },
            'model-distribution': { data: null, filter: null, rendered: false },
            'cost-trend': { data: null, filter: null, rendered: false },
            'activity-type': { data: null, filter: null, rendered: false },
            'user-heatmap': { data: null, filter: null, rendered: false },
            'cost-efficiency': { data: null, filter: null, rendered: false },
            'model-preference': { data: null, filter: null, rendered: false },
            'user-performance': { data: null, filter: null, rendered: false },
            'activity-type-detailed': { data: null, filter: null, rendered: false }
        };
        
        // 차트 캐시 초기화 함수
        function clearChartCache() {
            Object.keys(chartCache).forEach(key => {
                chartCache[key] = { data: null, filter: null, rendered: false };
            });
            console.log('📊 모든 차트 캐시 초기화');
        }
        let currentActivityData = []; // 현재 활동리스트 데이터
        
        // 사용자별 누적 사용량 정보 페이지네이션 변수
        let currentUserCumulativePage = 1; // 현재 사용자별 누적 사용량 정보 페이지
        let currentUserCumulativePageSize = 20; // 현재 사용자별 누적 사용량 정보 페이지 크기
        let currentUserCumulativeData = []; // 현재 사용자별 누적 사용량 정보 데이터
        let currentUserCumulativeStartDate = null; // 현재 사용자별 누적 사용량 정보 시작 날짜
        let currentUserCumulativeEndDate = null; // 현재 사용자별 누적 사용량 정보 종료 날짜
        
        // Members 페이지네이션 변수
        let currentMembersPage = 1; // 현재 Members 페이지
        let currentMembersPageSize = 20; // 현재 Members 페이지 크기
        let currentMembersData = []; // 현재 Members 데이터
        let originalMembersData = []; // 원본 멤버 데이터 (필터링용)

        // ============================================================================
        // 성능 최적화 시스템 (2025.07.29 추가)
        // ============================================================================









        // API 호출을 위한 설정
        const API_CONFIG = {
            baseUrl: '/api', // Vercel Functions 경로
            headers: {
                'Content-Type': 'application/json'
            }
        };

        // API 호출 함수 (실제 API 호출)
        async function callAPI(endpoint, method = 'GET', data = null) {
            try {
                const options = {
                    method: method,
                    headers: {
                        ...API_CONFIG.headers
                    }
                };

                if (data && method === 'POST') {
                    options.body = JSON.stringify(data);
                }

                console.log(`실제 Cursor Admin API 호출: ${method} ${API_CONFIG.baseUrl}${endpoint}`, data);
               
                const response = await fetch(API_CONFIG.baseUrl + endpoint, options);
               
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API 호출 실패: ${response.status} - ${response.statusText}\n${errorText}`);
                }

                const result = await response.json();
                console.log('실제 API 응답 데이터:', result);
               
                // API 응답에 오류가 있는지 확인
                if (result.error) {
                    throw new Error(`API 오류: ${result.error} - ${result.message}`);
                }
               
                return result;
               
            } catch (error) {
                console.error('API 호출 오류:', error);
                throw error; // 오류를 다시 던져서 호출자가 처리하도록 함
            }
        }



        // API 연결 상태 확인
        async function checkAPIConnection() {
            try {
                const response = await fetch(API_CONFIG.baseUrl + '/teams/members', {
                    method: 'GET',
                    headers: API_CONFIG.headers
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }

        // Aggressive 캐시: 팀원/이벤트 데이터 캐시
        window.__aggressivePreviewCacheEnabled = window.__aggressivePreviewCacheEnabled ?? true; // 기본 ON
        window.__membersCache = window.__membersCache || null; // { data, fetchedAt }
        window.__eventsCache = window.__eventsCache || new Map(); // key: `${startDate}_${endDate}` → { data, fetchedAt }

        // 팀원 정보 가져오기 (공격적 캐시 적용)
        async function getTeamMembers() {
            try {
                if (window.__aggressivePreviewCacheEnabled && window.__membersCache && window.__membersCache.data) {
                    const ttlMs = 10 * 60 * 1000; // 10분
                    if (Date.now() - (window.__membersCache.fetchedAt || 0) < ttlMs) {
                        return window.__membersCache.data;
                    }
                }
                const data = await callAPI('/teams/members');
                if (window.__aggressivePreviewCacheEnabled && data) {
                    window.__membersCache = { data, fetchedAt: Date.now() };
                }
                return data;
            } catch (e) {
                if (window.__membersCache && window.__membersCache.data) return window.__membersCache.data;
                throw e;
            }
        }

        // 사용량 데이터 가져오기
        async function getUsageData(startDate, endDate) {
            return await callAPI('/teams/daily-usage-data', 'POST', {
                startDate: startDate,
                endDate: endDate
            });
        }

        // 팀 지출 데이터 가져오기 (전체 멤버)
        async function getTeamSpendingData() {
            try {
                console.log('🔍 전체 멤버 지출 데이터 가져오기 시작...');
                
                // 직접 큰 pageSize로 모든 멤버 데이터 요청
                console.log('📡 API 호출: /teams/spend (pageSize: 1000)');
                const spendingData = await callAPI('/teams/spend', 'POST', {
                    page: 1,
                    pageSize: 1000
                });
                
                if (!spendingData || !spendingData.teamMemberSpend) {
                    throw new Error('지출 데이터를 가져올 수 없습니다.');
                }
                
                const retrievedCount = spendingData.teamMemberSpend.length;
                const totalMembers = spendingData.totalMembers || retrievedCount;
                const totalPages = spendingData.totalPages || 1;
                
                console.log(`✅ 지출 데이터 조회 완료:`);
                console.log(`   - 조회된 멤버: ${retrievedCount}명`);
                console.log(`   - 전체 멤버: ${totalMembers}명`);
                console.log(`   - 전체 페이지: ${totalPages}페이지`);
                
                // 모든 데이터를 가져왔는지 확인
                if (retrievedCount < totalMembers && totalPages > 1) {
                    console.log('⚠️ 추가 데이터가 있습니다. 더 큰 pageSize로 재요청...');
                    
                    const largerData = await callAPI('/teams/spend', 'POST', {
                        page: 1,
                        pageSize: Math.max(totalMembers + 100, 2000) // 여유있게 설정
                    });
                    
                    if (largerData && largerData.teamMemberSpend && largerData.teamMemberSpend.length > retrievedCount) {
                        console.log(`✅ 재요청 성공: ${largerData.teamMemberSpend.length}명의 데이터 확보`);
                        return largerData;
                    }
                }
                
                console.log(`🎯 최종 결과: ${retrievedCount}명의 멤버 데이터 반환`);
                return spendingData;
                
            } catch (error) {
                console.error('❌ 지출 데이터 가져오기 실패:', error);
                throw error;
            }
        }

        // 필터링된 이벤트 가져오기 (모든 페이지 데이터 수집) + 캐시
        async function getFilteredEvents(startDate, endDate) {
            try {
                console.log('=== 필터링된 이벤트 데이터 가져오기 시작 ===');
                const cacheKey = `${startDate}_${endDate}`;
                if (window.__aggressivePreviewCacheEnabled && window.__eventsCache && window.__eventsCache.has(cacheKey)) {
                    const cached = window.__eventsCache.get(cacheKey);
                    const ttlMs = 5 * 60 * 1000; // 5분
                    if (cached && cached.data && Date.now() - (cached.fetchedAt || 0) < ttlMs) {
                        console.log('🗄️ 캐시된 이벤트 데이터 사용');
                        return cached.data;
                    }
                }
                
                // 첫 번째 페이지 요청
                let allEvents = [];
                let currentPage = 1;
                let hasMorePages = true;
                
                while (hasMorePages) {
                    console.log(`📄 페이지 ${currentPage} 요청 중...`);
                    
                    const pageData = await callAPI('/teams/filtered-usage-events', 'POST', {
                        startDate: startDate,
                        endDate: endDate,
                        page: currentPage,
                        pageSize: 1000
                    });
                    
                    if (pageData && pageData.usageEvents) {
                        allEvents = allEvents.concat(pageData.usageEvents);
                        console.log(`✅ 페이지 ${currentPage}: ${pageData.usageEvents.length}개 이벤트 수집 (누적: ${allEvents.length}개)`);
                        
                        // 더 많은 페이지가 있는지 확인
                        hasMorePages = pageData.pagination && pageData.pagination.hasNextPage;
                        currentPage++;
                        
                        // 무한 루프 방지 (최대 10페이지)
                        if (currentPage > 10) {
                            console.log('⚠️ 최대 페이지 수 도달 - 무한 루프 방지');
                            break;
                        }
                    } else {
                        console.log(`❌ 페이지 ${currentPage} 데이터 없음`);
                        hasMorePages = false;
                    }
                }
                
                console.log(`=== 필터링된 이벤트 데이터 수집 완료: 총 ${allEvents.length}개 이벤트 ===`);
                
                // 기존 형식으로 반환 + 캐시 저장
                const result = {
                    totalUsageEventsCount: allEvents.length,
                    usageEvents: allEvents,
                    period: { startDate, endDate }
                };
                if (window.__aggressivePreviewCacheEnabled) {
                    window.__eventsCache.set(cacheKey, { data: result, fetchedAt: Date.now() });
                }
                return result;
                
            } catch (error) {
                console.error('❌ 필터링된 이벤트 가져오기 실패:', error);
                // 캐시 폴백
                try {
                    const cacheKey = `${startDate}_${endDate}`;
                    const cached = window.__eventsCache && window.__eventsCache.get(cacheKey);
                    if (cached && cached.data) {
                        console.warn('⚠️ 캐시된 이벤트 데이터로 폴백');
                        return cached.data;
                    }
                } catch (_) {}
                throw error;
            }
        }

        // 현재 선택된 필터 기간 가져오기
        function getCurrentFilterDays() {
            const activeBtn = document.querySelector('#overview .chart-btn.active');
            if (!activeBtn) return 30; // 기본값 30일
           
            const days = activeBtn.getAttribute('data-days');
            return days ? parseInt(days) : 30;
        }

        // 날짜를 epoch milliseconds로 변환 (한국 시간 기준)
        function getDateRange(days = 7) {
            // 한국 시간대 기준으로 현재 날짜 계산
            const now = new Date();
            const koreaTime = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9
            
            const endDate = new Date(koreaTime);
            const startDate = new Date(koreaTime);
            startDate.setDate(startDate.getDate() - days);
           
            return {
                startDate: startDate.getTime(),
                endDate: endDate.getTime()
            };
        }

        // 필터 기간 표시 업데이트 (한국 시간 기준)
        function updateFilterPeriodDisplay(startDate, endDate) {
            const filterPeriodText = document.getElementById('filter-period-text');
            if (!filterPeriodText) return;

            // 한국 시간대 기준으로 날짜 변환
            const startDateKorea = new Date(startDate + (9 * 60 * 60 * 1000));
            const endDateKorea = new Date(endDate + (9 * 60 * 60 * 1000));
            
            const startDateStr = startDateKorea.toISOString().split('T')[0];
            const endDateStr = endDateKorea.toISOString().split('T')[0];
            
            filterPeriodText.textContent = `${startDateStr} ~ ${endDateStr}`;
            console.log(`✅ 필터 기간 표시 업데이트: ${startDateStr} ~ ${endDateStr}`);
        }

        // Usage 섹션 필터 기간 표시 업데이트 (한국 시간 기준)
        function updateUsageFilterPeriodDisplay(startDate, endDate) {
            const filterPeriodText = document.getElementById('usage-filter-period-text');
            if (!filterPeriodText) return;

            // 한국 시간대 기준으로 날짜 변환
            const startDateKorea = new Date(startDate + (9 * 60 * 60 * 1000));
            const endDateKorea = new Date(endDate + (9 * 60 * 60 * 1000));
            
            const startDateStr = startDateKorea.toISOString().split('T')[0];
            const endDateStr = endDateKorea.toISOString().split('T')[0];
            
            filterPeriodText.textContent = `${startDateStr} ~ ${endDateStr}`;
            console.log(`✅ Usage 필터 기간 표시 업데이트: ${startDateStr} ~ ${endDateStr}`);
        }

        // Overview 데이터 업데이트 (초기 로드용)
        async function updateOverviewWithRealData() {
            try {
                console.log('=== 실제 Cursor Admin API 데이터로 Overview 초기 로드 시작 ===');
               
                // 초기화
                currentFilterType = 'total';
                currentDateRange = null;
               
                // 현재 필터로 업데이트
                await updateOverviewWithCurrentFilter();

                // 차트는 updateOverviewWithCurrentFilter에서 처리됨 (기본 30일 필터)
                console.log('차트는 기본 필터 업데이트에서 처리됩니다.');

                // 초기 로드 후 기본 선택된 'total' 카드에 맞는 실제 데이터 표시
                console.log('초기 로드 후 전체 멤버 데이터 표시');
                await updateMembersByTypeWithRealData('total');
               
                // 선택 상태와 데이터 일치 확인
                console.log(`현재 선택된 타입: ${currentFilterType}`);
                console.log('전체 멤버 카드 선택 상태 확인 완료');

                console.log('=== 실제 API 데이터로 Overview 초기 로드 완료! ===');
            } catch (error) {
                console.error('❌ Overview 초기 로드 실패:', error);
                alert('Overview 데이터를 불러오는데 실패했습니다. 네트워크 연결과 API 서버 상태를 확인해주세요.');
            }
        }

        // 통계 카드 업데이트 (실제 API 데이터 사용)
        function updateStatsCards(total, active, inactive) {
            const totalBox = document.querySelector('.overview-stat-box[data-type="total"] .stat-number');
            const activeBox = document.querySelector('.overview-stat-box[data-type="active"] .stat-number');
            const inactiveBox = document.querySelector('.overview-stat-box[data-type="inactive"] .stat-number');

            if (totalBox) {
                totalBox.textContent = total;
                console.log(`✅ 총 멤버 수 업데이트: ${total}명`);
            }
            if (activeBox) {
                activeBox.textContent = active;
                console.log(`✅ 활성 멤버 수 업데이트: ${active}명`);
            }
            if (inactiveBox) {
                inactiveBox.textContent = inactive;
                console.log(`✅ 비활성 멤버 수 업데이트: ${inactive}명`);
            }

            // 멤버 수 카운터 업데이트
            const memberCount = document.getElementById('member-count');
            if (memberCount) {
                memberCount.textContent = `(${total}명)`;
            }
        }

        // 차트 데이터 생성 (일별 집계)
        function createChartData(usageData) {
            const dailyTotals = {};
           
            // 일별로 모든 사용자의 활동 집계
            usageData.forEach(dayData => {
                const dateKey = new Date(dayData.date).toDateString();
               
                if (!dailyTotals[dateKey]) {
                    dailyTotals[dateKey] = {
                        date: dayData.date,
                        totalApplies: 0,
                        totalAccepts: 0,
                        chatRequests: 0,
                        agentRequests: 0
                    };
                }
               
                dailyTotals[dateKey].totalApplies += (dayData.totalApplies || 0);
                dailyTotals[dateKey].totalAccepts += (dayData.totalAccepts || 0);
                dailyTotals[dateKey].chatRequests += (dayData.chatRequests || 0);
                dailyTotals[dateKey].agentRequests += (dayData.agentRequests || 0);
            });
           
            // 차트 데이터 생성
            const chartData = Object.values(dailyTotals)
                .sort((a, b) => a.date - b.date)
                .map(dayTotal => {
                    const date = new Date(dayTotal.date);
                    const activityScore = dayTotal.totalApplies + dayTotal.totalAccepts +
                                        dayTotal.chatRequests + dayTotal.agentRequests;
                   
                    // 한국 시간 기준으로 날짜 표시
                    const koreaDate = new Date(date.getTime() + (9 * 60 * 60 * 1000));
                    const formatDate = koreaDate.toLocaleDateString('ko-KR', { 
                        month: 'numeric', 
                        day: 'numeric' 
                    }).replace(/\.$/, ''); // 끝의 점 제거
                    
                    return {
                        date: formatDate,
                        activity: activityScore,
                        applies: dayTotal.totalApplies,
                        accepts: dayTotal.totalAccepts,
                        chats: dayTotal.chatRequests,
                        agents: dayTotal.agentRequests
                    };
                });

            console.log('차트 데이터 생성:', chartData);
            return chartData;
        }

        // 차트 업데이트
        function updateChart(chartData) {
            const canvas = document.getElementById('overviewChart');
            if (!canvas || !chartData.length) return;

            // 캔버스 크기가 설정되지 않은 경우 다시 설정
            if (canvas.width === 0 || canvas.height === 0) {
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = 300;
            }

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // 기존 차트 지우기
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);

            // 그리드 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
           
            // 세로 그리드
            for (let i = 0; i <= chartData.length; i++) {
                const x = (width / chartData.length) * i;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }

            // 가로 그리드
            for (let i = 0; i <= 5; i++) {
                const y = (height / 5) * i;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            // 데이터 포인트 계산
            const maxActivity = Math.max(...chartData.map(d => d.activity));
            const dataPoints = chartData.map((data, index) => ({
                x: (width / (chartData.length - 1)) * index,
                y: height - (height * (data.activity / maxActivity))
            }));

            // 선 그래프 그리기
            if (dataPoints.length > 1) {
                ctx.strokeStyle = '#4a9eff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(dataPoints[0].x, dataPoints[0].y);
               
                for (let i = 1; i < dataPoints.length; i++) {
                    ctx.lineTo(dataPoints[i].x, dataPoints[i].y);
                }
                ctx.stroke();
            }

            // 데이터 포인트 원 그리기
            dataPoints.forEach(point => {
                ctx.fillStyle = '#4a9eff';
                ctx.beginPath();
                ctx.arc(point.x, point.y, 4, 0, Math.PI * 2);
                ctx.fill();
            });

            // 날짜 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
           
            chartData.forEach((data, index) => {
                const x = (width / (chartData.length - 1)) * index;
                ctx.fillText(data.date, x, height - 10);
            });
        }

        // 활동 리스트 생성 (실제 활동이 있는 멤버만, 정확한 통계 반영)
        function createActivityListWithLastActivity(events, members, memberSpendMap = {}) {
            console.log('=== 활동 리스트 생성 시작 ===');
            console.log(`전체 이벤트 수: ${events.length}개`);
            console.log(`전체 멤버 수: ${members.length}명`);
            console.log('지출 데이터 맵:', memberSpendMap);
           
            // 사용자별 마지막 활동 날짜 및 통계 계산
            const userActivity = {};
           
            events.forEach(event => {
                const userEmail = event.userEmail;
                const timestamp = parseInt(event.timestamp);
                const requestCost = event.requestsCosts || 0;
               
                if (!userActivity[userEmail]) {
                    userActivity[userEmail] = {
                        lastTimestamp: timestamp,
                        totalRequests: 0,
                        events: []
                    };
                }
               
                // 마지막 활동 시간 업데이트
                if (timestamp > userActivity[userEmail].lastTimestamp) {
                    userActivity[userEmail].lastTimestamp = timestamp;
                }
               
                // 요청 수만 누적 (실제 지출은 /teams/spend API에서 가져옴)
                userActivity[userEmail].totalRequests += requestCost;
                userActivity[userEmail].events.push(event);
            });
           
            console.log('사용자별 활동 통계:', userActivity);
           
            // 모든 멤버를 포함하여 활동 정보 생성 (활성 + 비활성)
            const activities = [];
            let activeCount = 0;
            let inactiveCount = 0;
           
            members.forEach(member => {
                const userStats = userActivity[member.email];
                const spendData = memberSpendMap[member.email] || {};
                
                // 실제 지출 데이터 사용 (/teams/spend API에서)
                const actualSpend = spendData.spend || 0;
                const premiumRequests = spendData.premiumRequests || 0;
                const hardLimit = spendData.hardLimitOverride || 0;
                const limitDisplay = hardLimit > 0 ? `$${hardLimit}` : '$0';
               
                if (userStats && userStats.totalRequests > 0) {
                    // 활동이 있는 멤버
                    const lastActivityDate = new Date(userStats.lastTimestamp);
                   
                    // 오늘 날짜 기준으로 정확한 일수 차이 계산
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                   
                    const activityDate = new Date(userStats.lastTimestamp);
                    activityDate.setHours(0, 0, 0, 0);
                   
                    const daysDiff = Math.floor((today - activityDate) / (1000 * 60 * 60 * 24));
                   
                    activeCount++;
                   
                    activities.push({
                        date: lastActivityDate.toLocaleDateString('ko-KR', {
                            month: '2-digit',
                            day: '2-digit'
                        }) + ` (${daysDiff === 0 ? '오늘' : daysDiff + '일 전'})`,
                        timestamp: userStats.lastTimestamp,
                        email: member.email,
                        name: member.name || 'Unnamed',
                        type: 'active',
                        kind: userStats.events.length > 0 ? userStats.events[0].kindLabel || 'Unknown' : 'Unknown',
                        request: premiumRequests, // Premium Requests 사용
                        spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                        limit: limitDisplay
                    });
                } else {
                    // 활동이 없는 멤버 (비활성)
                    inactiveCount++;
                   
                    activities.push({
                        date: 'No Activity',
                        timestamp: 0,
                        email: member.email,
                        name: member.name || 'Unnamed',
                        type: 'inactive',
                        kind: 'No Activity',
                        request: 0,
                        spend: `$${actualSpend.toFixed(2)}`, // 실제 지출 데이터 사용
                        limit: limitDisplay
                    });
                }
            });
           
            console.log(`활동 리스트 결과: 총 ${activities.length}명 (활성: ${activeCount}명, 비활성: ${inactiveCount}명)`);
           
            // 마지막 활동 날짜 기준으로 정렬 (최신순 - 내림차순)
            return activities.sort((a, b) => {
                return b.timestamp - a.timestamp;
            });
        }

        // 기존 활동 리스트 생성 (호환성 유지)
        function createActivityList(events) {
            return events.slice(0, 20).map(event => {
                const timestamp = new Date(parseInt(event.timestamp));
                return {
                    date: timestamp.toLocaleDateString('ko-KR', {
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    }),
                    email: event.userEmail || 'Unknown',
                    type: event.isTokenBasedCall ? 'active' : 'inactive',
                    kind: event.kindLabel || 'Unknown',
                    request: event.requestsCosts || 0,
                    spend: event.isTokenBasedCall ?
                        `$${(event.tokenUsage?.totalCents || 0) / 100}` :
                        '$0.00'
                };
            });
        }



        // 이메일 클릭 시 Usage 섹션으로 이동 및 검색
        function navigateToUsageWithEmail(email) {
            console.log(`이메일 클릭: ${email} - Usage 섹션으로 이동 시작`);
            
            // 검색 예정 플래그 설정 (자동 새로고침 방지용)
            window.pendingEmailSearch = email;
            
            // 수동으로 섹션 전환 (자동 데이터 로드 방지)
            const usageMenuItem = document.querySelector('.menu-item[data-section="usage"]');
            const allMenuItems = document.querySelectorAll('.menu-item');
            const allSections = document.querySelectorAll('.content-section');
            
            // 메뉴 상태 업데이트
            allMenuItems.forEach(menu => menu.classList.remove('active'));
            if (usageMenuItem) {
                usageMenuItem.classList.add('active');
            }
            
            // 섹션 전환
            allSections.forEach(section => section.classList.remove('active'));
            const usageSection = document.getElementById('usage');
            if (usageSection) {
                usageSection.classList.add('active');
            }
            
            // 페이지 제목 업데이트
            const pageTitle = document.getElementById('page-title');
            if (pageTitle) {
                pageTitle.textContent = 'Usage Analytics';
            }
            
            // Usage 데이터가 이미 로드되어 있는지 확인
            const hasData = currentRawEventsData && currentRawEventsData.length > 0;
            
            if (hasData) {
                // 데이터가 이미 있으면 즉시 검색 실행
                executeEmailSearch(email);
            } else {
                // 데이터가 없으면 먼저 로드한 후 검색
                console.log('Usage 데이터를 먼저 로드합니다...');
                updateUsageWithCurrentFilter(30).then(() => {
                    // 데이터 로드 완료 후 검색 실행
                    setTimeout(() => {
                        executeEmailSearch(email);
                    }, 500);
                }).catch(error => {
                    console.error('Usage 데이터 로드 실패:', error);
                    // 로드 실패해도 검색은 시도
                    executeEmailSearch(email);
                });
            }
            
            console.log(`📧 이메일 클릭 처리 완료: ${email}`);
        }
        
        // 이메일 검색 실행 함수
        function executeEmailSearch(email) {
            const searchBox = document.querySelector('#usage .search-box');
            if (searchBox) {
                searchBox.value = email;
                // X 버튼 표시
                toggleSearchClearBtn('usage-search');
                filterUsageMembers(email);
                console.log(`✅ 이메일 검색 완료: ${email}`);
                
                // 검색 완료 후 플래그 제거
                delete window.pendingEmailSearch;
            } else {
                console.error('❌ Usage 섹션의 검색창을 찾을 수 없습니다.');
            }
        }

        // 활동 리스트 업데이트 (Members 스타일 페이지네이션)
        function updateActivityList(activities) {
            currentActivityData = activities; // 데이터 저장
            renderOverviewActivityTableWithPagination(activities);
        }

        // Overview 활동리스트 테이블 렌더링 (Members 스타일)
        function renderOverviewActivityTableWithPagination(activities) {
            // 헤더 업데이트
            const headerElement = document.querySelector('.overview-activity-header');
            if (headerElement) {
                if (!activities || activities.length === 0) {
                    headerElement.innerHTML = '📋 활동 리스트';
                } else {
                    const totalActivities = activities.length;
                    const totalPages = Math.ceil(totalActivities / currentActivityPageSize);
                    const startIndex = (currentActivityPage - 1) * currentActivityPageSize;
                    const endIndex = Math.min(startIndex + currentActivityPageSize, totalActivities);
                    
                    // 현재 필터 타입에 따른 제목 결정
                    const titleInfo = updateOverviewActivityTitle(currentFilterType, totalActivities, totalActivities);
                    const periodText = getCurrentOverviewPeriodText();
                    
                    headerElement.innerHTML = `
                        <span>${titleInfo.emoji} ${titleInfo.title} (${periodText})(${startIndex + 1}-${endIndex} of ${totalActivities})</span>
                        <select id="overviewActivityPageSize" onchange="changeOverviewActivityPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                            <option value="10" ${currentActivityPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                            <option value="20" ${currentActivityPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                            <option value="30" ${currentActivityPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                            <option value="50" ${currentActivityPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                            <option value="100" ${currentActivityPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                        </select>
                    `;
                }
            }
            
            if (!activities || activities.length === 0) {
                const container = document.getElementById('overview-activity-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            활동 데이터가 없습니다.
                        </div>
                    `;
                }
                // 페이지네이션 숨기기
                const pagination = document.getElementById('overview-activity-pagination');
                if (pagination) pagination.style.display = 'none';
                return;
            }

            // 페이지네이션 계산
            const totalActivities = activities.length;
            const totalPages = Math.ceil(totalActivities / currentActivityPageSize);
            const startIndex = (currentActivityPage - 1) * currentActivityPageSize;
            const endIndex = Math.min(startIndex + currentActivityPageSize, totalActivities);
            const pageActivities = activities.slice(startIndex, endIndex);

            console.log(`📄 Overview 활동리스트 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalActivities} (페이지 ${currentActivityPage}/${totalPages})`);

            // 테이블 내용만 업데이트
            const tableContent = pageActivities.map(activity => `
                <div class="member-item">
                    <div class="member-date">${activity.date}</div>
                    <div class="member-email clickable-email" title="View usage for ${activity.email}" onclick="navigateToUsageWithEmail('${activity.email}')">${activity.email}</div>
                    <div class="member-type ${activity.type}">${activity.type === 'active' ? '활성' : '비활성'}</div>
                    <div class="member-kind">${activity.kind}</div>
                    <div class="member-request">${activity.request}</div>
                    <div class="member-spend">${activity.spend}</div>
                    <div class="member-limit">${activity.limit || '$0'}</div>
                </div>
            `).join('');

            // 컨테이너에 테이블 내용만 삽입
            const container = document.getElementById('overview-activity-container');
            if (container) {
                container.innerHTML = tableContent;
            }

            // 페이지네이션 업데이트
            const paginationContainer = document.getElementById('overview-activity-pagination');
            if (paginationContainer && totalPages > 1) {
                paginationContainer.innerHTML = generateOverviewActivityPagination(totalPages);
                paginationContainer.style.display = 'block';
            } else if (paginationContainer) {
                paginationContainer.style.display = 'none';
            }
           
            // 통계 업데이트
            const activeCount = activities.filter(a => a.type === 'active').length;
            const totalRequests = activities.reduce((sum, a) => sum + (typeof a.request === 'number' ? a.request : 0), 0);
           
            console.log(`📊 Overview 활동 리스트 업데이트: 총 ${activities.length}명, 활성 ${activeCount}명, 총 요청 ${totalRequests}건 (페이지 ${currentActivityPage}/${totalPages})`);
        }



        // 필터 기간 업데이트
        function updateFilterPeriod(startDate, endDate) {
            const start = new Date(startDate).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
            const end = new Date(endDate).toLocaleDateString('en-US', {
                month: 'short',
                day: 'numeric'
            });
           
            const dateFilterBtn = document.querySelector('.date-filter-btn');
            if (dateFilterBtn) {
                dateFilterBtn.textContent = `${start} - ${end}`;
            }
        }



        // 멤버 테이블을 실제 API 데이터로 업데이트
        async function updateMembersWithRealData() {
            try {
                console.log('=== 실제 Cursor Admin API 데이터로 멤버 테이블 업데이트 시작 ===');
               
                // 1. 실제 팀원 정보 가져오기
                console.log('1. 팀원 정보 API 호출 중...');
                const membersData = await getTeamMembers();
                console.log('팀원 데이터 응답:', membersData);
               
                if (!membersData || !membersData.teamMembers) {
                    throw new Error('팀원 데이터를 가져올 수 없습니다.');
                }

                console.log(`✅ 총 ${membersData.teamMembers.length}명의 팀원 정보를 가져왔습니다.`);

                // 2. 실제 지출 데이터 가져오기 (올바른 API 사용)
                console.log('2. 팀 지출 데이터 API 호출 중... (/teams/spend)');
                const spendingData = await getTeamSpendingData();
                console.log('지출 데이터 응답:', spendingData);
               
                if (!spendingData || !spendingData.teamMemberSpend) {
                    throw new Error('지출 데이터를 가져올 수 없습니다.');
                }

                console.log(`✅ ${spendingData.teamMemberSpend.length}명의 지출 데이터를 가져왔습니다.`);
                console.log(`📊 API 응답 정보: 총 멤버 ${spendingData.totalMembers || '정보없음'}명, 총 페이지 ${spendingData.totalPages || '정보없음'}개`);
                
                // 실제로 가져온 멤버 수와 API 멤버 수 비교 로깅
                if (membersData.teamMembers.length !== spendingData.teamMemberSpend.length) {
                    console.log(`⚠️ 멤버 수 불일치: 멤버 API ${membersData.teamMembers.length}명 vs 지출 API ${spendingData.teamMemberSpend.length}명`);
                }

                // 3. 이메일 기준으로 멤버와 지출 데이터 매핑
                console.log('3. 멤버와 지출 데이터 매핑 중...');
                const memberSpendMap = {};
               
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100, // cents를 dollars로 변환
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });

                console.log('지출 데이터 매핑 결과:', memberSpendMap);

                // 4. Fast Requests 리셋 날짜 표시
                console.log('4. Fast Requests 리셋 날짜 표시 중...');
                updateFastRequestsResetDate(spendingData.teamMemberSpend);
                
                // 5. 멤버 테이블 업데이트
                console.log('5. 멤버 테이블 UI 업데이트 중...');
                updateMembersTable(membersData.teamMembers, memberSpendMap);
               
                console.log('=== 실제 API 데이터로 멤버 테이블 업데이트 완료! ===');
               
            } catch (error) {
                console.error('❌ 실제 API 데이터 로드 실패:', error);
                
                // 사용자에게 알림
                alert(`실제 API 데이터 로드에 실패했습니다:\n${error.message}\n\n프록시 서버가 실행 중인지 확인하세요.`);
            }
        }

        // Fast Requests 리셋 날짜 표시
        function updateFastRequestsResetDate(teamMemberSpend) {
            try {
                // Premium Requests가 0인 멤버들을 찾아서 리셋 날짜 계산
                const zeroRequestMembers = teamMemberSpend.filter(member => 
                    member.fastPremiumRequests === 0
                );
                
                // 실제로는 API에서 제공하는 리셋 날짜 정보가 필요하지만,
                // 현재로서는 고정된 날짜를 사용
                const resetDate = '2025년 7월 22일';
                
                const resetDateElement = document.getElementById('fast-requests-reset-date');
                if (resetDateElement) {
                    resetDateElement.textContent = resetDate;
                }
                
                // 한국 시간 기준 오늘 날짜 업데이트
                updateTodayDate();
                
                console.log(`📅 Fast Requests 리셋 날짜: ${resetDate} (Premium Requests 0인 멤버: ${zeroRequestMembers.length}명)`);
            } catch (error) {
                console.error('❌ Fast Requests 리셋 날짜 계산 오류:', error);
                const resetDateElement = document.getElementById('fast-requests-reset-date');
                if (resetDateElement) {
                    resetDateElement.textContent = '2025년 7월 22일';
                }
                // 오류 발생 시에도 오늘 날짜는 업데이트
                updateTodayDate();
            }
        }

        // 한국 시간 기준 오늘 날짜 업데이트
        function updateTodayDate() {
            try {
                // 한국 시간 기준 (UTC+9)
                const now = new Date();
                const koreaTime = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9
                const todayDate = koreaTime.toISOString().split('T')[0]; // YYYY-MM-DD 형식
                
                const todayDateElement = document.getElementById('today-date');
                if (todayDateElement) {
                    todayDateElement.textContent = todayDate;
                    todayDateElement.style.color = '#ff9800'; // 오렌지색
                }
                
                console.log(`📅 오늘 날짜 (한국 시간): ${todayDate}`);
            } catch (error) {
                console.error('❌ 오늘 날짜 계산 오류:', error);
                const todayDateElement = document.getElementById('today-date');
                if (todayDateElement) {
                    todayDateElement.textContent = '2025-08-03';
                    todayDateElement.style.color = '#ff9800'; // 오렌지색
                }
            }
        }

        // Export CSV 기능 (Members 섹션 필드 기준, BOM/구분자/개행 반영)
        function exportMembersToCSV(filenameOverride) {
            try {
                if (!currentMembersData || currentMembersData.length === 0) {
                    alert('내보낼 멤버 데이터가 없습니다.');
                    return;
                }

                // 옵션 반영
                const delimiter = (document.getElementById('csv-delimiter')?.value) || ',';
                const includeHeader = (document.getElementById('csv-include-header')?.value || 'yes') === 'yes';
                const newline = (document.getElementById('csv-newline')?.value || 'CRLF') === 'CRLF' ? '\r\n' : '\n';
                const encoding = (document.getElementById('csv-encoding')?.value || 'utf8-bom');

                // CSV 헤더 (Members 섹션 기준 컬럼)
                const headers = ['Name', 'Email', 'Role', 'Premium Requests', 'Spend ($)'];

                // 필드 안전 인용
                const quote = (val) => {
                    const s = (val ?? '').toString();
                    const needsQuote = s.includes('"') || s.includes(delimiter) || s.includes('\n') || s.includes('\r');
                    const escaped = s.replace(/"/g, '""');
                    return needsQuote ? `"${escaped}"` : escaped;
                };

                // CSV 데이터 생성
                const csvRows = [];
                if (includeHeader) csvRows.push(headers.map(quote).join(delimiter));
                for (const member of currentMembersData) {
                    const row = [
                        member.name || '',
                        member.email || '',
                        member.role || '',
                        member.spendData?.premiumRequests ?? 0,
                        (member.spendData?.spend ?? 0).toFixed(2)
                    ];
                    csvRows.push(row.map(quote).join(delimiter));
                }

                const content = csvRows.join(newline);
                const bom = encoding === 'utf8-bom' ? '\uFEFF' : '';
                const blob = new Blob([bom + content], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                const filename = filenameOverride || `members_export_${new Date().toISOString().split('T')[0]}.csv`;
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(`📊 CSV 내보내기 완료: ${currentMembersData.length}명의 멤버 데이터`);
                return filename;
            } catch (error) {
                console.error('❌ CSV 내보내기 오류:', error);
                alert('CSV 내보내기에 실패했습니다.');
            }
        }

        // Excel(HTML 테이블 기반 .xls) Export (Members 섹션 필드 기준)
        function exportMembersToExcelHTML(filenameOverride) {
            const sanitize = (s) => (s ?? '').toString()
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/\"/g, '&quot;')
                .replace(/'/g, '&#39;');

            const rows = currentMembersData.map(member => `
                <tr>
                    <td>${sanitize(member.name || '')}</td>
                    <td>${sanitize(member.email || '')}</td>
                    <td>${sanitize(member.role || '')}</td>
                    <td>${sanitize(member.spendData?.premiumRequests ?? 0)}</td>
                    <td>${sanitize((member.spendData?.spend ?? 0).toFixed(2))}</td>
                </tr>`).join('');

            const html = `<!DOCTYPE html><html><head><meta charset="UTF-8"></head><body>
                <table border="1">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Email</th>
                            <th>Role</th>
                            <th>Premium Requests</th>
                            <th>Spend ($)</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${rows}
                    </tbody>
                </table>
            </body></html>`;

            const blob = new Blob(['\uFEFF' + html], { type: 'application/vnd.ms-excel;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.href = url;
            const filename = filenameOverride || `members_export_${new Date().toISOString().split('T')[0]}.xls`;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            return filename;
        }

        // JSON Export (Members 섹션 필드 기준)
        function exportMembersToJSON(filename) {
            try {
                const structure = (document.getElementById('json-structure')?.value || 'ndjson');
                const indentVal = document.getElementById('json-indent')?.value || '2';
                const indent = indentVal === 'minify' ? 0 : parseInt(indentVal, 10);

                const rows = currentMembersData.map(m => ({
                    name: m.name || '',
                    email: m.email || '',
                    role: m.role || '',
                    premiumRequests: m.spendData?.premiumRequests ?? 0,
                    spend: Number((m.spendData?.spend ?? 0).toFixed(2))
                }));

                let payload = '';
                if (structure === 'ndjson') {
                    payload = rows.map(r => JSON.stringify(r)).join('\n');
                } else {
                    payload = JSON.stringify(rows, null, indent);
                }

                const blob = new Blob([payload], { type: 'application/json;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = filename || `members_export_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                console.error('JSON Export 실패:', e);
                showSimpleAlert('❌ JSON 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // PDF Export (Members 섹션 필드 기준, 원클릭 저장 - html2pdf.js 사용)
        function exportMembersToPDF(filename) {
            try {
                if (!window.html2pdf) {
                    console.warn('html2pdf 라이브러리가 로드되지 않아 XLS로 대체 저장합니다.');
                    exportMembersToExcelHTML(filename?.replace(/\.pdf$/, '.xls'));
                    return;
                }

                const page = (document.getElementById('pdf-page')?.value || 'A4-portrait');
                const headerFooter = (document.getElementById('pdf-header-footer')?.value || 'yes') === 'yes';
                const [size, orientation] = page.split('-');

                const container = document.createElement('div');
                container.style.background = '#ffffff';
                container.style.color = '#000000';
                container.style.width = '794px';
                container.style.padding = '16px';
                container.style.fontFamily = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif";

                const title = headerFooter ? `<div style="text-align:center; margin-bottom:10px; font-weight:600;">Members Export - ${new Date().toLocaleDateString('ko-KR')}</div>` : '';
                const rows = currentMembersData.map(m => `
                    <tr>
                        <td style="padding:6px 8px; border: 1px solid #999;">${m.name || ''}</td>
                        <td style="padding:6px 8px; border: 1px solid #999;">${m.email || ''}</td>
                        <td style="padding:6px 8px; border: 1px solid #999;">${m.role || ''}</td>
                        <td style="padding:6px 8px; border: 1px solid #999; text-align:right;">${m.spendData?.premiumRequests ?? 0}</td>
                        <td style="padding:6px 8px; border: 1px solid #999; text-align:right;">${(m.spendData?.spend ?? 0).toFixed(2)}</td>
                    </tr>`).join('');

                container.innerHTML = `
                    ${title}
                    <table style="width:100%; border-collapse: collapse;">
                        <thead>
                            <tr>
                                <th style="padding:6px 8px; border: 1px solid #999; background:#eee;">Name</th>
                                <th style="padding:6px 8px; border: 1px solid #999; background:#eee;">Email</th>
                                <th style="padding:6px 8px; border: 1px solid #999; background:#eee;">Role</th>
                                <th style="padding:6px 8px; border: 1px solid #999; background:#eee;">Premium Requests</th>
                                <th style="padding:6px 8px; border: 1px solid #999; background:#eee;">Spend ($)</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${rows}
                        </tbody>
                    </table>`;

                const opt = {
                    margin:       10,
                    filename:     filename || `members_export_${new Date().toISOString().split('T')[0]}.pdf`,
                    image:        { type: 'jpeg', quality: 0.98 },
                    html2canvas:  { scale: 2, useCORS: true },
                    jsPDF:        { unit: 'pt', format: size.toLowerCase(), orientation: (orientation === 'landscape' ? 'landscape' : 'portrait') },
                    pagebreak:    { mode: ['avoid-all','css','legacy'] }
                };

                window.html2pdf().set(opt).from(container).save();
            } catch (e) {
                console.error('PDF Export 실패:', e);
                showSimpleAlert('❌ PDF 내보내기 중 오류가 발생했습니다.', 'error');
            }
        }

        // 다운로드 위치 힌트 생성
        function getDownloadLocationHint(filename) {
            const ua = navigator.userAgent || '';
            if (/Windows/i.test(ua)) {
                return `C:\\Users\\(사용자명)\\Downloads\\${filename}`;
            } else if (/Macintosh|Mac OS X/i.test(ua)) {
                return `~/Downloads/${filename}`;
            } else if (/Linux/i.test(ua)) {
                return `~/Downloads/${filename}`;
            }
            return `브라우저 기본 다운로드 폴더 (${filename})`;
        }

        // 멤버 테이블 업데이트 (실제 지출 데이터 사용)
        function updateMembersTable(members, memberSpendMap) {
            console.log(`🔄 멤버 테이블 업데이트 시작: ${members.length}명의 멤버 데이터`);
            console.log('📊 지출 데이터 매핑 정보:', Object.keys(memberSpendMap));
           
            // 멤버 정보와 실제 지출 데이터 결합
            const membersWithSpending = members.map(member => {
                const spendData = memberSpendMap[member.email] || {
                    premiumRequests: 0,
                    spend: 0,
                    hardLimitOverride: 0
                };
               
                return {
                    ...member,
                    spendData: spendData
                };
            });
           
            console.log(`📋 처리된 멤버 데이터: ${membersWithSpending.length}명`);
           
            // Premium Requests 기준으로 정렬 (높은 순)
            membersWithSpending.sort((a, b) => b.spendData.premiumRequests - a.spendData.premiumRequests);
           
            // 전역 데이터 저장
            currentMembersData = membersWithSpending;
            originalMembersData = [...membersWithSpending]; // 원본 데이터 보존
            currentMembersPage = 1; // 페이지 리셋
            
            // 페이지네이션과 함께 렌더링
            renderMembersTableWithPagination(membersWithSpending);
        }
        
        // Members 테이블 페이지네이션과 함께 렌더링 (All Raw Events 스타일)
        function renderMembersTableWithPagination(membersWithSpending) {
            const tableContainer = document.querySelector('#members-table-container');
            if (!tableContainer) {
                console.error('❌ 멤버 테이블 컨테이너를 찾을 수 없습니다.');
                return;
            }
            
            // 페이지네이션 적용
            const totalMembers = membersWithSpending.length;
            const totalPages = Math.ceil(totalMembers / currentMembersPageSize);
            const startIndex = (currentMembersPage - 1) * currentMembersPageSize;
            const endIndex = Math.min(startIndex + currentMembersPageSize, totalMembers);
            const pageMembers = membersWithSpending.slice(startIndex, endIndex);
            
            console.log(`📄 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalMembers} (페이지 ${currentMembersPage}/${totalPages})`);
           
            // 테이블 제목 동적 생성
            const getTableTitle = () => {
                if (currentFilterType === 'active') {
                    return `👥 활성 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                } else if (currentFilterType === 'inactive') {
                    return `👥 비활성 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                } else {
                    return `👥 전체 멤버 보기 (${startIndex + 1}-${endIndex} of ${totalMembers})`;
                }
            };

            // 테이블 HTML 생성 (All Raw Events 스타일)
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>${getTableTitle()}</span>
                    <select id="membersPageSize" onchange="changeMembersPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${currentMembersPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${currentMembersPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${currentMembersPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${currentMembersPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${currentMembersPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="table-header">
                    <div onclick="sortMembers('name')" style="cursor: pointer;">NAME ↕</div>
                    <div onclick="sortMembers('email')" style="cursor: pointer;">EMAIL ↕</div>
                    <div onclick="sortMembers('requests')" style="cursor: pointer;">PREMIUM REQUESTS ↕</div>
                    <div onclick="sortMembers('spend')" style="cursor: pointer;">SPEND ↕</div>
                    <div onclick="sortMembers('role')" style="cursor: pointer;">ROLE ↕</div>
                    <div></div>
                </div>
                ${pageMembers.length > 0 ? pageMembers.map(member => {
                const roleBadgeClass = member.role === 'owner' ? 'admin' : '';
                const roleText = member.role === 'owner' ? 'Admin' : 'Member';
                const requestColor = member.spendData.premiumRequests > 100 ? '#4caf50' :
                                   member.spendData.premiumRequests > 20 ? '#ff9800' :
                                   member.spendData.premiumRequests > 0 ? '#2196f3' : '#f44336';
               
                    return `
                        <div class="table-row">
                    <div>${member.name || 'Unnamed'}</div>
                    <div class="clickable-email" title="View usage for ${member.email}" onclick="navigateToUsageWithEmail('${member.email}')">${member.email}</div>
                    <div style="color: ${requestColor}; font-weight: 600;">${member.spendData.premiumRequests}</div>
                    <div>$${member.spendData.spend.toFixed(2)}</div>
                    <div><span class="role-badge ${roleBadgeClass}">${roleText}</span></div>
                    <div>⋯</div>
                        </div>
                    `;
                }).join('') : '<div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a; grid-column: 1 / -1;">멤버 데이터가 없습니다.</div>'}
            `;
            
            tableContainer.innerHTML = tableHtml;
            
            // 페이지네이션 표시/숨김
            const paginationContainer = document.getElementById('members-pagination');
            if (paginationContainer) {
                if (totalMembers > currentMembersPageSize) {
                    paginationContainer.style.display = 'block';
                    paginationContainer.innerHTML = generateMembersPagination(totalPages);
                } else {
                    paginationContainer.style.display = 'none';
                }
            }
            
            console.log(`✅ Members 테이블 업데이트 완료: 페이지 ${currentMembersPage}/${totalPages}, ${pageMembers.length}개 멤버 표시`);
           
            // 통계 정보 표시
            const totalRequests = membersWithSpending.reduce((sum, member) => sum + member.spendData.premiumRequests, 0);
            const totalSpend = membersWithSpending.reduce((sum, member) => sum + member.spendData.spend, 0);
            const activeMembers = membersWithSpending.filter(member => member.spendData.premiumRequests > 0).length;
           
            console.log(`📊 멤버 통계 (실제 API 데이터):`);
            console.log(`   - 총 멤버: ${membersWithSpending.length}명`);
            console.log(`   - 활성 멤버: ${activeMembers}명 (Premium Requests > 0)`);
            console.log(`   - 총 Premium Requests: ${totalRequests}건`);
            console.log(`   - 총 지출: $${totalSpend.toFixed(2)}`);
        }
        
        // 사용자별 누적 사용량 정보 페이지네이션 생성 (All Raw Events 스타일)
        function generateUserCumulativePagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentUserCumulativePage > 1) {
                pagination += `<button onclick="changeUserCumulativePage(${currentUserCumulativePage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentUserCumulativePage - 2);
            let endPage = Math.min(totalPages, currentUserCumulativePage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeUserCumulativePage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentUserCumulativePage;
                pagination += `<button onclick="changeUserCumulativePage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeUserCumulativePage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentUserCumulativePage < totalPages) {
                pagination += `<button onclick="changeUserCumulativePage(${currentUserCumulativePage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Overview 활동리스트 페이지네이션 생성 (Members와 동일)
        function generateOverviewActivityPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentActivityPage > 1) {
                pagination += `<button onclick="changeOverviewActivityPage(${currentActivityPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentActivityPage - 2);
            let endPage = Math.min(totalPages, currentActivityPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeOverviewActivityPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentActivityPage;
                pagination += `<button onclick="changeOverviewActivityPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeOverviewActivityPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentActivityPage < totalPages) {
                pagination += `<button onclick="changeOverviewActivityPage(${currentActivityPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Overview 활동리스트 페이지 변경
        function changeOverviewActivityPage(page) {
            currentActivityPage = page;
            renderOverviewActivityTableWithPagination(currentActivityData);
        }

        // Overview 활동리스트 페이지 크기 변경
        function changeOverviewActivityPageSize(pageSize) {
            currentActivityPageSize = parseInt(pageSize);
            currentActivityPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderOverviewActivityTableWithPagination(currentActivityData);
        }

        // Members 페이지네이션 생성 (All Raw Events와 동일)
        function generateMembersPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentMembersPage > 1) {
                pagination += `<button onclick="changeMembersPage(${currentMembersPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentMembersPage - 2);
            let endPage = Math.min(totalPages, currentMembersPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeMembersPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentMembersPage;
                pagination += `<button onclick="changeMembersPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'}; margin: 0 2px;">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeMembersPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentMembersPage < totalPages) {
                pagination += `<button onclick="changeMembersPage(${currentMembersPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; margin: 0 2px;">›</button>`;
            }
            
            return pagination;
        }

        // Members 페이지 변경
        function changeMembersPage(page) {
            currentMembersPage = page;
            renderMembersTableWithPagination(currentMembersData);
        }

        // Members 페이지 크기 변경
        function changeMembersPageSize(pageSize) {
            currentMembersPageSize = parseInt(pageSize);
            currentMembersPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderMembersTableWithPagination(currentMembersData);
        }

        // 검색창 X 버튼 표시/숨김 토글
        function toggleSearchClearBtn(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            
            if (searchInput && clearBtn) {
                if (searchInput.value.length > 0) {
                    clearBtn.style.display = 'flex';
                } else {
                    clearBtn.style.display = 'none';
                }
            }
        }

        // 검색창 비우기
        function clearSearch(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = '';
                clearBtn.style.display = 'none';
                
                // 자동완성 드롭다운 숨기기
                if (autocomplete) {
                    autocomplete.style.display = 'none';
                }
                
                // 검색 필터 초기화
                if (searchId === 'members-search') {
                    filterMembers('');
                } else if (searchId === 'usage-search') {
                    filterUsageMembers('');
                } else if (searchId === 'user-performance-search') {
                    filterUserPerformance('');
                }
            }
        }

        // 사용자별 성과 차트 검색창 비우기
        function clearUserPerformanceSearch(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = '';
                clearBtn.style.display = 'none';
                
                // 자동완성 드롭다운 숨기기
                if (autocomplete) {
                    autocomplete.style.display = 'none';
                }
                
                // 사용자별 성과 차트 재생성 (전체 사용자)
                filterUserPerformance('');
            }
        }

        // 자동완성 드롭다운 표시
        function showAutocomplete(searchId) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (!searchInput || !autocomplete) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            // 사용자 데이터 가져오기
            let users = [];
            if (searchId === 'members-search') {
                users = getMembersUsers();
            } else if (searchId === 'usage-search') {
                users = getUsageUsers();
            }
            
            // 검색어가 없으면 전체 사용자 표시, 있으면 필터링
            let filteredUsers = users;
            if (searchTerm.length > 0) {
                filteredUsers = users.filter(user => 
                    user.name.toLowerCase().includes(searchTerm) || 
                    user.email.toLowerCase().includes(searchTerm)
                );
            }
            
            if (filteredUsers.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            // 드롭다운 HTML 생성
            const dropdownHTML = filteredUsers.map(user => `
                <div class="autocomplete-item" onclick="selectUser('${searchId}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-email">${user.email}</div>
                </div>
            `).join('');
            
            autocomplete.innerHTML = dropdownHTML;
            autocomplete.style.display = 'block';
        }

        // 사용자별 성과 차트 자동완성 드롭다운 표시
        function showUserPerformanceAutocomplete(searchId) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (!searchInput || !autocomplete) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            
            // 사용자별 성과 데이터에서 사용자 정보 가져오기
            const users = getUserPerformanceUsers();
            
            // 검색어가 없으면 전체 사용자 표시, 있으면 필터링
            let filteredUsers = users;
            if (searchTerm.length > 0) {
                filteredUsers = users.filter(user => 
                    user.name.toLowerCase().includes(searchTerm) || 
                    user.email.toLowerCase().includes(searchTerm)
                );
            }
            
            if (filteredUsers.length === 0) {
                autocomplete.style.display = 'none';
                return;
            }
            
            // 드롭다운 HTML 생성
            const dropdownHTML = filteredUsers.map(user => `
                <div class="autocomplete-item" onclick="selectUserPerformanceUser('${searchId}', '${user.email}')">
                    <div class="user-name">${user.name}</div>
                    <div class="user-email">${user.email}</div>
                </div>
            `).join('');
            
            autocomplete.innerHTML = dropdownHTML;
            autocomplete.style.display = 'block';
        }

        // 차트 검색창 자동완성 드롭다운 표시
        function showChartAutocomplete(searchId) {
            const searchInput = document.getElementById(searchId);
            
            if (!searchInput) return;
            
            const searchTerm = searchInput.value.toLowerCase().trim();
            const chartSelect = document.getElementById('chartSelect');
            const currentChartType = chartSelect ? chartSelect.value : 'activity-trend';
            
            // 차트 타입에 따라 적절한 드롭다운 표시
            if (currentChartType === 'user-performance') {
                // 사용자별 성과 차트의 경우 전체 사용자 표시
                const users = getUserPerformanceUsers();
                
                // 검색어가 없으면 전체 사용자 표시, 있으면 필터링
                let filteredUsers = users;
                if (searchTerm.length > 0) {
                    filteredUsers = users.filter(user => 
                        user.name.toLowerCase().includes(searchTerm) || 
                        user.email.toLowerCase().includes(searchTerm)
                    );
                }
                
                if (filteredUsers.length === 0) {
                    return;
                }
                
                // 드롭다운 HTML 생성 (최대 20개)
                const dropdownHTML = filteredUsers.slice(0, 20).map(user => `
                    <div class="autocomplete-item" onclick="selectChartUser('${searchId}', '${user.email}')">
                        <div class="user-name">${user.name}</div>
                        <div class="user-email">${user.email}</div>
                    </div>
                `).join('');
                
                // 기존 드롭다운 제거 후 새로 생성
                const existingDropdown = document.getElementById('chart-autocomplete-dropdown');
                if (existingDropdown) {
                    existingDropdown.remove();
                }
                
                const dropdown = document.createElement('div');
                dropdown.id = 'chart-autocomplete-dropdown';
                dropdown.className = 'autocomplete-dropdown';
                dropdown.style.cssText = `
                    position: absolute;
                    top: 100%;
                    left: 0;
                    right: 0;
                    background-color: #2a2a2a;
                    border: 1px solid #3a3a3a;
                    border-radius: 6px;
                    max-height: 200px;
                    overflow-y: auto;
                    z-index: 1000;
                    margin-top: 2px;
                    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
                `;
                dropdown.innerHTML = dropdownHTML;
                
                // 검색창 컨테이너에 드롭다운 추가
                const inputContainer = searchInput.parentElement;
                inputContainer.style.position = 'relative';
                inputContainer.appendChild(dropdown);
                
                dropdown.style.display = 'block';
            }
        }

        // 차트 검색창 사용자 선택
        function selectChartUser(searchId, userEmail) {
            const searchInput = document.getElementById(searchId);
            const dropdown = document.getElementById('chart-autocomplete-dropdown');
            
            if (searchInput) {
                searchInput.value = userEmail;
                
                // 차트 검색 실행
                handleChartSearch(userEmail);
                
                // X 버튼 표시
                toggleSearchClearBtn(searchId);
            }
            
            // 드롭다운 숨기기
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }

        // 사용자 선택
        function selectUser(searchId, userEmail) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = userEmail;
                
                // 검색 실행
                if (searchId === 'members-search') {
                    filterMembers(userEmail);
                } else if (searchId === 'usage-search') {
                    filterUsageMembers(userEmail);
                }
                
                // X 버튼 표시
                toggleSearchClearBtn(searchId);
            }
            
            // 드롭다운 숨기기
            if (autocomplete) {
                autocomplete.style.display = 'none';
            }
        }

        // 사용자별 성과 차트 사용자 선택
        function selectUserPerformanceUser(searchId, userEmail) {
            const searchInput = document.getElementById(searchId);
            const autocomplete = document.getElementById(searchId.replace('-search', '-autocomplete'));
            
            if (searchInput) {
                searchInput.value = userEmail;
                
                // 사용자별 성과 차트 필터링
                filterUserPerformance(userEmail);
                
                // X 버튼 표시
                toggleSearchClearBtn(searchId);
            }
            
            // 드롭다운 숨기기
            if (autocomplete) {
                autocomplete.style.display = 'none';
            }
        }

        // Members 섹션 사용자 데이터 가져오기
        function getMembersUsers() {
            if (!currentMembersData || currentMembersData.length === 0) {
                return [];
            }
            
            return currentMembersData.map(member => ({
                name: member.name || 'Unnamed',
                email: member.email
            }));
        }

        // Usage 섹션 사용자 데이터 가져오기
        function getUsageUsers() {
            if (!currentUserCumulativeData || currentUserCumulativeData.length === 0) {
                return [];
            }
            
            return currentUserCumulativeData.map(user => ({
                name: user.name || 'Unnamed',
                email: user.email
            }));
        }

        // 사용자별 성과 차트 사용자 데이터 가져오기
        function getUserPerformanceUsers() {
            const members = currentMembersData || [];
            const rawEvents = currentRawEventsData || [];
            
            if (members.length === 0 || rawEvents.length === 0) {
                return [];
            }
            
            // 사용자별 성과 데이터 생성
            const userPerformance = [];
            const userMap = new Map();
            
            // 멤버 정보로 초기화
            members.forEach(member => {
                userMap.set(member.email, {
                    name: member.name || 'Unnamed',
                    email: member.email,
                    requests: 0,
                    costs: 0,
                    activeDays: 0
                });
            });
            
            // 이벤트 데이터로 성과 계산
            rawEvents.forEach(event => {
                const userEmail = event.email;
                const user = userMap.get(userEmail);
                
                if (user) {
                    user.requests += event.requests || 0;
                    user.costs += event.requestsCosts || 0;
                    
                    // 활동 일수 계산 (날짜별로 한 번만 카운트)
                    const eventDate = new Date(parseInt(event.timestamp)).toDateString();
                    if (!user.activeDaysSet) {
                        user.activeDaysSet = new Set();
                    }
                    user.activeDaysSet.add(eventDate);
                }
            });
            
            // Set을 개수로 변환
            userMap.forEach(user => {
                user.activeDays = user.activeDaysSet ? user.activeDaysSet.size : 0;
                delete user.activeDaysSet;
                userPerformance.push(user);
            });
            
            return userPerformance;
        }

        // 멤버 검색 기능
        function filterMembers(searchTerm) {
            const rows = document.querySelectorAll('#members .table-row');
            const searchLower = searchTerm.toLowerCase();
           
            rows.forEach(row => {
                const name = row.children[0].textContent.toLowerCase();
                const email = row.children[1].textContent.toLowerCase();
               
                if (name.includes(searchLower) || email.includes(searchLower)) {
                    row.style.display = 'grid';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        // 사용자별 성과 차트 필터링
        function filterUserPerformance(searchTerm) {
            console.log(`🔍 사용자별 성과 차트 필터링: "${searchTerm}"`);
            
            const searchLower = searchTerm.toLowerCase().trim();
            
            // 검색어가 비어있으면 전체 사용자 성과 차트 표시
            if (searchLower === '') {
                createUserPerformanceChart();
                return;
            }
            
            // 특정 사용자에 대한 성과 차트 생성
            createFilteredUserPerformanceChart(searchLower);
        }

        // 차트 데이터 필터링 (일반적인 차트 검색)
        function filterChartData(searchTerm) {
            console.log(`🔍 차트 데이터 필터링: "${searchTerm}"`);
            
            const searchLower = searchTerm.toLowerCase().trim();
            const chartSelect = document.getElementById('chartSelect');
            const currentChartType = chartSelect ? chartSelect.value : 'activity-trend';
            
            // 검색어가 비어있으면 현재 차트 재생성
            if (searchLower === '') {
                switchChart(currentChartType).catch(error => {
                    console.error('차트 재생성 중 오류가 발생했습니다:', error);
                });
                return;
            }
            
            // 차트 타입에 따라 적절한 필터링 적용
            switch (currentChartType) {
                case 'user-performance':
                    filterUserPerformance(searchTerm);
                    break;
                case 'user-heatmap':
                    // 사용자 활동 히트맵 필터링
                    createFilteredUserHeatmapChart(searchTerm);
                    break;
                case 'model-preference':
                    // 모델 선호도 필터링
                    createFilteredModelPreferenceChart(searchTerm);
                    break;
                default:
                    // 기본적으로는 차트 재생성
                    switchChart(currentChartType).catch(error => {
                        console.error('차트 재생성 중 오류가 발생했습니다:', error);
                    });
                    break;
            }
        }

        // 차트 검색창 비우기
        function clearChartSearch(searchId) {
            const searchInput = document.getElementById(searchId);
            const clearBtn = document.getElementById(searchId + '-clear');
            
            if (searchInput) {
                searchInput.value = '';
                clearBtn.style.display = 'none';
                
                // 현재 차트 타입 확인
                const chartSelect = document.getElementById('chartSelect');
                const currentChartType = chartSelect ? chartSelect.value : 'activity-trend';
                
                // 검색창이 있는 차트들의 경우 즉시 기본 차트로 전환
                if (currentChartType === 'user-heatmap') {
                    console.log('🔥 검색창 클리어 - 상위 20명 히트맵으로 전환');
                    createUserHeatmapChart();
                } else if (currentChartType === 'model-preference') {
                    console.log('🔥 검색창 클리어 - 상위 20명 모델 선호도로 전환');
                    createModelPreferenceChart();
                } else {
                    // 다른 차트는 기존 방식으로 재생성
                    switchChart(currentChartType).catch(error => {
                        console.error('차트 재생성 중 오류가 발생했습니다:', error);
                    });
                }
            }
        }

        // 차트 검색 처리 (히트맵 및 모델 선호도)
        function handleChartSearch(searchTerm) {
            console.log('🔍 차트 검색 처리:', searchTerm);
            
            const chartSelect = document.getElementById('chartSelect');
            if (!chartSelect) return;
            
            const selectedChart = chartSelect.value;
            
            // 히트맵 차트 검색 처리
            if (selectedChart === 'user-heatmap') {
                if (searchTerm.trim() === '') {
                    // 검색어가 없으면 즉시 기본 히트맵 표시 (상위 20명)
                    createUserHeatmapChart();
                } else {
                    // 검색어로 사용자 필터링
                    const filteredUsers = getFilteredUsers(searchTerm);
                    
                    if (filteredUsers.length === 1) {
                        // 정확히 1명이면 요일별 차트 표시
                        createFilteredUserHeatmapChart(filteredUsers[0].email.split('@')[0]);
                    } else if (filteredUsers.length > 1) {
                        // 여러 명이면 상위 20명까지 막대 차트 표시
                        createMultiUserHeatmapChart(filteredUsers.slice(0, 20));
                    } else {
                        // 검색 결과 없음
                        showNoSearchResults(searchTerm);
                    }
                }
            }
            // 모델 선호도 차트 검색 처리
            else if (selectedChart === 'model-preference') {
                if (searchTerm.trim() === '') {
                    // 검색어가 없으면 기본 모델 선호도 표시 (상위 20명)
                    createModelPreferenceChart();
                } else {
                    // 검색어로 사용자 필터링
                    const filteredUsers = getFilteredUsers(searchTerm);
                    
                    if (filteredUsers.length === 1) {
                        // 정확히 1명이면 해당 사용자의 모델 사용량 차트 표시
                        createFilteredModelPreferenceChart(filteredUsers[0].email.split('@')[0]);
                    } else if (filteredUsers.length > 1) {
                        // 여러 명이면 상위 20명까지 모델 선호도 차트 표시
                        createMultiUserModelPreferenceChart(filteredUsers.slice(0, 20));
                    } else {
                        // 검색 결과 없음
                        showNoSearchResults(searchTerm);
                    }
                }
            }
        }

        // 검색어로 사용자 필터링 (ID 기반)
        function getFilteredUsers(searchTerm) {
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            
            if (!members || members.length === 0) return [];
            
            // ID로만 검색 (정확히 일치하는 경우)
            const exactMatch = members.find(member => {
                const emailId = member.email.split('@')[0];
                return emailId.toLowerCase() === searchTerm.toLowerCase();
            });
            
            if (exactMatch) {
                return [exactMatch]; // 정확히 1명만 반환
            }
            
            // 부분 검색 (ID에 포함되는 경우)
            return members.filter(member => {
                const emailId = member.email.split('@')[0];
                return emailId.toLowerCase().includes(searchTerm.toLowerCase());
            });
        }

        // 여러 사용자 히트맵 차트 생성 (부분 검색 결과)
        function createMultiUserHeatmapChart(filteredUsers) {
            console.log('🔥 createMultiUserHeatmapChart 시작:', filteredUsers.length, '명');
            const canvas = document.getElementById('userHeatmapChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 필터된 사용자들의 활동 데이터 생성
            const heatmapData = generateFilteredHeatmapBarData(filteredUsers);
            
            if (heatmapData.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('활동 데이터가 없습니다.', width / 2, height / 2);
                return;
            }
            
            // 막대 그래프 그리기
            drawHeatmapBarChart(ctx, width, height, heatmapData);
        }

        // 필터된 사용자들의 히트맵 데이터 생성
        function generateFilteredHeatmapBarData(filteredUsers) {
            console.log('🔥 generateFilteredHeatmapBarData 시작:', filteredUsers.length, '명');
            
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ 이벤트 데이터가 없습니다.');
                return [];
            }
            
            // 사용자별 활동 수 계산
            const userActivityMap = new Map();
            filteredUsers.forEach((member, userIndex) => {
                const userEmail = member.email;
                const userName = member.name;
                const userId = userEmail.split('@')[0];
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail || event.email === userEmail
                );
                
                const totalActivity = userEvents.length;
                
                userActivityMap.set(userIndex, {
                    name: userName,
                    email: userEmail,
                    id: userId,
                    totalActivity: totalActivity
                });
            });
            
            // 활동 수로 정렬
            const sortedUsers = Array.from(userActivityMap.entries())
                .sort((a, b) => b[1].totalActivity - a[1].totalActivity);
            
            const data = sortedUsers.map(([userIndex, userData]) => ({
                userId: userData.id,
                userName: userData.name,
                email: userData.email,
                activity: userData.totalActivity
            }));
            
            console.log(`🔥 필터된 히트맵 데이터 생성 완료: ${data.length}명`);
            return data;
        }

        // 검색 결과 없음 표시
        function showNoSearchResults(searchTerm) {
            const canvas = document.getElementById('userHeatmapChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`검색 결과가 없습니다: "${searchTerm}"`, width / 2, height / 2);
        }

        // 히트맵용 커스텀 드롭다운 생성
        function populateHeatmapEmailDropdown() {
            console.log('📧 히트맵용 커스텀 드롭다운 생성 중...');
            
            const searchInput = document.getElementById('chart-search-input');
            if (!searchInput) {
                console.error('❌ chart-search-input 요소를 찾을 수 없습니다.');
                return;
            }
            
            // 기존 커스텀 드롭다운 제거
            const existingDropdown = document.getElementById('custom-heatmap-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            // 새 커스텀 드롭다운 생성
            const dropdown = document.createElement('div');
            dropdown.id = 'custom-heatmap-dropdown';
            dropdown.style.cssText = `
                position: absolute;
                top: calc(100% + 4px);
                left: 0;
                right: 0;
                background-color: #2a2a2a;
                border: 1px solid #3a3a3a;
                border-radius: 8px;
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                display: none;
            `;
            
            // 멤버 데이터 가져오기
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            
            if (!members || members.length === 0) {
                console.log('⚠️ 사용 가능한 멤버 데이터가 없습니다.');
                return;
            }
            
            // 전체 멤버를 대상으로 하는 드롭다운 목록 생성
            const allMembers = [];
            members.forEach(member => {
                const emailId = member.email.split('@')[0];
                allMembers.push({
                    id: emailId,
                    name: member.name,
                    email: member.email
                });
            });
            
            console.log(`📋 전체 멤버 목록 생성: ${allMembers.length}명`);
            
            // 드롭다운 업데이트 함수 (실시간 필터링)
            function updateDropdownOptions(searchTerm = '') {
                dropdown.innerHTML = '';
                
                // 검색어가 없으면 전체 멤버 표시 (최대 50개)
                if (searchTerm.trim() === '') {
                    const displayMembers = allMembers.slice(0, 50);
                    displayMembers.forEach(member => {
                        const option = createDropdownOption(member, '');
                        dropdown.appendChild(option);
                    });
                    return;
                }
                
                // 검색어가 있으면 필터링된 멤버만 표시
                const filteredMembers = allMembers.filter(member => 
                    member.id.toLowerCase().includes(searchTerm.toLowerCase())
                );
                
                if (filteredMembers.length === 0) {
                    const noResult = document.createElement('div');
                    noResult.style.cssText = `
                        padding: 12px;
                        color: #7a7a7a;
                        text-align: center;
                        font-size: 14px;
                    `;
                    noResult.textContent = '검색 결과가 없습니다';
                    dropdown.appendChild(noResult);
                    return;
                }
                
                // 필터링된 결과는 최대 30개까지 표시
                const displayMembers = filteredMembers.slice(0, 30);
                
                displayMembers.forEach(member => {
                    const option = createDropdownOption(member, searchTerm);
                    dropdown.appendChild(option);
                });
            }
            
            // 드롭다운 옵션 생성 함수
            function createDropdownOption(member, searchTerm) {
                const option = document.createElement('div');
                option.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    color: #e1e1e1;
                    border-bottom: 1px solid #3a3a3a;
                    transition: background-color 0.2s ease;
                `;
                
                // 검색어가 있으면 하이라이트, 없으면 일반 표시
                let displayId = member.id;
                if (searchTerm && searchTerm.trim() !== '') {
                    displayId = member.id.replace(
                        new RegExp(searchTerm, 'gi'),
                        match => `<span style="background-color: #4a9eff; color: white; padding: 1px 2px; border-radius: 2px;">${match}</span>`
                    );
                }
                
                option.innerHTML = `
                    <div style="font-weight: 500; font-size: 14px;">${displayId}</div>
                    <div style="font-size: 12px; color: #7a7a7a;">${member.name} • ${member.email}</div>
                `;
                
                // 호버 효과
                option.addEventListener('mouseenter', () => {
                    option.style.backgroundColor = '#3a3a3a';
                });
                option.addEventListener('mouseleave', () => {
                    option.style.backgroundColor = 'transparent';
                });
                
                // 클릭 이벤트
                option.addEventListener('click', () => {
                    searchInput.value = member.id;
                    dropdown.style.display = 'none';
                    handleChartSearch(member.id);
                });
                
                return option;
            }
            
            // 검색 입력 컨테이너에 드롭다운 추가
            const inputContainer = searchInput.parentElement;
            inputContainer.style.position = 'relative';
            inputContainer.appendChild(dropdown);
            
            // 입력 이벤트로 실시간 필터링
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value;
                if (dropdown.style.display !== 'none') {
                    updateDropdownOptions(searchTerm);
                }
            });
            
            // 포커스 이벤트로 드롭다운 표시
            searchInput.addEventListener('focus', () => {
                updateDropdownOptions(searchInput.value);
                dropdown.style.display = 'block';
            });
            
            // 키보드 이벤트 처리
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                }
            });
            
            // 블러 이벤트로 드롭다운 숨김
            searchInput.addEventListener('blur', (e) => {
                setTimeout(() => {
                    if (!dropdown.contains(document.activeElement)) {
                        dropdown.style.display = 'none';
                    }
                }, 200);
            });
            
            console.log(`✅ 전체 멤버 대상 실시간 필터링 드롭다운 생성 완료: ${allMembers.length}명의 사용자`);
        }

        // 모델 선호도용 커스텀 드롭다운 생성
        function populateModelPreferenceDropdown() {
            console.log('📧 모델 선호도용 커스텀 드롭다운 생성 중...');
            
            const searchInput = document.getElementById('chart-search-input');
            if (!searchInput) {
                console.error('❌ chart-search-input 요소를 찾을 수 없습니다.');
                return;
            }
            
            // 기존 커스텀 드롭다운 제거
            const existingDropdown = document.getElementById('custom-model-preference-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }
            
            // 새 커스텀 드롭다운 생성
            const dropdown = document.createElement('div');
            dropdown.id = 'custom-model-preference-dropdown';
            dropdown.style.cssText = `
                position: absolute;
                top: calc(100% + 4px);
                left: 0;
                right: 0;
                background-color: #2a2a2a;
                border: 1px solid #3a3a3a;
                border-radius: 8px;
                max-height: 200px;
                overflow-y: auto;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                display: none;
            `;
            
            // 멤버 데이터 가져오기
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            
            if (!members || members.length === 0) {
                console.log('⚠️ 사용 가능한 멤버 데이터가 없습니다.');
                return;
            }
            
            // 전체 멤버를 대상으로 하는 드롭다운 목록 생성
            const allMembers = [];
            members.forEach(member => {
                const emailId = member.email.split('@')[0];
                allMembers.push({
                    id: emailId,
                    name: member.name,
                    email: member.email
                });
            });
            
            console.log(`📋 전체 멤버 목록 생성: ${allMembers.length}명`);
            
            // 드롭다운 업데이트 함수 (실시간 필터링)
            function updateDropdownOptions(searchTerm = '') {
                dropdown.innerHTML = '';
                
                // 검색어가 없으면 전체 멤버 표시 (최대 50개)
                if (searchTerm.trim() === '') {
                    const displayMembers = allMembers.slice(0, 50);
                    displayMembers.forEach(member => {
                        const option = createModelPreferenceDropdownOption(member, '');
                        dropdown.appendChild(option);
                    });
                    return;
                }
                
                // 검색어가 있으면 필터링된 멤버만 표시
                const filteredMembers = allMembers.filter(member => 
                    member.id.toLowerCase().includes(searchTerm.toLowerCase())
                );
                
                if (filteredMembers.length === 0) {
                    const noResult = document.createElement('div');
                    noResult.style.cssText = `
                        padding: 12px;
                        color: #7a7a7a;
                        text-align: center;
                        font-size: 14px;
                    `;
                    noResult.textContent = '검색 결과가 없습니다';
                    dropdown.appendChild(noResult);
                    return;
                }
                
                // 필터링된 결과는 최대 30개까지 표시
                const displayMembers = filteredMembers.slice(0, 30);
                
                displayMembers.forEach(member => {
                    const option = createModelPreferenceDropdownOption(member, searchTerm);
                    dropdown.appendChild(option);
                });
            }
            
            // 드롭다운 옵션 생성 함수
            function createModelPreferenceDropdownOption(member, searchTerm) {
                const option = document.createElement('div');
                option.style.cssText = `
                    padding: 8px 12px;
                    cursor: pointer;
                    color: #e1e1e1;
                    border-bottom: 1px solid #3a3a3a;
                    transition: background-color 0.2s ease;
                `;
                
                // 검색어가 있으면 하이라이트, 없으면 일반 표시
                let displayId = member.id;
                if (searchTerm && searchTerm.trim() !== '') {
                    displayId = member.id.replace(
                        new RegExp(searchTerm, 'gi'),
                        match => `<span style="background-color: #4a9eff; color: white; padding: 1px 2px; border-radius: 2px;">${match}</span>`
                    );
                }
                
                option.innerHTML = `
                    <div style="font-weight: 500; font-size: 14px;">${displayId}</div>
                    <div style="font-size: 12px; color: #7a7a7a;">${member.name} • ${member.email}</div>
                `;
                
                // 호버 효과
                option.addEventListener('mouseenter', () => {
                    option.style.backgroundColor = '#3a3a3a';
                });
                option.addEventListener('mouseleave', () => {
                    option.style.backgroundColor = 'transparent';
                });
                
                // 클릭 이벤트
                option.addEventListener('click', () => {
                    searchInput.value = member.id;
                    dropdown.style.display = 'none';
                    handleChartSearch(member.id);
                });
                
                return option;
            }
            
            // 검색 입력 컨테이너에 드롭다운 추가
            const inputContainer = searchInput.parentElement;
            inputContainer.style.position = 'relative';
            inputContainer.appendChild(dropdown);
            
            // 입력 이벤트로 실시간 필터링
            searchInput.addEventListener('input', (e) => {
                const searchTerm = e.target.value;
                if (dropdown.style.display !== 'none') {
                    updateDropdownOptions(searchTerm);
                }
            });
            
            // 포커스 이벤트로 드롭다운 표시
            searchInput.addEventListener('focus', () => {
                updateDropdownOptions(searchInput.value);
                dropdown.style.display = 'block';
            });
            
            // 키보드 이벤트 처리
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    dropdown.style.display = 'none';
                }
            });
            
            // 블러 이벤트로 드롭다운 숨김
            searchInput.addEventListener('blur', (e) => {
                setTimeout(() => {
                    if (!dropdown.contains(document.activeElement)) {
                        dropdown.style.display = 'none';
                    }
                }, 200);
            });
            
            console.log(`✅ 모델 선호도용 실시간 필터링 드롭다운 생성 완료: ${allMembers.length}명의 사용자`);
        }

        // 특정 사용자의 모델 사용량 차트 생성 (막대 그래프)
        function createFilteredModelPreferenceChart(userId) {
            console.log('🔥 createFilteredModelPreferenceChart 시작:', userId);
            
            const canvas = document.getElementById('modelPreferenceChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 특정 사용자의 모델 사용량 데이터 생성
            const userModelData = generateUserModelUsageData(userId);
            
            if (!userModelData || userModelData.length === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(`${userId}의 모델 사용 데이터가 없습니다.`, width / 2, height / 2);
                return;
            }
            
            // 막대 그래프 그리기
            drawUserModelBarChart(ctx, width, height, userModelData, userId);
        }

        // 특정 사용자의 모델 사용량 데이터 생성
        function generateUserModelUsageData(userId) {
            console.log('🔥 generateUserModelUsageData 시작:', userId);
            
            const members = (chartDataStore.members && chartDataStore.members.length > 0) ? 
                chartDataStore.members : (currentMembers || []);
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            if (!members || members.length === 0 || !rawEvents || rawEvents.length === 0) {
                console.log('⚠️ 데이터가 부족합니다.');
                return [];
            }
            
            // 사용자 찾기
            const user = members.find(member => {
                const emailId = member.email.split('@')[0];
                return emailId.toLowerCase() === userId.toLowerCase();
            });
            
            if (!user) {
                console.log('⚠️ 사용자를 찾을 수 없습니다.');
                return [];
            }
            
            // 해당 사용자의 이벤트 필터링
            const userEvents = rawEvents.filter(event => 
                event.userEmail === user.email || event.email === user.email
            );
            
            // 모델별 사용 횟수 계산
            const modelUsage = new Map();
            userEvents.forEach(event => {
                const model = event.model || 'unknown';
                modelUsage.set(model, (modelUsage.get(model) || 0) + 1);
            });
            
            // 배열로 변환 및 사용 횟수 순으로 정렬
            const data = Array.from(modelUsage.entries())
                .map(([model, count]) => ({ model, count }))
                .sort((a, b) => b.count - a.count);
            
            console.log(`🔥 ${userId}의 모델 사용량 데이터:`, data);
            return data;
        }

        // 사용자별 모델 사용량 막대 그래프 그리기 (모델 사용 분포 스타일)
        function drawUserModelBarChart(ctx, width, height, data, userId) {
            console.log('🔍 drawUserModelBarChart 시작...');
            console.log('📊 입력 데이터:', data);
            console.log('📏 캔버스 크기:', width, 'x', height);
            
            if (data.length === 0) {
                console.log('⚠️ 데이터가 비어있어 로딩 메시지를 표시합니다.');
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('데이터를 불러오는 중...', width / 2, height / 2);
                return;
            }
            
            const padding = 60;
            const chartWidth = width - (padding * 2);
            const chartHeight = height - (padding * 2);
            const barWidth = chartWidth / data.length * 0.8;
            const barSpacing = chartWidth / data.length * 0.2;
            
            // 최대값 계산
            const maxValue = Math.max(...data.map(d => d.count));
            
            // Y축 그리기
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.stroke();
            
            // X축 그리기
            ctx.beginPath();
            ctx.moveTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Y축 레이블
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            
            const ySteps = 5;
            for (let i = 0; i <= ySteps; i++) {
                const y = padding + (chartHeight / ySteps) * i;
                const value = Math.round((maxValue / ySteps) * (ySteps - i));
                ctx.fillText(value.toString(), padding - 10, y);
            }
            
            // 막대 그리기 (다양한 색상)
            const colors = ['#4a9eff', '#4caf50', '#ff9800', '#f44336', '#9c27b0', '#00bcd4', '#ff5722', '#795548', '#607d8b', '#e91e63'];
            
            data.forEach((item, index) => {
                const x = padding + (chartWidth / data.length) * index + barSpacing / 2;
                const barHeight = (item.count / maxValue) * chartHeight;
                const y = height - padding - barHeight;
                
                // 막대 그리기 (다양한 색상)
                ctx.fillStyle = colors[index % colors.length];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // 막대 위에 값 표시
                ctx.fillStyle = '#e1e1e1';
                ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.count.toString(), x + barWidth / 2, y - 10);
                
                // X축 레이블 (모델명)
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '11px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                const modelName = item.model.length > 12 ? item.model.substring(0, 12) + '...' : item.model;
                ctx.fillText(modelName, x + barWidth / 2, height - padding + 20);
            });
            
            // 제목
            ctx.fillStyle = '#e1e1e1';
            ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${userId}의 모델 사용량`, width / 2, 25);
            
            // Y축 제목
            ctx.fillStyle = '#7a7a7a';
            ctx.font = '12px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.save();
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('사용 횟수', 0, 0);
            ctx.restore();
        }

        // 여러 사용자 모델 선호도 차트 생성 (부분 검색 결과)
        function createMultiUserModelPreferenceChart(filteredUsers) {
            console.log('🔥 createMultiUserModelPreferenceChart 시작:', filteredUsers.length, '명');
            
            const canvas = document.getElementById('modelPreferenceChart');
            if (!canvas) return;
            
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = 300;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, width, height);
            
            // 필터된 사용자들의 모델 선호도 데이터 생성
            const preferenceData = generateFilteredModelPreferenceData(filteredUsers);
            
            if (preferenceData.size === 0) {
                ctx.fillStyle = '#7a7a7a';
                ctx.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('모델 선호도 데이터가 없습니다.', width / 2, height / 2);
                return;
            }
            
            // 스택 바 차트 그리기
            drawStackedBarChart(ctx, width, height, preferenceData);
        }

        // 필터된 사용자들의 모델 선호도 데이터 생성
        function generateFilteredModelPreferenceData(filteredUsers) {
            console.log('🔥 generateFilteredModelPreferenceData 시작:', filteredUsers.length, '명');
            
            const rawEvents = (chartDataStore.rawEvents && chartDataStore.rawEvents.length > 0) ? 
                chartDataStore.rawEvents : (currentRawEventsData || []);
            
            if (!rawEvents || rawEvents.length === 0) {
                console.log('⚠️ 이벤트 데이터가 없습니다.');
                return new Map();
            }
            
            // 사용자별 활동 및 모델 사용량 계산
            const userActivityData = [];
            filteredUsers.forEach(member => {
                const userEmail = member.email;
                const userId = userEmail.split('@')[0];
                
                const userEvents = rawEvents.filter(event => 
                    event.userEmail === userEmail || event.email === userEmail
                );
                
                // 활동이 없는 사용자는 제외
                if (userEvents.length === 0) {
                    return;
                }
                
                const modelUsage = new Map();
                userEvents.forEach(event => {
                    const model = event.model || 'unknown';
                    modelUsage.set(model, (modelUsage.get(model) || 0) + 1);
                });
                
                userActivityData.push({
                    userId: userId,
                    email: userEmail,
                    totalActivity: userEvents.length,
                    modelUsage: modelUsage
                });
            });
            
            // 활동 수로 정렬하여 상위 20명 선택
            const sortedUsers = userActivityData
                .sort((a, b) => b.totalActivity - a.totalActivity)
                .slice(0, 20);
            
            // Map 형태로 변환
            const userModelPreference = new Map();
            sortedUsers.forEach(user => {
                userModelPreference.set(user.userId, user.modelUsage);
            });
            
            console.log(`📊 필터된 모델 선호도 데이터 생성 완료: ${userModelPreference.size}명의 활성 사용자`);
            return userModelPreference;
        }

        // Usage 섹션 현재 필터로 업데이트
        async function updateUsageWithCurrentFilter(days = 30, showLoading = true) {
            try {
                // 이미 로딩 중이면 중복 실행 방지
                if (isUsageLoading) {
                    console.log('⚠️ Usage 데이터 로딩 중 - 중복 실행 방지');
                    return;
                }
                
                console.log(`=== Usage 섹션 ${days}일 필터로 업데이트 시작 (로딩 표시: ${showLoading}) ===`);
                
                isUsageLoading = true;
                
                // 날짜 범위 계산
                const dateRange = getDateRange(days);
                currentUsageDateRange = null; // 사용자 정의 범위 초기화
                
                // 필터 기간 표시 업데이트
                updateUsageFilterPeriodDisplay(dateRange.startDate, dateRange.endDate);
                
                await updateUsageWithDateRange(dateRange.startDate, dateRange.endDate, showLoading);
                
                // 첫 번째 로딩 완료 표시
                if (showLoading) {
                    isUsageDataLoaded = true;
                }
                
                isUsageLoading = false;
                console.log(`=== Usage 섹션 ${days}일 필터 업데이트 완료 ===`);
            } catch (error) {
                console.error('❌ Usage 필터 업데이트 실패:', error);
                isUsageLoading = false;
            }
        }

        // Usage 섹션 특정 날짜 범위로 업데이트
        async function updateUsageWithDateRange(startDate, endDate, showLoading = true) {
            try {
                console.log(`=== Usage 섹션 날짜 범위 업데이트 시작: ${new Date(startDate).toLocaleDateString()} ~ ${new Date(endDate).toLocaleDateString()} (로딩 표시: ${showLoading}) ===`);
                
                // 로딩 상태 표시 (첫 번째 로딩에만)
                if (showLoading) {
                    showUsageLoadingState(true);
                }
                
                // API 데이터 가져오기
                const [membersData, eventsData, usageData, spendingData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(startDate, endDate),
                    getUsageData(startDate, endDate),
                    getTeamSpendingData()
                ]);
                
                // Usage 카드 업데이트
                updateUsageCards(usageData, eventsData);
                
                // 사용자별 누적 사용량 정보 업데이트
                updateUserCumulativeInfo(membersData, eventsData, spendingData, startDate, endDate);
                
                // All Raw Events 업데이트 (페이지 초기화)
                currentRawEventsPage = 1;
                updateRawEventsTable(eventsData);
                
                // 로딩 상태 해제 (첫 번째 로딩에만)
                if (showLoading) {
                    showUsageLoadingState(false);
                }
                
                console.log(`=== Usage 섹션 날짜 범위 업데이트 완료 ===`);
            } catch (error) {
                console.error('❌ Usage 날짜 범위 업데이트 실패:', error);
                if (showLoading) {
                    showUsageLoadingState(false);
                }
            }
        }

        // Usage 로딩 상태 표시/해제
        function showUsageLoadingState(isLoading) {
            const usageCards = document.querySelectorAll('#usage .usage-card-number');
            const userTables = document.querySelectorAll('#usage .user-cumulative-info');
            
            if (isLoading) {
                usageCards.forEach(card => {
                    card.textContent = '-';
                });
                userTables.forEach(table => {
                    table.style.opacity = '0.5';
                });
            } else {
                userTables.forEach(table => {
                    table.style.opacity = '1';
                });
            }
        }

        // Usage 카드 업데이트 (Overview와 Usage 섹션 모두)
        function updateUsageCards(usageData, eventsData) {
            // Overview 섹션과 Usage 섹션 모두의 카드를 찾음
            const overviewCards = document.querySelectorAll('#overview .usage-card-number');
            const usageCards = document.querySelectorAll('#usage .usage-card-number');
            const allCards = [...overviewCards, ...usageCards];
            
            if (!usageData || !usageData.data) {
                allCards.forEach((card, index) => {
                    const cardIndex = index % 4; // 4개 카드 반복
                    card.textContent = '0';
                });
                console.log('📊 Usage 카드 업데이트: 데이터 없음 - 모든 값을 0으로 설정');
                return;
            }
            
            // 실제 활동한 사용자 수 계산
            const activeUsers = new Set();
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    if (event.userEmail && event.requestsCosts > 0) {
                        activeUsers.add(event.userEmail);
                    }
                });
            }
            
            // 집계 계산
            let totalLinesAdded = 0;
            let totalLinesAccepted = 0;
            let totalTabsAccepted = 0;
            let totalChats = 0;
            
            usageData.data.forEach(dayData => {
                totalLinesAdded += (dayData.totalLinesAdded || 0);
                totalLinesAccepted += (dayData.acceptedLinesAdded || 0);
                totalTabsAccepted += (dayData.totalTabsAccepted || 0);
                totalChats += (dayData.chatRequests || 0);
            });
            
            // 카드 업데이트 (Overview와 Usage 섹션 모두)
            const values = [
                activeUsers.size.toLocaleString(), // Total Users
                (totalLinesAdded + totalLinesAccepted).toLocaleString(), // Lines of Agent Edits
                totalTabsAccepted.toLocaleString(), // Tabs Accepted
                totalChats.toLocaleString() // Chats
            ];
            
            allCards.forEach((card, index) => {
                const cardIndex = index % 4; // 4개 카드 반복
                card.textContent = values[cardIndex];
            });
            
            console.log(`Usage 카드 업데이트: 사용자 ${activeUsers.size}명, 라인 ${totalLinesAdded + totalLinesAccepted}줄, 탭 ${totalTabsAccepted}개, 채팅 ${totalChats}건`);
        }

        // 사용자별 누적 사용량 정보 테이블 렌더링 (All Raw Events 스타일)
        function renderUserCumulativeTableWithPagination(userInfos, startDate, endDate) {
            console.log('🎨 renderUserCumulativeTableWithPagination 함수 호출됨');
            console.log('📊 렌더링 데이터:', {
                userInfos: userInfos ? `${userInfos.length}명` : 'null',
                startDate: startDate,
                endDate: endDate
            });
            
            // 헤더 업데이트
            const headerElement = document.querySelector('.user-cumulative-info .user-cumulative-header');
            if (headerElement) {
                if (!userInfos || userInfos.length === 0) {
                    headerElement.innerHTML = '📊 사용자별 누적 사용량 정보';
                } else {
                    const totalUsers = userInfos.length;
                    const totalPages = Math.ceil(totalUsers / currentUserCumulativePageSize);
                    const startIndex = (currentUserCumulativePage - 1) * currentUserCumulativePageSize;
                    const endIndex = Math.min(startIndex + currentUserCumulativePageSize, totalUsers);
                    
                    // 날짜 형식 변경 (날짜 끝의 "." 제거)
                    const cleanStartDate = new Date(startDate).toLocaleDateString('ko-KR').replace(/\.$/, '');
                    const cleanEndDate = new Date(endDate).toLocaleDateString('ko-KR').replace(/\.$/, '');
                    
                    headerElement.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span>📊 사용자별 누적 사용량 정보 (${cleanStartDate} ~ ${cleanEndDate})(${startIndex + 1}-${endIndex} of ${totalUsers})</span>
                            <select id="userCumulativePageSize" onchange="changeUserCumulativePageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                                <option value="10" ${currentUserCumulativePageSize === 10 ? 'selected' : ''}>10개 보기</option>
                                <option value="20" ${currentUserCumulativePageSize === 20 ? 'selected' : ''}>20개 보기</option>
                                <option value="30" ${currentUserCumulativePageSize === 30 ? 'selected' : ''}>30개 보기</option>
                                <option value="50" ${currentUserCumulativePageSize === 50 ? 'selected' : ''}>50개 보기</option>
                                <option value="100" ${currentUserCumulativePageSize === 100 ? 'selected' : ''}>100개 보기</option>
                            </select>
                        </div>
                    `;
                }
            }
            
            if (!userInfos || userInfos.length === 0) {
                const container = document.getElementById('user-cumulative-container');
                if (container) {
                    container.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a;">
                            사용자별 누적 사용량 데이터가 없습니다.
                        </div>
                    `;
                }
                // 페이지네이션 숨기기
                const pagination = document.getElementById('user-cumulative-pagination');
                if (pagination) pagination.style.display = 'none';
                return;
            }
            
            // 페이지네이션 계산
            const totalUsers = userInfos.length;
            const totalPages = Math.ceil(totalUsers / currentUserCumulativePageSize);
            const startIndex = (currentUserCumulativePage - 1) * currentUserCumulativePageSize;
            const endIndex = Math.min(startIndex + currentUserCumulativePageSize, totalUsers);
            const pageUsers = userInfos.slice(startIndex, endIndex);

            console.log(`📄 사용자별 누적 사용량 페이지네이션: ${startIndex + 1}-${endIndex} of ${totalUsers} (페이지 ${currentUserCumulativePage}/${totalPages})`);
            
            // 테이블 내용만 업데이트
            const tableContent = pageUsers.map(user => `
                <div class="user-cumulative-row">
                    <div>${user.name}</div>
                    <div class="user-email clickable-email" title="View usage for ${user.email}" onclick="navigateToUsageWithEmail('${user.email}')">${user.email}</div>
                    <div><span class="role-badge ${user.role === 'owner' ? 'admin' : ''}">${user.role === 'owner' ? 'Admin' : 'Member'}</span></div>
                    <div style="font-weight: 600;">${user.periodRequests}</div>
                    <div>$${user.spend.toFixed(2)}</div>
                    <div>${user.lastActivity}</div>
                </div>
            `).join('');
            
            // 컨테이너에 테이블 내용만 삽입
            const container = document.getElementById('user-cumulative-container');
            if (container) {
                container.innerHTML = tableContent;
            }

            // 페이지네이션 업데이트
            const paginationContainer = document.getElementById('user-cumulative-pagination');
            if (paginationContainer && totalPages > 1) {
                paginationContainer.innerHTML = generateUserCumulativePagination(totalPages);
                paginationContainer.style.display = 'block';
            } else if (paginationContainer) {
                paginationContainer.style.display = 'none';
            }
            
            console.log('✅ 사용자별 누적 사용량 정보 테이블 HTML 렌더링 완료');
            console.log(`📊 사용자별 누적 사용량 정보 업데이트: 총 ${userInfos.length}명 (페이지 ${currentUserCumulativePage}/${totalPages})`);
        }
        

        
        // 사용자별 누적 사용량 정보 페이지 변경 (All Raw Events 스타일)
        function changeUserCumulativePage(page) {
            currentUserCumulativePage = page;
            renderUserCumulativeTableWithPagination(currentUserCumulativeData, currentUserCumulativeStartDate, currentUserCumulativeEndDate);
        }
        
        // 사용자별 누적 사용량 정보 페이지 크기 변경 (All Raw Events 스타일)
        function changeUserCumulativePageSize(pageSize) {
            currentUserCumulativePageSize = parseInt(pageSize);
            currentUserCumulativePage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderUserCumulativeTableWithPagination(currentUserCumulativeData, currentUserCumulativeStartDate, currentUserCumulativeEndDate);
        }

        // 사용자별 누적 사용량 정보 업데이트
        function updateUserCumulativeInfo(membersData, eventsData, spendingData, startDate, endDate) {
            console.log('🔍 updateUserCumulativeInfo 함수 호출됨');
            console.log('📊 전달받은 데이터:', {
                membersData: membersData ? `${membersData.teamMembers?.length || 0}명` : 'null',
                eventsData: eventsData ? `${eventsData.usageEvents?.length || 0}개 이벤트` : 'null',
                spendingData: spendingData ? `${spendingData.teamMemberSpend?.length || 0}개 지출` : 'null',
                startDate: startDate,
                endDate: endDate
            });
            
            if (!membersData || !membersData.teamMembers) {
                console.log('⚠️ 사용자별 누적 사용량 정보: 멤버 데이터가 없습니다.');
                console.log('상세 정보:', {
                    membersData: !!membersData,
                    teamMembers: membersData?.teamMembers?.length || 0
                });
                return;
            }
            
            console.log('=== 사용자별 누적 사용량 정보 업데이트 시작 ===');
            
            // 지출 데이터 매핑
            const memberSpendMap = {};
            if (spendingData && spendingData.teamMemberSpend) {
                spendingData.teamMemberSpend.forEach(spendInfo => {
                    memberSpendMap[spendInfo.email] = {
                        premiumRequests: spendInfo.fastPremiumRequests || 0,
                        spend: (spendInfo.spendCents || 0) / 100,
                        hardLimitOverride: spendInfo.hardLimitOverrideDollars || 0
                    };
                });
            }
            
            // 선택된 기간 내 사용자별 활동 통계 계산
            const userPeriodStats = {};
            if (eventsData && eventsData.usageEvents) {
                eventsData.usageEvents.forEach(event => {
                    const userEmail = event.userEmail;
                    const timestamp = parseInt(event.timestamp);
                    
                    if (!userPeriodStats[userEmail]) {
                        userPeriodStats[userEmail] = {
                            lastTimestamp: timestamp,
                            periodRequests: 0
                        };
                    }
                    
                    // 마지막 활동 시간 업데이트
                    if (timestamp > userPeriodStats[userEmail].lastTimestamp) {
                        userPeriodStats[userEmail].lastTimestamp = timestamp;
                    }
                    
                    // 선택된 기간 내 요청 비용 누적 (All Raw Events의 COST값과 동일)
                    const requestCost = event.requestsCosts || 0;
                    userPeriodStats[userEmail].periodRequests += requestCost;
                    
                    // 디버깅을 위한 로그 (처음 5개 이벤트만)
                    if (Object.keys(userPeriodStats).length <= 5 && userPeriodStats[userEmail].periodRequests <= requestCost * 3) {
                        console.log(`💰 ${userEmail}: +${requestCost} (누적: ${userPeriodStats[userEmail].periodRequests})`);
                    }
                });
            }
            
            // 사용자 정보 생성
            const userInfos = membersData.teamMembers.map(member => {
                const spendData = memberSpendMap[member.email] || {};
                const periodStats = userPeriodStats[member.email] || {};
                const actualSpend = spendData.spend || 0;
                const totalPremiumRequests = spendData.premiumRequests || 0; // 전체 기간 Premium Requests
                const periodRequests = periodStats.periodRequests || 0; // 선택된 기간 내 요청 수
                
                // 마지막 활동 날짜 계산
                let lastActivityText = 'No Activity';
                if (periodStats.lastTimestamp) {
                    const lastDate = new Date(periodStats.lastTimestamp);
                    const today = new Date();
                    const daysDiff = Math.floor((today - lastDate) / (1000 * 60 * 60 * 24));
                    
                    if (daysDiff === 0) {
                        lastActivityText = '오늘';
                    } else if (daysDiff === 1) {
                        lastActivityText = '어제';
                    } else {
                        lastActivityText = `${daysDiff}일 전`;
                    }
                }
                
                return {
                    name: member.name || 'Unnamed',
                    email: member.email,
                    role: member.role,
                    totalPremiumRequests: totalPremiumRequests, // 전체 Premium Requests
                    periodRequests: periodRequests, // 선택된 기간 내 요청 수
                    spend: actualSpend,
                    lastActivity: lastActivityText,
                    lastTimestamp: periodStats.lastTimestamp || 0
                };
            });
            
            // 1. Last Act 최신순, 2. Request 기준 내림차순으로 정렬
            userInfos.sort((a, b) => {
                // 1차 정렬: Last Act (마지막 활동) 최신순 - timestamp 기준 내림차순
                if (b.lastTimestamp !== a.lastTimestamp) {
                    return b.lastTimestamp - a.lastTimestamp;
                }
                // 2차 정렬: Request 기준 내림차순
                return b.periodRequests - a.periodRequests;
            });
            
            // 데이터 저장 및 페이지네이션 적용
            currentUserCumulativeData = userInfos;
            currentUserCumulativeStartDate = startDate;
            currentUserCumulativeEndDate = endDate;
            currentUserCumulativePage = 1; // 첫 페이지로 리셋
            
            // 페이지네이션 적용
            renderUserCumulativeTableWithPagination(userInfos, startDate, endDate);
            
            console.log(`사용자별 누적 사용량 정보 업데이트 완료: ${userInfos.length}명`);
            console.log(`선택된 기간 내 총 요청 수: ${userInfos.reduce((sum, user) => sum + user.periodRequests, 0)}건`);
        }

        // All Raw Events 테이블 업데이트
        function updateRawEventsTable(eventsData) {
            const tableContainer = document.querySelector('#usage .user-cumulative-info:last-child');
            if (!tableContainer || !eventsData || !eventsData.usageEvents) return;
            
            // 검색 중인 경우 자동 업데이트 방지
            if (window.pendingEmailSearch) {
                console.log(`⏳ 이메일 검색 대기 중 (${window.pendingEmailSearch}) - Raw Events 테이블 자동 업데이트 건너뜀`);
                // 데이터는 저장하되 테이블 렌더링은 하지 않음
                currentRawEventsData = eventsData.usageEvents.sort((a, b) => {
                    const timestampA = parseInt(a.timestamp) || 0;
                    const timestampB = parseInt(b.timestamp) || 0;
                    return timestampB - timestampA; // 내림차순 (최신 → 과거)
                });
                return;
            }
            
            // 전체 데이터 저장 및 DATE 기준 내림차순 정렬 (최신순)
            currentRawEventsData = eventsData.usageEvents.sort((a, b) => {
                const timestampA = parseInt(a.timestamp) || 0;
                const timestampB = parseInt(b.timestamp) || 0;
                return timestampB - timestampA; // 내림차순 (최신 → 과거)
            });
            
            // 페이지네이션 적용
            renderRawEventsTableWithPagination();
        }

        // Raw Events 테이블 페이지네이션과 함께 렌더링
        function renderRawEventsTableWithPagination() {
            const tableContainer = document.querySelector('#usage .user-cumulative-info:last-child');
            if (!tableContainer || !currentRawEventsData.length) return;
            
            const totalEvents = currentRawEventsData.length;
            const totalPages = Math.ceil(totalEvents / currentRawEventsPageSize);
            const startIndex = (currentRawEventsPage - 1) * currentRawEventsPageSize;
            const endIndex = Math.min(startIndex + currentRawEventsPageSize, totalEvents);
            const pageEvents = currentRawEventsData.slice(startIndex, endIndex);
            
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>📋 All Raw Events (${startIndex + 1}-${endIndex} of ${totalEvents})</span>
                    <select id="rawEventsPageSize" onchange="changeRawEventsPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${currentRawEventsPageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${currentRawEventsPageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${currentRawEventsPageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${currentRawEventsPageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${currentRawEventsPageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>COST</div>
                </div>
                ${pageEvents.map(event => {
                    const date = new Date(parseInt(event.timestamp));
                    const dateText = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    return `
                        <div class="user-cumulative-row">
                            <div>${dateText}</div>
                            <div class="user-email">${event.userEmail}</div>
                            <div>${(event.kindLabel || 'Unknown').substring(0, 15)}${(event.kindLabel || '').length > 15 ? '...' : ''}</div>
                            <div>${event.maxMode ? 'Yes' : 'No'}</div>
                            <div>${(event.model || 'auto').substring(0, 10)}${(event.model || '').length > 10 ? '...' : ''}</div>
                            <div>${event.requestsCosts || 0}</div>
                        </div>
                    `;
                }).join('')}
                ${totalPages > 1 ? `
                    <div style="padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        ${generateRawEventsPagination(totalPages)}
                    </div>
                ` : ''}
            `;
            
            tableContainer.innerHTML = tableHtml;
            
            console.log(`Raw Events 테이블 업데이트 완료: 페이지 ${currentRawEventsPage}/${totalPages}, ${pageEvents.length}개 이벤트 표시`);
        }

        // Raw Events 페이지네이션 생성
        function generateRawEventsPagination(totalPages) {
            let pagination = '';
            
            // 이전 버튼
            if (currentRawEventsPage > 1) {
                pagination += `<button onclick="changeRawEventsPage(${currentRawEventsPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">‹</button>`;
            }
            
            // 페이지 번호들
            let startPage = Math.max(1, currentRawEventsPage - 2);
            let endPage = Math.min(totalPages, currentRawEventsPage + 2);
            
            // 첫 페이지가 범위에 없으면 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeRawEventsPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 현재 범위의 페이지들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentRawEventsPage;
                pagination += `<button onclick="changeRawEventsPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid ${isActive ? '#4a9eff' : '#4a4a4a'}; color: ${isActive ? 'white' : '#e1e1e1'}; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px; font-weight: ${isActive ? '600' : 'normal'};">${i}</button>`;
            }
            
            // 마지막 페이지가 범위에 없으면 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeRawEventsPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${totalPages}</button>`;
            }
            
            // 다음 버튼
            if (currentRawEventsPage < totalPages) {
                pagination += `<button onclick="changeRawEventsPage(${currentRawEventsPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">›</button>`;
            }
            
            return pagination;
        }

        // Raw Events 페이지 변경
        function changeRawEventsPage(page) {
            currentRawEventsPage = page;
            renderRawEventsTableWithPagination();
        }

        // Raw Events 페이지 크기 변경
        function changeRawEventsPageSize(pageSize) {
            currentRawEventsPageSize = parseInt(pageSize);
            currentRawEventsPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            renderRawEventsTableWithPagination();
        }

        // 필터링된 Raw Events 테이블 렌더링 (페이지네이션 포함)
        function renderFilteredRawEventsTable(filteredEvents, container) {
            if (!container || !filteredEvents) return;
            
            // 페이지네이션 설정 - 기존 설정이 있으면 사용, 없으면 기본값
            const pageSize = window.currentFilteredEventsPageSize || 20;
            const currentPage = window.currentFilteredEventsPage || 1;
            const totalPages = Math.ceil(filteredEvents.length / pageSize);
            
            // 현재 페이지의 이벤트만 추출
            const startIndex = (currentPage - 1) * pageSize;
            const endIndex = Math.min(startIndex + pageSize, filteredEvents.length);
            const pageEvents = filteredEvents.slice(startIndex, endIndex);
            
            console.log(`📄 필터링된 Raw Events 페이지네이션: ${startIndex + 1}-${endIndex} of ${filteredEvents.length} (페이지 ${currentPage}/${totalPages})`);
            
            // 일반 테이블과 동일한 구조로 HTML 생성 (페이지네이션 포함)
            const tableHtml = `
                <div class="user-cumulative-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>📋 All Raw Events - 검색 결과 (${startIndex + 1}-${endIndex} of ${filteredEvents.length})</span>
                    <select onchange="changeFilteredEventsPageSize(this.value)" style="background: #3a3a3a; color: #fff; border: 1px solid #4a4a4a; padding: 5px 10px; border-radius: 4px; font-size: 12px;">
                        <option value="10" ${pageSize === 10 ? 'selected' : ''}>10개 보기</option>
                        <option value="20" ${pageSize === 20 ? 'selected' : ''}>20개 보기</option>
                        <option value="30" ${pageSize === 30 ? 'selected' : ''}>30개 보기</option>
                        <option value="50" ${pageSize === 50 ? 'selected' : ''}>50개 보기</option>
                        <option value="100" ${pageSize === 100 ? 'selected' : ''}>100개 보기</option>
                    </select>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>COST</div>
                </div>
                ${pageEvents.map(event => {
                    const date = new Date(parseInt(event.timestamp));
                    const dateText = date.toLocaleDateString('en-US', { 
                        month: 'short', 
                        day: 'numeric', 
                        hour: '2-digit', 
                        minute: '2-digit' 
                    });
                    
                    return `
                        <div class="user-cumulative-row">
                            <div>${dateText}</div>
                            <div class="user-email">${event.userEmail}</div>
                            <div>${(event.kindLabel || 'Unknown').substring(0, 15)}${(event.kindLabel || '').length > 15 ? '...' : ''}</div>
                            <div>${event.maxMode ? 'Yes' : 'No'}</div>
                            <div>${(event.model || 'auto').substring(0, 10)}${(event.model || '').length > 10 ? '...' : ''}</div>
                            <div>${event.requestsCosts || 0}</div>
                        </div>
                    `;
                }).join('')}
                ${totalPages > 1 ? `
                    <div style="padding: 15px 20px; background-color: #2a2a2a; border-top: 1px solid #3a3a3a; display: flex; justify-content: center; align-items: center; gap: 10px;">
                        ${generateFilteredEventsPagination(totalPages, currentPage)}
                    </div>
                ` : ''}
            `;
            
            container.innerHTML = tableHtml;
            
            // 필터링된 이벤트 데이터 저장 (페이지네이션용)
            window.currentFilteredEvents = filteredEvents;
            window.currentFilteredEventsPage = currentPage;
            window.currentFilteredEventsPageSize = pageSize;
            
            console.log(`필터링된 Raw Events 테이블 렌더링 완료: ${filteredEvents.length}개 이벤트 (페이지 ${currentPage}/${totalPages}, 페이지당 ${pageSize}개)`);
        }

        // 빈 Raw Events 테이블 렌더링
        function renderEmptyRawEventsTable(container, searchedEmails) {
            if (!container) return;
            
            const emailList = searchedEmails.join(', ');
            
            const tableHtml = `
                <div class="user-cumulative-header">
                    <span>📋 All Raw Events - 검색 결과 (0개)</span>
                </div>
                <div class="user-cumulative-table">
                    <div>DATE</div>
                    <div>USER</div>
                    <div>KIND</div>
                    <div>MAX_MODEL</div>
                    <div>MODEL</div>
                    <div>COST</div>
                </div>
                <div style="padding: 40px 20px; text-align: center; color: #7a7a7a; background-color: #1a1a1a; grid-column: 1 / -1;">
                    <h3 style="color: #e1e1e1; margin-bottom: 10px;">검색된 사용자의 활동이 없습니다</h3>
                    <p style="margin-bottom: 15px;">검색 대상: <strong style="color: #4a9eff;">${emailList}</strong></p>
                    <p style="font-size: 14px; line-height: 1.4;">
                        • 해당 사용자가 선택된 기간에 활동하지 않았을 수 있습니다<br>
                        • 다른 날짜 범위를 선택해보세요<br>
                        • 또는 다른 사용자를 검색해보세요
                    </p>
                </div>
            `;
            
            container.innerHTML = tableHtml;
            console.log(`빈 Raw Events 테이블 렌더링 완료 (검색 대상: ${emailList})`);
        }

        // 필터링된 이벤트 페이지네이션 생성 (일반 테이블과 동일한 구조)
        function generateFilteredEventsPagination(totalPages, currentPage) {
            let pagination = '';
            
            // 이전 페이지 버튼
            if (currentPage > 1) {
                pagination += `<button onclick="changeFilteredEventsPage(${currentPage - 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">‹</button>`;
            }
            
            // 페이지 번호 버튼들
            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, currentPage + 2);
            
            // 시작 페이지가 1이 아니면 첫 페이지 버튼 추가
            if (startPage > 1) {
                pagination += `<button onclick="changeFilteredEventsPage(1)" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">1</button>`;
                if (startPage > 2) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
            }
            
            // 페이지 번호들
            for (let i = startPage; i <= endPage; i++) {
                const isActive = i === currentPage;
                pagination += `<button onclick="changeFilteredEventsPage(${i})" style="background: ${isActive ? '#4a9eff' : '#3a3a3a'}; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${i}</button>`;
            }
            
            // 끝 페이지가 totalPages가 아니면 마지막 페이지 버튼 추가
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) {
                    pagination += `<span style="color: #7a7a7a; padding: 0 5px;">...</span>`;
                }
                pagination += `<button onclick="changeFilteredEventsPage(${totalPages})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">${totalPages}</button>`;
            }
            
            // 다음 페이지 버튼
            if (currentPage < totalPages) {
                pagination += `<button onclick="changeFilteredEventsPage(${currentPage + 1})" style="background: #3a3a3a; border: 1px solid #4a4a4a; color: #e1e1e1; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 12px;">›</button>`;
            }
            
            return pagination;
        }

        // 필터링된 이벤트 페이지 변경
        function changeFilteredEventsPage(page) {
            if (!window.currentFilteredEvents) {
                console.log('⚠️ 필터링된 이벤트 데이터가 없습니다.');
                return;
            }
            
            window.currentFilteredEventsPage = page;
            const filteredEvents = window.currentFilteredEvents;
            const container = document.querySelector('#usage .user-cumulative-info:last-child');
            
            console.log(`📄 필터링된 Raw Events 페이지 변경: 페이지 ${page}로 이동`);
            console.log(`📄 컨테이너 발견: ${!!container}, 필터링된 이벤트 수: ${filteredEvents.length}`);
            
            if (container) {
                // renderFilteredRawEventsTable 함수를 재사용
                renderFilteredRawEventsTable(filteredEvents, container);
            } else {
                console.error('❌ Raw Events 컨테이너를 찾을 수 없습니다.');
            }
        }

        // 필터링된 이벤트 페이지 크기 변경
        function changeFilteredEventsPageSize(newPageSize) {
            console.log(`🔧 changeFilteredEventsPageSize 호출됨: ${newPageSize}`);
            console.log(`📊 현재 상태: currentFilteredEvents=${!!window.currentFilteredEvents}, currentFilteredEventsPage=${window.currentFilteredEventsPage}, currentFilteredEventsPageSize=${window.currentFilteredEventsPageSize}`);
            
            if (!window.currentFilteredEvents) {
                console.log('⚠️ 필터링된 이벤트 데이터가 없습니다.');
                return;
            }
            
            window.currentFilteredEventsPageSize = parseInt(newPageSize);
            window.currentFilteredEventsPage = 1; // 페이지 크기 변경시 첫 페이지로 이동
            
            const filteredEvents = window.currentFilteredEvents;
            const container = document.querySelector('#usage .user-cumulative-info:last-child');
            
            console.log(`📄 필터링된 Raw Events 페이지 크기 변경: ${newPageSize}개로 변경, 첫 페이지로 이동`);
            console.log(`📄 컨테이너 발견: ${!!container}, 필터링된 이벤트 수: ${filteredEvents.length}`);
            
            if (container) {
                // renderFilteredRawEventsTable 함수를 재사용
                renderFilteredRawEventsTable(filteredEvents, container);
            } else {
                console.error('❌ Raw Events 컨테이너를 찾을 수 없습니다.');
            }
        }
        
        // 디버깅용 전역 함수
        window.debugFilteredEvents = function() {
            console.log('=== 필터링된 이벤트 상태 디버깅 ===');
            console.log('currentFilteredEvents:', window.currentFilteredEvents ? window.currentFilteredEvents.length + '개' : 'null');
            console.log('currentFilteredEventsPage:', window.currentFilteredEventsPage);
            console.log('currentFilteredEventsPageSize:', window.currentFilteredEventsPageSize);
            console.log('컨테이너:', document.querySelector('#usage .user-cumulative-info:last-child'));
            console.log('==============================');
        };



        // Usage 멤버 검색 기능 (사용자별 누적 사용량 정보와 All Raw Events 테이블 연동)
        function filterUsageMembers(searchTerm) {
            const searchLower = searchTerm.toLowerCase().trim();
            
            console.log(`🔍 Usage 멤버 검색 시작: "${searchTerm}"`);
            
            // 검색어가 비어있으면 모든 행 표시
            if (searchLower === '') {
                const allRows = document.querySelectorAll('#usage .user-cumulative-row');
                allRows.forEach(row => {
                    row.style.display = 'grid';
                });
                
                // 전체 이벤트 로그 테이블도 함께 갱신
                if (currentRawEventsData && currentRawEventsData.length > 0) {
                    // 필터링된 이벤트 변수들 정리
                    delete window.currentFilteredEvents;
                    delete window.currentFilteredEventsPage;
                    delete window.currentFilteredEventsPageSize;
                    
                    renderRawEventsTableWithPagination();
                    console.log('✅ 검색어 없음 - 전체 Raw Events 페이지네이션 복원');
                }
                
                console.log('✅ 검색어 없음 - 모든 행 표시 및 전체 이벤트 로그 갱신');
                return;
            }
            
            // 이메일 주소인지 확인 (@ 포함 여부로 판단)
            const isEmailSearch = searchLower.includes('@');
            
            // 모든 Usage 섹션의 user-cumulative-info 컨테이너 가져오기
            const userInfoContainers = document.querySelectorAll('#usage .user-cumulative-info');
            
            if (userInfoContainers.length === 0) {
                console.log('⚠️ Usage 섹션의 user-cumulative-info 컨테이너를 찾을 수 없습니다.');
                return;
            }
            
            console.log(`📋 발견된 테이블 컨테이너: ${userInfoContainers.length}개`);
            
            // 사용자별 누적 사용량 정보 테이블 (첫 번째 컨테이너)과 All Raw Events 테이블 (두 번째 컨테이너) 구분
            const userCumulativeContainer = userInfoContainers[0]; // 첫 번째: 사용자별 누적 사용량 정보
            const rawEventsContainer = userInfoContainers[1]; // 두 번째: All Raw Events
            
            // 1. 사용자별 누적 사용량 정보 테이블에서 필터링하고 매칭된 이메일 수집
            const matchedEmails = new Set();
            
            // 정확한 이메일 매칭이 있는지 먼저 확인
            let hasExactMatch = false;
            if (isEmailSearch) {
                const allEmailElements = userCumulativeContainer.querySelectorAll('.user-cumulative-row .user-email, .user-cumulative-row div:nth-child(2)');
                hasExactMatch = Array.from(allEmailElements).some(element => 
                    element.textContent.toLowerCase().trim() === searchLower
                );
                console.log(`🔍 정확한 이메일 매칭 확인: ${hasExactMatch ? '발견됨' : '없음'}`);
            }
            
            // 사용자별 누적 사용량 정보 테이블 필터링
            const userCumulativeRows = userCumulativeContainer.querySelectorAll('.user-cumulative-row');
            console.log(`📊 사용자별 누적 사용량 정보: ${userCumulativeRows.length}개 행 발견`);
            
            userCumulativeRows.forEach(row => {
                if (row.children.length < 2) return; // 충분한 컬럼이 없으면 스킵
                
                const name = row.children[0].textContent.toLowerCase().trim();
                const email = row.children[1].textContent.toLowerCase().trim();
                
                let shouldShow = false;
                
                if (isEmailSearch) {
                    if (hasExactMatch) {
                        // 정확한 매칭이 있으면 정확한 매칭만 표시
                        shouldShow = email === searchLower;
                    } else {
                        // 정확한 매칭이 없으면 부분 매칭 허용
                        shouldShow = email.includes(searchLower);
                    }
                } else {
                    // 일반 검색: 이름 또는 이메일 부분 매칭
                    shouldShow = name.includes(searchLower) || email.includes(searchLower);
                }
                
                if (shouldShow) {
                    row.style.display = 'grid';
                    // 매칭된 이메일을 수집 (원본 이메일 저장)
                    const originalEmail = row.children[1].textContent.trim();
                    matchedEmails.add(originalEmail);
                } else {
                    row.style.display = 'none';
                }
            });
            
            console.log(`📧 매칭된 이메일: ${Array.from(matchedEmails).join(', ')}`);
            
            // 2. All Raw Events 테이블 연동 필터링 (전체 데이터에서 검색)
            if (rawEventsContainer && currentRawEventsData && currentRawEventsData.length > 0) {
                console.log(`📋 All Raw Events 전체 데이터: ${currentRawEventsData.length}개 이벤트`);
                console.log(`🔍 매칭 대상 이메일: ${Array.from(matchedEmails).join(', ')}`);
                
                // 검색어가 있으면 매칭된 이메일의 이벤트만 필터링
                if (matchedEmails.size > 0) {
                    // 새로운 검색 시작 시 페이지네이션 변수 초기화
                    window.currentFilteredEventsPage = 1;
                    window.currentFilteredEventsPageSize = window.currentFilteredEventsPageSize || 20;
                    
                    const filteredEvents = currentRawEventsData.filter(event => {
                        const eventUserEmail = event.userEmail?.trim() || '';
                        
                        // 정확한 이메일 매칭만 수행 (대소문자 무시)
                        return Array.from(matchedEmails).some(email => {
                            const emailLower = email.toLowerCase().trim();
                            const eventEmailLower = eventUserEmail.toLowerCase().trim();
                            return emailLower === eventEmailLower;
                        });
                    });
                    
                    console.log(`✅ 필터링된 Raw Events: ${filteredEvents.length}개`);
                    
                    if (filteredEvents.length > 0) {
                        // 필터링된 데이터로 테이블 다시 렌더링
                        renderFilteredRawEventsTable(filteredEvents, rawEventsContainer);
                        console.log(`✅ ${filteredEvents.length}개의 매칭된 이벤트를 표시했습니다.`);
                        console.log(`📊 전역 변수 상태: currentFilteredEvents=${!!window.currentFilteredEvents}, currentFilteredEventsPage=${window.currentFilteredEventsPage}, currentFilteredEventsPageSize=${window.currentFilteredEventsPageSize}`);
                    } else {
                        // 매칭된 이벤트가 없으면 빈 테이블 표시
                        renderEmptyRawEventsTable(rawEventsContainer, Array.from(matchedEmails));
                        console.log('⚠️ 매칭된 사용자의 Raw Events가 없습니다.');
                        console.log('💡 해당 사용자가 선택된 기간에 활동하지 않았을 수 있습니다.');
                    }
                } else {
                    // 검색어가 없으면 원래 페이지네이션 방식으로 복원
                    renderRawEventsTableWithPagination();
                    console.log('✅ 검색어 없음 - 전체 Raw Events 페이지네이션 복원');
                }
            } else {
                console.log('⚠️ All Raw Events 컨테이너 또는 데이터를 찾을 수 없습니다.');
                console.log(`   - 컨테이너 존재: ${!!rawEventsContainer}`);
                console.log(`   - 데이터 존재: ${!!currentRawEventsData}`);
                console.log(`   - 데이터 길이: ${currentRawEventsData?.length || 0}`);
            }
            
            const matchingType = isEmailSearch ? (hasExactMatch ? '정확한 이메일 매칭' : '이메일 부분 매칭') : '부분 매칭';
            console.log(`✅ Usage 검색 완료: "${searchTerm}" - ${matchingType}으로 두 테이블 연동 필터링 완료 (매칭된 사용자 ${matchedEmails.size}명)`);
            
            // 검색 완료 후 대기 중인 이메일 검색 플래그 제거
            if (window.pendingEmailSearch) {
                console.log(`🔄 이메일 검색 플래그 제거: ${window.pendingEmailSearch}`);
                delete window.pendingEmailSearch;
            }
        }

        // 멤버 정렬 기능
        let currentSortField = 'requests';
        let currentSortDirection = 'desc';

        function sortMembers(field) {
            const dataTable = document.querySelector('#members .data-table');
            const rows = Array.from(dataTable.querySelectorAll('.table-row'));
           
            // 정렬 방향 토글
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc';
            }
           
            // 정렬 함수
            rows.sort((a, b) => {
                let aValue, bValue;
               
                switch(field) {
                    case 'name':
                        aValue = a.children[0].textContent.toLowerCase();
                        bValue = b.children[0].textContent.toLowerCase();
                        break;
                    case 'email':
                        aValue = a.children[1].textContent.toLowerCase();
                        bValue = b.children[1].textContent.toLowerCase();
                        break;
                    case 'requests':
                        aValue = parseInt(a.children[2].textContent.replace(/,/g, '')) || 0;
                        bValue = parseInt(b.children[2].textContent.replace(/,/g, '')) || 0;
                        break;
                    case 'spend':
                        aValue = parseFloat(a.children[3].textContent.replace('$', '')) || 0;
                        bValue = parseFloat(b.children[3].textContent.replace('$', '')) || 0;
                        break;
                    case 'role':
                        aValue = a.children[4].textContent.toLowerCase();
                        bValue = b.children[4].textContent.toLowerCase();
                        break;
                    default:
                        return 0;
                }
               
                if (currentSortDirection === 'asc') {
                    return aValue > bValue ? 1 : -1;
                } else {
                    return aValue < bValue ? 1 : -1;
                }
            });
           
            // 정렬된 행들을 다시 추가
            rows.forEach(row => dataTable.appendChild(row));
           
            // 헤더 업데이트
            updateSortHeaders(field);
        }

        // 정렬 헤더 업데이트
        function updateSortHeaders(field) {
            const headers = document.querySelectorAll('#members .table-header > div');
            headers.forEach((header, index) => {
                if (index < 5) { // 마지막 빈 열 제외
                    const text = header.textContent.replace(/[↑↓]/, '');
                    if (index === 0 && field === 'name') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 1 && field === 'email') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 2 && field === 'requests') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 3 && field === 'spend') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else if (index === 4 && field === 'role') header.textContent = text + (currentSortDirection === 'asc' ? ' ↑' : ' ↓');
                    else header.textContent = text + ' ↕';
                }
            });
        }

        // 검색창 외부 클릭 시 자동완성 드롭다운 숨기기
        document.addEventListener('click', function(e) {
            const autocompleteDropdowns = document.querySelectorAll('.autocomplete-dropdown');
            const searchContainers = document.querySelectorAll('.search-container');
            
            let clickedInsideSearch = false;
            searchContainers.forEach(container => {
                if (container.contains(e.target)) {
                    clickedInsideSearch = true;
                }
            });
            
            if (!clickedInsideSearch) {
                autocompleteDropdowns.forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });

        // 유틸리티 가드: PerformanceMonitor / updatePerformanceIndicator / SkeletonUI가 없으면 안전한 기본 구현 제공
        (function(){
            try {
                if (typeof window.PerformanceMonitor === 'undefined') {
                    window.PerformanceMonitor = {
                        _marks: new Map(),
                        start(label) {
                            try { this._marks.set(label, (window.performance && performance.now) ? performance.now() : Date.now()); } catch (_) {}
                        },
                        end(label) {
                            try {
                                const start = this._marks.get(label);
                                const now = (window.performance && performance.now) ? performance.now() : Date.now();
                                const delta = (start != null) ? Math.round(now - start) : 0;
                                this._marks.delete(label);
                                return delta;
                            } catch (_) { return 0; }
                        }
                    };
                }
                if (typeof window.updatePerformanceIndicator === 'undefined') {
                    window.updatePerformanceIndicator = function(){ /* no-op */ };
                }
                if (typeof window.SkeletonUI === 'undefined') {
                    window.SkeletonUI = { show: function(){}, hide: function(){} };
                }
                if (typeof window.DataCache === 'undefined') {
                    window.DataCache = {
                        members: null,
                        events: null,
                        _ts: {},
                        set(key, value) { this[key] = value; this._ts[key] = Date.now(); },
                        get(key) { return this[key]; },
                        isValid(key, ttlMs = 5 * 60 * 1000) { // 기본 TTL 5분
                            const ts = this._ts[key];
                            return !!ts && (Date.now() - ts) < ttlMs && !!this[key];
                        },
                        clear() { this.members = null; this.events = null; this._ts = {}; }
                    };
                }
            } catch (_) { /* ignore guard setup errors */ }
        })();

        // 최적화된 페이지 초기화 (Progressive Loading)
        document.addEventListener('DOMContentLoaded', async function() {
            PerformanceMonitor.start('페이지 전체 로드');
            console.log('🚀 최적화된 대시보드 초기화 시작');
           
            try {
                // 1단계: 즉시 스켈레톤 UI 표시 (0ms)
                SkeletonUI.show('overview');
                updatePerformanceIndicator('loading', 'UI 초기화');
                console.log('💀 스켈레톤 UI 표시 완료');
               
                // 2단계: 기본 UI 초기화 (즉시)
                initOverviewStats();
               
                // Overview 필터 기본값을 30일로 설정
                document.querySelectorAll('#overview .chart-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.querySelector('#overview .chart-btn[data-days="30"]').classList.add('active');
                
                // 초기 필터 기간 표시 설정 (30일)
                const initialDateRange = getDateRange(30);
                updateFilterPeriodDisplay(initialDateRange.startDate, initialDateRange.endDate);
               
                createOverviewChart(); // 빈 차트 먼저 표시
                window.overviewChartInitialized = true; // 차트 초기화 플래그 설정
                
                // 기본 차트 탭 활성화 (일별 활동 추이)
                switchChart('activity-trend');
               
                // 3단계: 백그라운드에서 데이터 로드 시작 (비동기)
                console.log('📡 백그라운드 데이터 로드 시작...');
               
                // 캐시 확인 및 즉시 사용 가능한 데이터가 있다면 먼저 표시
                if (DataCache.isValid('members') && DataCache.members) {
                    console.log('🚀 캐시된 멤버 데이터로 즉시 기본 UI 업데이트');
                    updatePerformanceIndicator('cached', '캐시 사용');
                    const totalMembers = DataCache.members.teamMembers?.length || 0;
                    updateStatsCards(totalMembers, 0, 0); // 기본값으로 먼저 표시
                } else {
                    updatePerformanceIndicator('loading', 'API 호출');
                }
               
                // 4단계: 실제 API 데이터 로드 및 업데이트
                await refreshAllRealData();
               
                // 초기 로드 완료 후 기본 선택 상태 설정 (전체 멤버)
                console.log('초기 로드 완료 후 전체 멤버 기본 선택');
                document.querySelectorAll('.overview-stat-box').forEach(box => {
                    box.classList.remove('selected');
                });
                document.querySelector('.overview-stat-box[data-type="total"]').classList.add('selected');
                currentFilterType = 'total';
                
                // 날짜 입력 필드 변경 시 자동 새로고침 이벤트 리스너 추가
                setupAutoRefreshEvents();
                
                // 날짜 입력 필드 실시간 업데이트 이벤트 리스너 추가
                setupDateInputEvents();
                
                // Overview 섹션을 최초 방문한 것으로 표시
                sectionVisited.overview = true;
               
                const totalLoadTime = PerformanceMonitor.end('페이지 전체 로드');
                updatePerformanceIndicator('ready', `${totalLoadTime}ms`);
                console.log('✅ 최적화된 대시보드 초기화 완료!');
                
                // 예약 메일 발송 스케줄러 초기화
                console.log('📅 [INIT] 예약 메일 발송 스케줄러 초기화 시작');
                try {
                    // Settings 토글 상태 확인
                    console.log(`📅 [INIT] emailSchedulerActive 초기 상태: ${emailSchedulerActive}`);
                    
                    // 예약 리스트 확인
                    if (window.emailScheduleList && window.emailScheduleList.length > 0) {
                        console.log(`📅 [INIT] 저장된 예약 발견: ${window.emailScheduleList.length}개`);
                        
                        // 활성 예약 확인
                        const activeSchedules = window.emailScheduleList.filter(s => s.status === '활성');
                        console.log(`📅 [INIT] 활성 예약: ${activeSchedules.length}개`);
                        
                        if (activeSchedules.length > 0) {
                            console.log('📅 [INIT] 활성 예약이 있으므로 스케줄러를 자동 시작합니다.');
                            
                            // 스케줄러 활성화 (토글 상태와 무관하게)
                            emailSchedulerActive = true;
                            console.log('📅 [INIT] emailSchedulerActive를 true로 설정');
                            
                            // 스케줄러 시작
                            startEmailScheduler();
                            console.log('📅 [INIT] 스케줄러 시작 완료');
                        } else {
                            console.log('📅 [INIT] 활성 예약이 없어 스케줄러를 시작하지 않습니다.');
                        }
                    } else {
                        console.log('📅 [INIT] 저장된 예약이 없어 스케줄러를 시작하지 않습니다.');
                    }
                } catch (error) {
                    console.error('❌ [INIT] 스케줄러 초기화 실패:', error);
                }
               
            } catch (error) {
                PerformanceMonitor.end('페이지 전체 로드');
                updatePerformanceIndicator('error', error.message.substring(0, 20));
                console.error('❌ 대시보드 초기화 실패:', error);
               
                // 에러 발생 시에도 기본 UI는 표시
                const errorMessage = `
                    <div style="text-align: center; padding: 50px; color: #ff6b6b;">
                        <h3>⚠️ 데이터 로드 실패</h3>
                        <p>${error.message}</p>
                        <button onclick="location.reload()" style="margin-top: 20px; padding: 10px 20px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            새로고침
                        </button>
                    </div>
                `;
               
                const overviewSection = document.getElementById('overview');
                if (overviewSection) {
                    overviewSection.innerHTML = errorMessage;
                }
            }
        });

        // 캐시 새로고침 함수 (버튼용)
        function forceCacheRefresh() {
            console.log('🗑️ 캐시 강제 새로고침 시작');
            DataCache.clear();
            location.reload();
        }

        // Refresh 실행 상태 관리 (중복 실행 방지)
        let isRefreshInProgress = false;

        // 진행바 제어 함수들
        function showRefreshProgress() {
            const progressContainer = document.querySelector('.refresh-progress');
            const progressBar = document.querySelector('.refresh-progress-bar');
            if (progressContainer && progressBar) {
                progressContainer.style.display = 'block';
                progressBar.style.width = '0%';
            }
        }

        function updateRefreshProgress(percentage) {
            const progressBar = document.querySelector('.refresh-progress-bar');
            if (progressBar) {
                progressBar.style.width = percentage + '%';
            }
        }

        function hideRefreshProgress() {
            const progressContainer = document.querySelector('.refresh-progress');
            if (progressContainer) {
                progressContainer.style.display = 'none';
            }
        }

        // Refresh 메뉴 클릭 핸들러 (완전 백그라운드 동작)
        async function handleRefreshClick() {
            // 이미 refresh가 진행 중이면 무시
            if (isRefreshInProgress) {
                console.log('🔄 Refresh 이미 진행 중 - 요청 무시');
                return;
            }

            // 진행바 표시
            showRefreshProgress();
            
            // Refresh 시작 (사용자에게는 아무 변화 없음)
            isRefreshInProgress = true;
            
            try {
                console.log('🔄 Refresh 시작 - 백그라운드 데이터 갱신 (사용자 화면 변화 없음)');
                
                // 현재 활성화된 섹션 확인
                const activeSection = document.querySelector('.content-section.active');
                const activeSectionId = activeSection ? activeSection.id : 'overview';
                
                console.log(`현재 활성 섹션: ${activeSectionId}`);
                
                // 백그라운드에서 모든 데이터 새로고침 (병렬 처리)
                console.log('📡 백그라운드 API 데이터 로드 시작...');
                
                // 진행바 단계별 업데이트
                updateRefreshProgress(20);
                await refreshOverviewData();
                updateRefreshProgress(50);
                await refreshMembersData();
                updateRefreshProgress(80);
                await refreshUsageData();
                updateRefreshProgress(90);
                
                // 현재 섹션이 활성화되어 있다면 화면 업데이트
                await updateCurrentSectionDisplay(activeSectionId);
                updateRefreshProgress(100);
                
                console.log('✅ Refresh 완료 - 모든 데이터가 백그라운드에서 갱신됨');
                
            } catch (error) {
                console.error('❌ Refresh 실패:', error);
                // 에러 발생 시에도 사용자 화면에는 변화 없음 (콘솔에만 로그)
            } finally {
                // 진행바 숨기기
                setTimeout(() => {
                    hideRefreshProgress();
                }, 500);
                
                // Refresh 완료 상태로 변경
                isRefreshInProgress = false;
            }
        }

        // Overview 데이터 백그라운드 새로고침
        async function refreshOverviewData() {
            try {
                console.log('📊 Overview 데이터 백그라운드 갱신 중...');
                await updateOverviewWithRealData();
                console.log('✅ Overview 데이터 갱신 완료');
            } catch (error) {
                console.error('❌ Overview 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // Members 데이터 백그라운드 새로고침
        async function refreshMembersData() {
            try {
                console.log('👥 Members 데이터 백그라운드 갱신 중...');
                await updateMembersWithRealData();
                console.log('✅ Members 데이터 갱신 완료');
            } catch (error) {
                console.error('❌ Members 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // Usage 데이터 백그라운드 새로고침 (화면 변화 없이 캐시만 갱신)
        async function refreshUsageData() {
            try {
                console.log('📈 Usage 데이터 백그라운드 갱신 중 (화면 변화 없음)...');
                
                // 날짜 범위 계산
                const dateRange = getDateRange(30);
                
                // API 데이터만 가져와서 캐시에 저장 (화면 업데이트 없음)
                const [membersData, eventsData, usageData, spendingData] = await Promise.all([
                    getTeamMembers(),
                    getFilteredEvents(dateRange.startDate, dateRange.endDate),
                    getUsageData(dateRange.startDate, dateRange.endDate),
                    getTeamSpendingData()
                ]);
                
                // 캐시에만 저장하고 화면은 업데이트하지 않음
                console.log('💾 Usage 데이터를 캐시에 저장 (화면 업데이트 안함)');
                
                // 전역 변수에 데이터 저장 (화면 업데이트 함수들 호출하지 않음)
                // 이렇게 하면 데이터는 최신으로 유지되지만 화면은 변경되지 않음
                
                console.log('✅ Usage 데이터 백그라운드 갱신 완료 (캐시만 업데이트)');
            } catch (error) {
                console.error('❌ Usage 데이터 갱신 실패:', error);
                throw error;
            }
        }

        // 현재 섹션 화면 업데이트 (백그라운드 갱신 후)
        async function updateCurrentSectionDisplay(activeSectionId) {
            try {
                console.log(`🖥️ 현재 섹션 화면 업데이트: ${activeSectionId}`);
                switch(activeSectionId) {
                    case 'overview':
                        await updateOverviewWithCurrentFilter();
                        break;
                    case 'members':
                        // Members는 이미 refreshMembersData()에서 갱신됨
                        // 추가 화면 업데이트 없음
                        break;
                    case 'usage':
                        // Usage는 백그라운드에서만 데이터 갱신됨
                        // 화면 업데이트 하지 않음 (사용자가 보고 있는 화면 유지)
                        console.log('Usage 섹션: 화면 업데이트 안함 (백그라운드 갱신만)');
                        break;
                    case 'settings':
                        // Settings는 별도 API 데이터가 없음
                        break;
                }
                console.log(`✅ ${activeSectionId} 섹션 화면 업데이트 완료`);
            } catch (error) {
                console.error(`❌ ${activeSectionId} 섹션 화면 업데이트 실패:`, error);
            }
        }

        // 자동 새로고침 이벤트 설정
        function setupAutoRefreshEvents() {
            console.log('자동 새로고침 이벤트 리스너 설정 중...');
            
            // Overview 날짜 입력 필드
            const overviewStartDate = document.getElementById('start-date');
            const overviewEndDate = document.getElementById('end-date');
            
            if (overviewStartDate && overviewEndDate) {
                overviewStartDate.addEventListener('change', debounce(async () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        console.log('Overview 시작 날짜 변경됨 - 자동 새로고침');
                        await applyDateFilter();
                    }
                }, 500));
                
                overviewEndDate.addEventListener('change', debounce(async () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        console.log('Overview 종료 날짜 변경됨 - 자동 새로고침');
                        await applyDateFilter();
                    }
                }, 500));
            }
            
            // Usage 날짜 입력 필드
            const usageStartDate = document.getElementById('usage-start-date');
            const usageEndDate = document.getElementById('usage-end-date');
            
            if (usageStartDate && usageEndDate) {
                usageStartDate.addEventListener('change', debounce(async () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        console.log('Usage 시작 날짜 변경됨 - 자동 새로고침');
                        await applyUsageDateFilter();
                    }
                }, 500));
                
                usageEndDate.addEventListener('change', debounce(async () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        console.log('Usage 종료 날짜 변경됨 - 자동 새로고침');
                        await applyUsageDateFilter();
                    }
                }, 500));
            }
            
            console.log('자동 새로고침 이벤트 리스너 설정 완료');
        }

        // 날짜 입력 필드 실시간 업데이트 이벤트 설정
        function setupDateInputEvents() {
            console.log('날짜 입력 필드 실시간 업데이트 이벤트 리스너 설정 중...');
            
            // Overview 날짜 입력 필드 실시간 업데이트
            const overviewStartDate = document.getElementById('start-date');
            const overviewEndDate = document.getElementById('end-date');
            
            if (overviewStartDate && overviewEndDate) {
                // 시작 날짜 변경 시 즉시 범위 표시 업데이트
                overviewStartDate.addEventListener('input', () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        const startDate = new Date(overviewStartDate.value).getTime();
                        const endDate = new Date(overviewEndDate.value).getTime() + (24 * 60 * 60 * 1000 - 1);
                        updateFilterPeriodDisplay(startDate, endDate);
                    }
                });
                
                // 종료 날짜 변경 시 즉시 범위 표시 업데이트
                overviewEndDate.addEventListener('input', () => {
                    if (overviewStartDate.value && overviewEndDate.value) {
                        const startDate = new Date(overviewStartDate.value).getTime();
                        const endDate = new Date(overviewEndDate.value).getTime() + (24 * 60 * 60 * 1000 - 1);
                        updateFilterPeriodDisplay(startDate, endDate);
                    }
                });
            }
            
            // Usage 날짜 입력 필드 실시간 업데이트
            const usageStartDate = document.getElementById('usage-start-date');
            const usageEndDate = document.getElementById('usage-end-date');
            
            if (usageStartDate && usageEndDate) {
                // 시작 날짜 변경 시 즉시 범위 표시 업데이트
                usageStartDate.addEventListener('input', () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        const startDate = new Date(usageStartDate.value).getTime();
                        const endDate = new Date(usageEndDate.value).getTime() + (24 * 60 * 60 * 1000 - 1);
                        updateUsageFilterPeriodDisplay(startDate, endDate);
                    }
                });
                
                // 종료 날짜 변경 시 즉시 범위 표시 업데이트
                usageEndDate.addEventListener('input', () => {
                    if (usageStartDate.value && usageEndDate.value) {
                        const startDate = new Date(usageStartDate.value).getTime();
                        const endDate = new Date(usageEndDate.value).getTime() + (24 * 60 * 60 * 1000 - 1);
                        updateUsageFilterPeriodDisplay(startDate, endDate);
                    }
                });
            }
            
            console.log('날짜 입력 필드 실시간 업데이트 이벤트 리스너 설정 완료');
        }

        // 디바운스 함수 (연속 호출 방지)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }



        // Email Report 설정 - 직접 입력 체크박스 토글 함수
        function toggleCustomEmailInput(checkbox) {
            const customEmailInput = document.getElementById('custom-email-input');
            if (checkbox.checked) {
                customEmailInput.style.display = 'block';
                console.log('직접 입력 이메일 영역이 표시되었습니다.');
            } else {
                customEmailInput.style.display = 'none';
                console.log('직접 입력 이메일 영역이 숨겨졌습니다.');
            }
            updateRecipientCount();
        }

        // 수신자 수 계산 및 업데이트 함수
        function updateRecipientCount() {
            let totalCount = 0;
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('custom-email-checkbox');
            const customEmails = document.getElementById('custom-emails');
            
            // 관리자 수 계산
            if (adminCheckbox && adminCheckbox.checked) {
                const adminCount = originalMembersData ? originalMembersData.filter(member => member.role === 'owner').length : 0;
                totalCount += adminCount;
            }
            
            // 전체 멤버 수 계산
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                const allMembersCount = originalMembersData ? originalMembersData.length : 0;
                totalCount += allMembersCount;
            }
            
            // 비활성 멤버 수 계산
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                const inactiveCount = originalMembersData ? originalMembersData.filter(member => member.spendData.premiumRequests === 0).length : 0;
                totalCount += inactiveCount;
            }
            
            // 직접 입력 이메일 수 계산
            if (customEmailCheckbox && customEmailCheckbox.checked && customEmails && customEmails.value.trim()) {
                const emailList = customEmails.value.split(',').filter(email => email.trim().length > 0);
                totalCount += emailList.length;
            }
            
            // 수신자 수 표시 업데이트
            const recipientCountElement = document.getElementById('recipient-count');
            if (recipientCountElement) {
                recipientCountElement.textContent = totalCount;
            }
            
            console.log(`수신자 수 업데이트: ${totalCount}명`);
        }

        // Email Report 설정 - 메시지 글자 수 카운터 함수
        function updateMessageCharCount() {
            const messageInput = document.getElementById('email-report-message');
            const charCount = document.getElementById('report-message-char-count');
            
            if (messageInput && charCount) {
                const maxLength = 1000;
                const currentLength = messageInput.value.length;
                
                // 글자 수 업데이트
                charCount.textContent = currentLength;
                
                // 글자 수 제한
                if (currentLength > maxLength) {
                    messageInput.value = messageInput.value.substring(0, maxLength);
                    charCount.textContent = maxLength;
                }
                
                // 글자 수에 따른 색상 변경
                if (currentLength >= maxLength * 0.9) {
                    charCount.style.color = '#ff9800'; // 경고 색상 (90% 이상)
                } else if (currentLength >= maxLength * 0.8) {
                    charCount.style.color = '#ff9800'; // 주의 색상 (80% 이상)
                } else {
                    charCount.style.color = '#7a7a7a'; // 기본 색상
                }
            }
        }

        // 메시지 입력란 동기화 함수
        function syncMessageInputs(sourceId) {
            const emailReportMessage = document.getElementById('email-report-message');
            const emailMessageInput = document.getElementById('email-message-input');
            
            if (sourceId === 'email-report-message' && emailReportMessage && emailMessageInput) {
                // Email Report 테이블의 입력란에서 수신자 보기 팝업의 입력란으로 동기화
                emailMessageInput.value = emailReportMessage.value;
                
                // 팝업의 글자 수 카운터도 업데이트
                const popupCharCount = document.getElementById('message-char-count');
                if (popupCharCount) {
                    popupCharCount.textContent = emailReportMessage.value.length;
                }
                
                console.log('메시지 동기화: Email Report → 수신자 보기 팝업');
            } else if (sourceId === 'email-message-input' && emailMessageInput && emailReportMessage) {
                // 수신자 보기 팝업의 입력란에서 Email Report 테이블의 입력란으로 동기화
                emailReportMessage.value = emailMessageInput.value;
                
                // Email Report의 글자 수 카운터도 업데이트
                updateMessageCharCount();
                
                console.log('메시지 동기화: 수신자 보기 팝업 → Email Report');
            }
        }

        // 예약 리스트 보기 함수
        function showEmailScheduleList() {
            // 기존 모달이 있으면 제거
            const existingModal = document.getElementById('email-schedule-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // 선택 상태 초기화 (이전 팝업에서 남은 선택으로 오작동 방지)
            window._selectedScheduleIds = new Set();

            // 예약 리스트 데이터 (저장된 예약만 표시)
            let scheduleList = [];
            
            // 수신자 문자열 정리 함수 (과거에 잘못 저장된 비수신자 토큰 제거)
            const sanitizeRecipients = (recipients) => {
                if (!recipients || typeof recipients !== 'string') return recipients || '';
                const validTokens = new Set(['관리자', '전체 멤버', '비활성 멤버', '직접입력', '직접 입력']);
                const cleaned = [];
                recipients.split(',').forEach(token => {
                    const t = token.trim();
                    if (validTokens.has(t) && !cleaned.includes(t)) {
                        cleaned.push(t);
                    }
                });
                return cleaned.join(', ');
            };

            // 저장된 예약 리스트가 있으면 추가 (기존 데이터 마이그레이션 포함)
            if (window.emailScheduleList && window.emailScheduleList.length > 0) {
                // 기존 데이터에 currentSend 필드가 없는 경우 추가 및 시간 갱신
                const migratedScheduleList = window.emailScheduleList.map(schedule => {
                    if (!schedule.currentSend) {
                        // currentSend가 없으면 nextSend를 currentSend로 복사하고 새로운 nextSend 계산
                        schedule.currentSend = schedule.nextSend;
                        const frequency = getFrequencyValue(schedule.frequency);
                        if (frequency) {
                            schedule.nextSend = calculateNextSendTimeFromCurrent(schedule.currentSend, frequency);
                        }
                        console.log(`📋 기존 예약 데이터 마이그레이션: ${schedule.title}`);
                    }
                    
                    // 시간 갱신: 이번 발송 시간이 과거인 경우 갱신
                    updateScheduleTimeIfNeeded(schedule);

                    // 수신자 문자열 정리: 비수신자 토큰(예: 사용량) 제거 및 중복 제거
                    if (schedule.recipients) {
                        const before = schedule.recipients;
                        schedule.recipients = sanitizeRecipients(schedule.recipients);
                        if (before !== schedule.recipients) {
                            console.log(`🧹 수신자 정리: '${before}' → '${schedule.recipients}'`);
                        }
                    }
                    
                    return schedule;
                });
                scheduleList = scheduleList.concat(migratedScheduleList);
            }

            // 모달 HTML 생성
            const modalHTML = `
                <div id="email-schedule-modal" style="
                    display: block;
                    position: fixed;
                    z-index: 1000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                ">
                    <div style="
                        background-color: #2a2a2a;
                        margin: 5% auto;
                        padding: 25px;
                        border-radius: 8px;
                        width: 90%;
                        max-width: 800px;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                        max-height: 85vh;
                        overflow-y: auto;
                        border: 1px solid #3a3a3a;
                    ">
                        <!-- 모달 헤더 -->
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 25px;
                            padding-bottom: 15px;
                            border-bottom: 1px solid #3a3a3a;
                        ">
                            <div style="color: #fff; font-size: 18px; font-weight: 600;">메일 발송 예약 리스트</div>
                            <button onclick="closeEmailScheduleModal()" style="
                                background: none;
                                border: none;
                                color: #7a7a7a;
                                font-size: 20px;
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 3px;
                                transition: color 0.2s ease;
                            " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#7a7a7a'">×</button>
                        </div>

                        <!-- 검색 및 필터 -->
                        <div style="margin-bottom: 20px;">
                            <div style="
                                position: relative;
                                display: flex;
                                align-items: center;
                                background-color: #1a1a1a;
                                border: 1px solid #3a3a3a;
                                border-radius: 4px;
                                padding: 0 12px;
                                transition: all 0.2s ease;
                                margin-bottom: 15px;
                            " onfocus="this.style.backgroundColor='#2a2a2a'; this.style.borderColor='#4a9eff'" onblur="this.style.backgroundColor='#1a1a1a'; this.style.borderColor='#3a3a3a'">
                                <span style="
                                    color: #7a7a7a;
                                    margin-right: 8px;
                                    font-size: 14px;
                                ">🔍</span>
                                <input 
                                    type="text" 
                                    id="schedule-search" 
                                    placeholder="예약 리스트 검색..."
                                    style="
                                        flex: 1;
                                        padding: 10px 0;
                                        border: none;
                                        background: transparent;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        outline: none;
                                    "
                                >
                            </div>
                            
                            <!-- 필터 버튼 -->
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <button class="analytics-btn" onclick="deleteAllSchedules()">전체 삭제</button>
                                <button class="chart-btn active" data-filter="all" onclick="filterScheduleList('all')">전체</button>
                                <button class="chart-btn" data-filter="active" onclick="filterScheduleList('active')">활성</button>
                                <button class="chart-btn" data-filter="inactive" onclick="filterScheduleList('inactive')">비활성</button>
                            </div>
                        </div>

                        <!-- 예약 리스트 테이블 -->
                        <div style="
                            background-color: #1a1a1a;
                            border-radius: 4px;
                            overflow: hidden;
                            margin-bottom: 20px;
                        ">
                            <!-- 테이블 헤더 -->
                            <div style="
                                display: grid;
                                grid-template-columns: 0.6fr 2fr 1fr 1.2fr 1.2fr 1.5fr 0.8fr 0.8fr 0.8fr;
                                gap: 15px;
                                padding: 15px;
                                border-bottom: 1px solid #3a3a3a;
                                font-weight: 600;
                                color: #fff;
                                font-size: 14px;
                            ">
                                <div style="text-align:center;">
                                    <input type="checkbox" id="select-all-schedules" style="width: 16px; height: 16px; accent-color: #4a9eff;">
                                </div>
                                <div>제목</div>
                                <div>주기</div>
                                <div>이번 발송</div>
                                <div>다음 발송</div>
                                <div>수신자</div>
                                <div>활성</div>
                                <div>비활성</div>
                                <div>삭제</div>
                            </div>

                            <!-- 테이블 내용 -->
                            <div id="schedule-list-content">
                                ${scheduleList.map(item => `
                                    <div class="schedule-item" data-id="${item.id}" data-status="${item.status}" style="
                                        display: grid;
                                        grid-template-columns: 0.6fr 2fr 1fr 1.2fr 1.2fr 1.5fr 0.8fr 0.8fr 0.8fr;
                                        gap: 15px;
                                        padding: 15px;
                                        border-bottom: 1px solid #3a3a3a;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        transition: background-color 0.2s ease;
                                    " onmouseover="this.style.backgroundColor='#3a3a3a'" onmouseout="this.style.backgroundColor='transparent'">
                                        <!-- 선택 체크박스 -->
                                        <div style="text-align: center;">
                                            <input type="checkbox" class="schedule-select-checkbox" data-id="${item.id}" onchange="handleSelectSchedule(${item.id}, this.checked)" style="
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                        </div>
                                        <!-- 제목 (요약 표시) -->
                                        <div>
                                            <div class="editable-field" data-field="title" style="font-weight: 600; color: #fff; margin-bottom: 5px;">${item.title}</div>
                                            <div style="color: #7a7a7a; font-size: 12px; display:-webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${(() => { const limit = (window.PREVIEW_MESSAGE_MAX || 80); const m=(item.message||'').toString().replace(/\s+/g,' ').trim(); return m.length>limit? m.slice(0,limit)+'…': m; })()}</div>
                                        </div>
                                        <!-- 주기 -->
                                        <div>
                                            <div class="editable-field" data-field="frequency">${item.frequency}</div>
                                        </div>
                                        <!-- 이번 발송 -->
                                        <div>
                                            <div class="editable-field" data-field="currentSend" style="color: #ff9800; font-weight: 600;">${item.currentSend || item.nextSend}</div>
                                        </div>
                                        <!-- 다음 발송 (자동 계산) -->
                                        <div class="next-send-time" style="color: #7a7a7a;">${item.nextSend}</div>
                                        <!-- 수신자 -->
                                        <div>
                                            <div class="editable-field" data-field="recipients">${item.recipients}</div>
                                        </div>
                                        <div style="text-align: center;">
                                            <input type="radio" name="status-${item.id}" value="active" ${item.status === '활성' ? 'checked' : ''} 
                                                   onchange="updateScheduleStatus(${item.id}, '활성')" style="
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                        </div>
                                        <div style="text-align: center;">
                                            <input type="radio" name="status-${item.id}" value="inactive" ${item.status === '비활성' ? 'checked' : ''} 
                                                   onchange="updateScheduleStatus(${item.id}, '비활성')" style="
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                        </div>
                                        <div style="text-align: center;">
                                            <button onclick="deleteSchedule(${item.id})" style="
                                                background: none;
                                                border: none;
                                                color: #ff4757;
                                                cursor: pointer;
                                                padding: 4px;
                                                font-size: 16px;
                                                font-weight: bold;
                                            ">×</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>

                        <!-- 하단 버튼 -->
                        <div style="display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #3a3a3a; padding-top: 20px;">
                            <div style="color: #7a7a7a; font-size: 14px;">
                                총 ${scheduleList.length}개의 예약 리스트
                            </div>
                            <div style="display: flex; gap: 10px;">
                                <button class="chart-btn" onclick="showSelectedSchedulePreview()">미리보기</button>
                                <button class="chart-btn" onclick="editSelectedSchedule()">수정</button>
                                <button class="chart-btn" onclick="saveScheduleChanges()">저장</button>
                                <button class="chart-btn" onclick="closeEmailScheduleModal()">닫기</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // 모달을 페이지에 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // 검색 기능 추가
            setTimeout(() => {
                const searchInput = document.getElementById('schedule-search');
                const selectAll = document.getElementById('select-all-schedules');
                if (searchInput) {
                    searchInput.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const scheduleItems = document.querySelectorAll('#email-schedule-modal .schedule-item');
                        
                        scheduleItems.forEach(item => {
                            const text = item.textContent.toLowerCase();
                            if (text.includes(searchTerm)) {
                                item.style.display = 'grid';
                            } else {
                                item.style.display = 'none';
                            }
                        });
                    });
                }
                if (selectAll) {
                    selectAll.addEventListener('change', function() {
                        const checked = this.checked;
                        const checkboxes = document.querySelectorAll('#email-schedule-modal .schedule-select-checkbox');
                        checkboxes.forEach(cb => {
                            cb.checked = checked;
                            const id = parseInt(cb.getAttribute('data-id'));
                            handleSelectSchedule(id, checked);
                        });
                    });
                }
            }, 100);
        }

        // 예약 리스트 선택 상태 관리
        window._selectedScheduleIds = new Set();
        function handleSelectSchedule(id, isSelected) {
            if (!window._selectedScheduleIds) window._selectedScheduleIds = new Set();
            if (isSelected) window._selectedScheduleIds.add(id);
            else window._selectedScheduleIds.delete(id);
            // 단일 선택 보장 옵션: 하나만 선택되어야 하는 액션 대비 안전장치
            // 체크한 직후에도 DOM에서 다시 확인 가능
        }

        // 선택된 예약 미리보기 (첨부 파일 포함)
        async function showSelectedSchedulePreview() {
            const ids = Array.from(window._selectedScheduleIds || []);
            if (!ids.length) {
                showSimpleAlert('⚠️ 미리보기할 예약을 선택하세요.', 'warning');
                return;
            }
            const schedules = (window.emailScheduleList || []).filter(s => ids.includes(s.id));
            if (!schedules.length) {
                showSimpleAlert('⚠️ 선택된 예약을 찾을 수 없습니다.', 'warning');
                return;
            }

            // 첨부 파일 현재 설정 요약
            // 첨부 설정: 저장된 예약의 스냅샷 우선, 없으면 현재 UI 값 사용
            const saved = schedules[0] || {};
            const attAll = (typeof saved.attachAllMembers === 'boolean') ? saved.attachAllMembers : !!document.getElementById('attachment-all-members')?.checked;
            const attInactive = (typeof saved.attachInactiveMembers === 'boolean') ? saved.attachInactiveMembers : !!document.getElementById('attachment-inactive-members')?.checked;
            const attCustom = (typeof saved.attachCustom === 'boolean') ? saved.attachCustom : !!document.getElementById('attachment-custom')?.checked;
            const attAllUsage = (typeof saved.attachAllUsage === 'boolean')
                ? saved.attachAllUsage
                : !!document.getElementById('attachment-all-usage')?.checked;
            const attInactiveUsage = (typeof saved.attachInactiveUsage === 'boolean')
                ? saved.attachInactiveUsage
                : !!document.getElementById('attachment-inactive-usage')?.checked;
            const attCustomUsage = (typeof saved.attachCustomUsage === 'boolean')
                ? saved.attachCustomUsage
                : !!document.getElementById('attachment-custom-usage')?.checked;
            const usagePeriodText = (() => {
                const savedText = (saved.usagePeriodText && saved.usagePeriodText.trim()) || '';
                const fromAttachment = (document.getElementById('usage-attachment-period-text')?.textContent || '').trim();
                const fromUsage = (document.getElementById('usage-filter-period-text')?.textContent || '').trim();
                const fromOverview = (document.getElementById('filter-period-text')?.textContent || '').trim();
                const isUnset = (t) => !t || t === '기간을 선택하세요';
                if (!isUnset(savedText)) return savedText;
                if (!isUnset(fromAttachment)) return fromAttachment;
                if (!isUnset(fromUsage)) return fromUsage;
                return fromOverview;
            })();
            const customAttachmentEmails = (document.getElementById('attachment-custom-emails')?.value || '').trim();

            // 1) 즉시 표시용 미리보기 모달 쉘을 먼저 렌더링 (로딩 상태)
            (function renderPreviewShell(){
                try {
                    if (document.getElementById('schedule-preview-modal')) return;
                    const schedule = schedules[0] || {};
                    const chipsHTML = (() => {
                        const r=(schedule?.recipients||'');
                        const map={ '관리자':'admin','전체 멤버':'all','비활성 멤버':'inactive','직접입력':'custom'};
                        const chips=['관리자','전체 멤버','비활성 멤버','직접입력']
                            .filter(x=>r.includes(x))
                            .map(x=>`<span class=\"recipient-chip\" data-group=\"${map[x]}\" style=\"background:#2a2a2a; border:1px solid #ff9800; color:#ff9800; padding:4px 8px; border-radius:999px; font-size:12px; cursor:pointer;\">${x}</span>`)
                            .join(' ');
                        return chips || '<span style=\"color:#7a7a7a;\">선택된 그룹 없음</span>';
                    })();
                    const shell = `
                        <div id=\"schedule-preview-modal\" style=\"position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1100;\">
                            <div style=\"position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:90%; max-width:900px; max-height:85vh; overflow:auto; background:#2a2a2a; border:1px solid #3a3a3a; border-radius:8px; padding:20px;\">
                                <div style=\"display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #3a3a3a; padding-bottom:12px; margin-bottom:16px;\">
                                    <div style=\"color:#fff; font-size:18px; font-weight:600;\">예약 미리보기</div>
                                    <button class=\"chart-btn\" onclick=\"document.getElementById('schedule-preview-modal').remove()\">닫기</button>
                                </div>
                                <div style=\"background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px;\">
                                    <div style=\"font-size:14px; margin-top:12px;\">
                                        <div style=\"color:#fff; font-weight:600; margin-bottom:6px;\">발송 메시지</div>
                                        <div id=\"preview-message-content\" style=\"background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#ff9800; white-space:pre-wrap;\">로딩 중...</div>
                                    </div>
                                    <div style=\"margin-top:12px;\">
                                        <div style=\"color:#fff; font-weight:600; margin-bottom:8px;\">수신자 그룹</div>
                                        <div id=\"recipient-chips\" style=\"display:flex; gap:8px; flex-wrap:wrap;\">${chipsHTML}</div>
                                    </div>
                                </div>
                                <div style=\"color:#e1e1e1; font-size:14px; margin:16px 0;\">
                                    <div style=\"color:#fff; font-size:16px; font-weight:600; margin-bottom:8px;\">첨부 파일 요약</div>
                                    <div id=\"attachments-summary-content\" style=\"background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#7a7a7a;\">로딩 중...</div>
                                </div>
                                <div style=\"margin-top:16px; background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px;\">
                                    <div style=\"display:flex; justify-content:space-between; align-items:center; color:#fff; font-size:16px; font-weight:600; border-bottom:1px solid #3a3a3a; padding:12px;\">
                                        <div>첨부 파일 내용</div>
                                        <div style=\"display:flex; gap:8px;\">
                                            <button id=\"attachments-csv-download\" class=\"analytics-btn\" disabled>CSV 다운로드</button>
                                        </div>
                                    </div>
                                    <div style=\"padding:12px;\">
                                        <pre id=\"attachments-csv-content\" style=\"white-space:pre; overflow:auto; max-height:50vh; background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#7a7a7a;\">생성 중...</pre>
                                    </div>
                                </div>
                                <div style=\"display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:16px; border-top:1px solid #3a3a3a; padding-top:16px;\">
                                    <div>
                                        <button id=\"schedule-preview-send-now-btn\" class=\"analytics-btn\" disabled>📧 즉시 발송</button>
                                    </div>
                                    <div style=\"display:flex; gap:10px;\">
                                        <button id=\"schedule-preview-edit-btn\" class=\"chart-btn\" disabled>수정</button>
                                        <button class=\"chart-btn\" onclick=\"document.getElementById('schedule-preview-modal').remove()\">닫기</button>
                                    </div>
                                </div>
                            </div>
                        </div>`;
                    document.body.insertAdjacentHTML('beforeend', shell);
                } catch (e) {}
            })();

            // 표본 데이터 생성: 비활성 멤버 상위 N명, 전체 멤버 상위 N명, 직접입력 N개, 사용량 기간 요약
            const SAMPLE_COUNT = 10;
            let inactiveSamples = [];
            let allMemberSamples = [];
            let customSamples = [];

            try {
                if ((attInactive || attAll) && typeof getTeamMembers === 'function') {
                    const membersData = await getTeamMembers();
                    const members = membersData && membersData.teamMembers ? membersData.teamMembers : [];
                    if (attInactive) {
                        const inactives = members.filter(m => (m.spendData && m.spendData.premiumRequests === 0));
                        inactiveSamples = inactives.slice(0, SAMPLE_COUNT).map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`);
                    }
                    if (attAll) {
                        allMemberSamples = members.slice(0, SAMPLE_COUNT).map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`);
                    }
                }
            } catch (e) {
                console.warn('첨부 표본 데이터 수집 중 오류:', e);
            }

            if (attCustom) {
                const list = (customAttachmentEmails || '')
                    .split(',')
                    .map(s => s.trim())
                    .filter(Boolean);
                customSamples = list.slice(0, SAMPLE_COUNT);
            }

            let attachmentSummaryHTML = "";

            // 상세 첨부 요약을 위한 전체 목록 및 카운트 계산
            const allMemberFullList = [];
            const inactiveFullList = [];
            const customFullList = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);

            const allMemberCount = 0;
            const inactiveCount = 0;
            const customCount = attCustom ? customFullList.length : 0;

            const sampleBlock = (items) => {
                const take = items.slice(0, Math.max(3, Math.min(10, items.length)));
                if (!take.length) return '<div style="color:#7a7a7a;">표시할 항목이 없습니다.</div>';
                return `<pre style=\"white-space:pre-wrap; background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:10px; color:#e1e1e1; max-height:120px; overflow:auto;\">${take.join('\n')}${items.length>take.length?'\n…':''}</pre>`;
            };

            const attachmentRows = [];
            attachmentRows.push(`<div>• 전체 멤버 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attAll ? '포함' : '미포함'}${attAllUsage ? ' (사용량 포함)' : ''}</span>${attAll ? ` <span style=\"color:#b1b1b1;\">(총 ${allMemberCount}명)</span>` : ''} ${attAll ? `<button id=\"view-all-all-members\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
            if (attAll) attachmentRows.push(`<div style=\"margin-top:6px;\">${'<div style="color:#7a7a7a;">목록은 멤버 로딩 후 표시됩니다.</div>'}</div>`);
            attachmentRows.push(`<div style=\"margin-top:10px;\">• 비활성 멤버 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attInactive ? '포함' : '미포함'}${attInactiveUsage ? ' (사용량 포함)' : ''}</span>${attInactive ? ` <span style=\"color:#b1b1b1;\">(총 ${inactiveCount}명)</span>` : ''} ${attInactive ? `<button id=\"view-all-inactive-members\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
            if (attInactive) attachmentRows.push(`<div style=\"margin-top:6px;\">${'<div style="color:#7a7a7a;">목록은 멤버 로딩 후 표시됩니다.</div>'}</div>`);
            attachmentRows.push(`<div style=\"margin-top:10px;\">• 직접 입력 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attCustom ? '포함' : '미포함'}${attCustomUsage ? ' (사용량 포함)' : ''}</span>${attCustom ? ` <span style=\"color:#b1b1b1;\">(총 ${customCount}명)</span>` : ''} ${attCustom ? `<button id=\"view-all-custom\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
            if (attCustom) attachmentRows.push(`<div style=\"margin-top:6px;\">${sampleBlock(customFullList)}</div>`);

            attachmentSummaryHTML = attachmentRows.join('');

            // CSV 생성 준비
            const delimiter = ',';
            const newline = '\n';
            const quote = (val) => {
                const s = (val ?? '').toString();
                const needsQuote = s.includes('"') || s.includes(delimiter) || s.includes('\n') || s.includes('\r');
                const escaped = s.replace(/"/g, '""');
                return needsQuote ? `"${escaped}"` : escaped;
            };

            // 사용량 기간 파싱
            let startDate = null, endDate = null;
            const periodMatch = usagePeriodText.match(/(\d{4}-\d{2}-\d{2})\s*~\s*(\d{4}-\d{2}-\d{2})/);
            if (periodMatch) {
                startDate = periodMatch[1];
                endDate = periodMatch[2];
            }

            // 멤버/이벤트 데이터 수집
            let members = [];
            try {
                const membersData = await getTeamMembers();
                members = membersData && membersData.teamMembers ? membersData.teamMembers : [];
            } catch (e) {
                console.warn('미리보기 멤버 데이터 수집 실패:', e);
            }

            // 이벤트 맵: 기간이 설정되면 이벤트 먼저 수집해 비활성 계산에 사용
            let emailToUsageCost = new Map();
            let emailToLastTs = new Map();
            const anyUsage = (attAllUsage || attInactiveUsage || attCustomUsage) && startDate && endDate;
            const needEventsForInactivity = attInactive && startDate && endDate;
            const shouldFetchEvents = (anyUsage || needEventsForInactivity) && startDate && endDate;
            if (shouldFetchEvents) {
                try {
                    const eventsData = await getFilteredEvents(startDate, endDate);
                    if (eventsData && eventsData.usageEvents) {
                        for (const ev of eventsData.usageEvents) {
                            const key = ev.userEmail || ev.email;
                            if (!key) continue;
                            const prev = emailToUsageCost.get(key) || 0;
                            emailToUsageCost.set(key, prev + (ev.requestsCosts || 0));
                            const ts = parseInt(ev.timestamp || 0) || 0;
                            const prevTs = emailToLastTs.get(key) || 0;
                            if (ts > prevTs) emailToLastTs.set(key, ts);
                        }
                    }
                } catch (e) {
                    console.warn('미리보기 사용량 데이터 수집 실패:', e);
                }
            }

            // 멤버 확보 후 첨부 요약 생성 (실제 목록/카운트/샘플/전체보기)
            (function(){
                try {
                    const allMemberFullList = (members || []).map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`).filter(Boolean);
                    const customFullList = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);

                    // 비활성 기준: 첨부 파일 섹션과 동일하게 "최근 N일 무활동" 기준 사용
                    const inactivityDays = (window.attachmentInactiveState && window.attachmentInactiveState.days)
                        || parseInt(document.getElementById('attachment-inactive-days')?.value)
                        || 14;
                    const rawEventsNow = (typeof currentRawEventsData !== 'undefined' && Array.isArray(currentRawEventsData)
                        ? currentRawEventsData
                        : (window.currentRawEventsData || []));
                    const allowedEventsNow = rawEventsNow.filter(ev => ev && ev.userEmail && typeof ev.requestsCosts === 'number' && ev.requestsCosts > 0 && !isNaN(parseInt(ev.timestamp)));
                    const cutoffTs = Date.now() - (inactivityDays * 24 * 60 * 60 * 1000);
                    const activeEmailsSet = new Set();
                    for (const ev of allowedEventsNow) {
                        const ts = parseInt(ev.timestamp);
                        if (ts >= cutoffTs) {
                            activeEmailsSet.add(ev.userEmail);
                        }
                    }
                    const inactiveByDays = (members || []).filter(m => !activeEmailsSet.has(m.email));
                    const inactiveFullList = inactiveByDays.map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`).filter(Boolean);

                    const allMemberCount = attAll ? allMemberFullList.length : 0;
                    const inactiveCount = attInactive ? inactiveFullList.length : 0;
                    const customCount = attCustom ? customFullList.length : 0;

                    const sampleBlock = (items) => {
                        const take = items.slice(0, Math.max(3, Math.min(10, items.length)));
                        if (!take.length) return '<div style=\"color:#7a7a7a;\">표시할 항목이 없습니다.</div>';
                        return `<pre style=\"white-space:pre-wrap; background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:10px; color:#e1e1e1; max-height:120px; overflow:auto;\">${take.join('\\n')}${items.length>take.length?'\\n…':''}</pre>`;
                    };

                    const attachmentRows = [];
                    attachmentRows.push(`<div>• 전체 멤버 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attAll ? '포함' : '미포함'}${attAllUsage ? ' (사용량 포함)' : ''}</span>${attAll ? ` <span style=\"color:#b1b1b1;\">(총 ${allMemberCount}명)</span>` : ''} ${attAll ? `<button id=\"view-all-all-members\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
                    if (attAll) attachmentRows.push(`<div style=\"margin-top:6px;\">${sampleBlock(allMemberFullList)}</div>`);
                    attachmentRows.push(`<div style=\"margin-top:10px;\">• 비활성 멤버 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attInactive ? '포함' : '미포함'}${attInactiveUsage ? ' (사용량 포함)' : ''}</span>${attInactive ? ` <span style=\"color:#b1b1b1;\">(총 ${inactiveCount}명)</span>` : ''} ${attInactive ? `<button id=\"view-all-inactive-members\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
                    if (attInactive) attachmentRows.push(`<div style=\"margin-top:6px;\">${sampleBlock(inactiveFullList)}</div>`);
                    attachmentRows.push(`<div style=\"margin-top:10px;\">• 직접 입력 리스트: <span style=\"color:#ff9800; font-weight:600;\">${attCustom ? '포함' : '미포함'}${attCustomUsage ? ' (사용량 포함)' : ''}</span>${attCustom ? ` <span style=\"color:#b1b1b1;\">(총 ${customCount}명)</span>` : ''} ${attCustom ? `<button id=\"view-all-custom\" class=\"chart-btn\" style=\"padding:2px 8px; font-size:12px; margin-left:6px;\">전체 보기</button>` : ''}</div>`);
                    if (attCustom) attachmentRows.push(`<div style=\"margin-top:6px;\">${sampleBlock(customFullList)}</div>`);
                    // 사용량 기간은 사용량 옵션이 하나라도 체크된 경우, 요약 맨 하단에 표시
                    if (attAllUsage || attInactiveUsage || attCustomUsage) {
                        attachmentRows.push(`<div style=\"margin-top:10px;\">• 사용량 기간: <span style=\"color:#ff9800; font-weight:600;\">${usagePeriodText || '설정 없음'}</span></div>`);
                    }

                    attachmentSummaryHTML = attachmentRows.join('');

                    // 모달에서 사용할 비활성 이메일 목록 저장 (첨부 섹션과 동일 기준)
                    window.__previewInactiveEmailsByPeriod = inactiveByDays.map(m => m.email).filter(Boolean);
                } catch (e) { console.warn('첨부 요약 생성 실패:', e); }
            })();

            // CSV 헤더 구성 (사용량 컬럼은 그룹별 사용량 옵션이 하나라도 선택된 경우 포함)
            const includeUsageCol = (attAllUsage || attInactiveUsage || attCustomUsage);
            const headers = ['Type', 'Name', 'Email', 'Role', 'Premium Requests', 'Spend ($)']
                .concat(includeUsageCol ? ['Usage RequestsCosts'] : []);
            const rows = [headers];

            // 전체 멤버
            if (attAll) {
                const usageOn = !!attAllUsage;
                for (const m of members) {
                    const row = [
                        '전체',
                        m.name || '',
                        m.email || '',
                        m.role || '',
                        m.spendData?.premiumRequests ?? 0,
                        (m.spendData?.spend ?? 0).toFixed(2)
                    ];
                    if (includeUsageCol) {
                        row.push(usageOn ? (emailToUsageCost.get(m.email) || 0) : '');
                    }
                    rows.push(row);
                }
            }

            // 비활성 멤버 (첨부 섹션과 동일 기준: 최근 N일 무활동)
            if (attInactive) {
                const usageOn = !!attInactiveUsage;
                const byDaysSet = new Set(Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : []);
                const inactives = (members || []).filter(m => byDaysSet.has(m.email));
                for (const m of inactives) {
                    const row = [
                        '비활성',
                        m.name || '',
                        m.email || '',
                        m.role || '',
                        m.spendData?.premiumRequests ?? 0,
                        (m.spendData?.spend ?? 0).toFixed(2)
                    ];
                    if (includeUsageCol) {
                        row.push(usageOn ? (emailToUsageCost.get(m.email) || 0) : '');
                    }
                    rows.push(row);
                }
            }

            // 직접 입력 리스트
            if (attCustom) {
                const usageOn = !!attCustomUsage;
                const list = (customAttachmentEmails || '')
                    .split(',')
                    .map(s => s.trim())
                    .filter(Boolean);
                for (const email of list) {
                    const row = [
                        '직접입력',
                        '',
                        email,
                        'custom',
                        '',
                        ''
                    ];
                    if (includeUsageCol) {
                        row.push(usageOn ? (emailToUsageCost.get(email) || 0) : '');
                    }
                    rows.push(row);
                }
            }

            // CSV 문자열 생성
            const csvLines = rows.map(r => r.map(quote).join(delimiter));
            const csvContent = csvLines.join(newline);
            window.__attachmentsCsvContent = csvContent;

            const schedule = schedules[0] || {};
            const html = `
                <div id="schedule-preview-modal" style="
                    position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1100;
                ">
                    <div style="
                        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        width: 90%; max-width: 900px; max-height: 85vh; overflow: auto;
                        background: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 8px; padding: 20px;
                    ">
                        <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #3a3a3a; padding-bottom:12px; margin-bottom:16px;">
                            <div style="color:#fff; font-size:18px; font-weight:600;">예약 미리보기</div>
                        </div>
                        <!-- 수신자 보기 스타일의 상단 정보 블록 (실데이터는 오렌지색) -->
                        <div style="background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px;">
                            <div style="display:grid; grid-template-columns: 1fr 3fr; gap:8px;">
                                <div style="color:#b1b1b1;">주기</div>
                                <div style="color:#ff9800;">${schedules[0]?.frequency || ''}</div>
                                <div style="color:#b1b1b1;">시간</div>
                                <div>${(() => { const s=schedules[0]||{}; const d=parseNextSendTime((s.currentSend||s.nextSend||'')); if(d){ const h=d.getHours(); const m=String(d.getMinutes()).padStart(2,'0'); const ampm = h<12 ? '오전' : '오후'; const h12 = h===0?12:(h<=12?h:h-12); return `<span style=\"color:#ff9800;\">${ampm} ${h12}시 ${m}분</span>`; } const t=s.time||''; return `<span style=\"color:#ff9800;\">${t}</span>`; })()}</div>
                            </div>
                            <div style="font-size:14px; margin-top:12px;">
                                <div style="color:#fff; font-weight:600; margin-bottom:6px;">발송 메시지</div>
                                <div style="background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#ff9800; white-space:pre-wrap;">${schedules[0]?.message || ''}</div>
                            </div>
                            <div style="margin-top:12px;">
                                <div style="color:#fff; font-weight:600; margin-bottom:8px;">수신자 그룹</div>
                                <div style="display:flex; gap:8px; flex-wrap:wrap;">
                                    ${(() => { const r=(schedule?.recipients||''); const map={ '관리자':'admin','전체 멤버':'all','비활성 멤버':'inactive','직접입력':'custom'}; const chips=['관리자','전체 멤버','비활성 멤버','직접입력'].filter(x=>r.includes(x)).map(x=>`<span class=\"recipient-chip\" data-group=\"${map[x]}\" style=\"background:#2a2a2a; border:1px solid #ff9800; color:#ff9800; padding:4px 8px; border-radius:999px; font-size:12px; cursor:pointer;\">${x}</span>`).join(' '); return chips || '<span style=\"color:#7a7a7a;\">선택된 그룹 없음</span>'; })()}
                                </div>
                            </div>
                        </div>
                        <div style="color:#e1e1e1; font-size:14px; margin:16px 0;">
                            <div style="color:#fff; font-size:16px; font-weight:600; margin-bottom:8px;">첨부 파일 요약</div>
                            <div id="attachments-summary-content" style="background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#e1e1e1; line-height:1.6;">${attachmentSummaryHTML}</div>
                        </div>

                        <!-- 첨부 파일 내용 (수신자 리스트 + 사용량 표 + CSV 미리보기) -->
                        <div style="margin-top:16px; background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; color:#fff; font-size:16px; font-weight:600; border-bottom:1px solid #3a3a3a; padding:12px;">
                                <div>첨부 파일 내용</div>
                                <div style="display:flex; gap:8px;">
                                    <button class="analytics-btn" onclick="downloadAttachmentsPreviewCSV()">CSV 다운로드</button>
                                </div>
                            </div>
                            <div style="padding:12px; display:flex; flex-direction:column; gap:12px;">
                                <!-- 박스 1: 체크박스 선택/입력된 수신자 리스트 -->
                                <div id="attachments-detail-recipient-box" style="background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px;">
                                    <div style="color:#fff; font-weight:600; margin-bottom:8px;">수신자 리스트</div>
                                    <div style="color:#7a7a7a;">로딩 중...</div>
                                </div>
                                <!-- 박스 2: 사용량 체크 시 누적 사용량 표 -->
                                <div id="attachments-detail-usage-box" style="background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px; padding:12px;">
                                    <div style="display:flex; justify-content:space-between; align-items:center;">
                                        <div style="color:#fff; font-weight:600;">누적 사용량</div>
                                        <div style="color:#ff9800; font-size:12px;">기간: ${usagePeriodText || '설정 없음'}</div>
                                    </div>
                                    <div style="margin-top:8px; color:#7a7a7a;">로딩 중...</div>
                                </div>
                                <!-- CSV 미리보기 박스 제거 (요청 사항) -->
                            </div>
                        </div>

                        <!-- 하단 버튼: 좌측 즉시 발송, 우측 수정/닫기 -->
                        <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-top:16px; border-top:1px solid #3a3a3a; padding-top:16px;">
                            <div>
                                <button id="schedule-preview-send-now-btn" class="analytics-btn">📧 즉시 발송</button>
                            </div>
                            <div style="display:flex; gap:10px;">
                                <button id="schedule-preview-edit-btn" class="chart-btn">수정</button>
                            <button class="chart-btn" onclick="document.getElementById('schedule-preview-modal').remove()">닫기</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            // 이미 쉘을 렌더링했다면, 해당 쉘의 콘텐츠를 실제 내용으로 교체
            const shellModal = document.getElementById('schedule-preview-modal');
            if (shellModal) {
                shellModal.outerHTML = html;
            } else {
                document.body.insertAdjacentHTML('beforeend', html);
            }

            // 미리보기 CSV 다운로드 핸들러를 위한 전역 함수 바인딩
            window.downloadAttachmentsPreviewCSV = async function() {
                try {
                    const sheetsPayload = window.__attachmentsSheets;
                    if (!sheetsPayload || !Array.isArray(sheetsPayload.sheets) || sheetsPayload.sheets.length === 0) {
                        showSimpleAlert('⚠️ 다운로드할 첨부 데이터가 없습니다.', 'warning');
                        return;
                    }
                    const resp = await fetch('/api/generate-xlsx', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(sheetsPayload)
                    });
                    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                    const blob = await resp.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = sheetsPayload.filename || `email_attachments_${new Date().toISOString().split('T')[0]}.xlsx`;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                } catch (e) {
                    console.error('XLSX 다운로드 실패:', e);
                    showSimpleAlert('❌ 엑셀 파일 다운로드 중 오류가 발생했습니다.', 'error');
                }
            };

            // 첨부 상세 박스 렌더링 (수신자 리스트 + 누적 사용량 표)
            (function renderAttachmentDetailBoxes(){
                try {
                    const recBox = document.getElementById('attachments-detail-recipient-box');
                    const usageBox = document.getElementById('attachments-detail-usage-box');
                    if (!recBox || !usageBox) return;

                    // 1) 수신자 리스트 구성
                    const sections = [];
                    const monoList = (arr) => arr && arr.length
                        ? `<pre style="white-space:pre-wrap; background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:10px; color:#ff9800; max-height:200px; overflow:auto;">${arr.join('\n')}</pre>`
                        : `<div style="color:#7a7a7a;">표시할 항목이 없습니다.</div>`;

                    // 전체 멤버
                    if (attAll) {
                        const emails = (members || []).map(m => m.email).filter(Boolean);
                        const names = (members || []).map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`).filter(Boolean);
                        sections.push(`
                            <div style="margin-bottom:10px;">
                                <div style="color:#fff; font-weight:600;">전체 멤버 <span style="color:#b1b1b1; font-weight:400;">(${emails.length}명)</span></div>
                                ${monoList(names)}
                            </div>
                        `);
                    }

                    // 비활성 멤버 (첨부 섹션과 동일 기준: 최근 N일 무활동)
                    if (attInactive) {
                        const byPeriod = Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : [];
                        let inactiveEmails = byPeriod && byPeriod.length ? byPeriod : [];
                        if (!inactiveEmails.length) {
                            // 보조: 데이터가 없을 경우에만 spendData 기준 사용
                            inactiveEmails = (members || []).filter(m => (m.spendData && m.spendData.premiumRequests === 0)).map(m => m.email).filter(Boolean);
                        }
                        const inactiveRows = (members || [])
                            .filter(m => inactiveEmails.includes(m.email))
                            .map(m => `${m.name || m.email || 'unknown'} <${m.email || ''}>`);
                        sections.push(`
                            <div style="margin-bottom:10px;">
                                <div style="color:#fff; font-weight:600;">비활성 멤버 <span style="color:#b1b1b1; font-weight:400;">(${inactiveEmails.length}명)</span></div>
                                ${monoList(inactiveRows)}
                            </div>
                        `);
                    }

                    // 직접 입력
                    if (attCustom) {
                        const customList = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);
                        sections.push(`
                            <div style="margin-bottom:10px;">
                                <div style="color:#fff; font-weight:600;">직접 입력 <span style="color:#b1b1b1; font-weight:400;">(${customList.length}명)</span></div>
                                ${monoList(customList)}
                            </div>
                        `);
                    }

                    recBox.innerHTML = `
                        <div style="color:#fff; font-weight:600; margin-bottom:8px;">수신자 리스트</div>
                        ${sections.join('') || '<div style="color:#7a7a7a;">선택된 수신자 그룹이 없습니다.</div>'}
                    `;

                    // 2) 누적 사용량 표 구성
                    const anyUsageSelected = (attAllUsage || attInactiveUsage || attCustomUsage);
                    if (!anyUsageSelected) {
                        usageBox.style.display = 'none';
                        return;
                    }

                    if (!(startDate && endDate)) {
                        usageBox.innerHTML = `
                            <div style="display:flex; justify-content:space-between; align-items:center;">
                                <div style="color:#fff; font-weight:600;">누적 사용량</div>
                                <div style="color:#ff9800; font-size:12px;">기간: 설정 없음</div>
                            </div>
                            <div style="margin-top:8px; color:#7a7a7a;">사용량 기간이 설정되지 않았습니다. 첨부 사용량 기간을 먼저 선택하세요.</div>
                        `;
                        return;
                    }

                    const rows = [];
                    const pushRow = (group, name, email, usage) => {
                        rows.push({ group, name: name || '', email: email || '', usage: usage || 0 });
                    };

                    // 전체 멤버 사용량
                    if (attAll && attAllUsage) {
                        (members || []).forEach(m => {
                            pushRow('전체', m.name || '', m.email || '', emailToUsageCost.get(m.email) || 0);
                        });
                    }

                    // 비활성 멤버 사용량 (첨부 섹션과 동일 비활성 집합 기준)
                    if (attInactive && attInactiveUsage) {
                        const inactiveSet = new Set(Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : []);
                        (members || []).forEach(m => {
                            if (inactiveSet.has(m.email)) {
                                pushRow('비활성', m.name || '', m.email || '', emailToUsageCost.get(m.email) || 0);
                            }
                        });
                    }

                    // 직접 입력 사용량
                    if (attCustom && attCustomUsage) {
                        const customList = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);
                        customList.forEach(email => {
                            const m = (members || []).find(x => x.email === email);
                            pushRow('직접입력', m?.name || '', email, emailToUsageCost.get(email) || 0);
                        });
                    }

                    // 새 필드 구성: NAME, EMAIL, ROLE, REQUEST, SPEND, LAST ACT
                    // rows: { group, name, email, usage } → 멤버 정보와 spendData, lastTs를 조합하여 변환
                    const toLastAct = (email) => {
                        const ts = emailToLastTs.get(email) || 0;
                        if (!ts) return '-';
                        const d = new Date(ts);
                        const yyyy = d.getFullYear();
                        const mm = String(d.getMonth() + 1).padStart(2, '0');
                        const dd = String(d.getDate()).padStart(2, '0');
                        const hh = String(d.getHours()).padStart(2, '0');
                        const mi = String(d.getMinutes()).padStart(2, '0');
                        return `${yyyy}-${mm}-${dd} ${hh}:${mi}`;
                    };

                    const emailToMember = new Map((members || []).map(m => [m.email, m]));
                    const detailedRows = rows.map(r => {
                        const m = emailToMember.get(r.email) || {};
                        const roleLabel = (m.role === 'owner') ? 'Admin' : (m.role ? 'Member' : '');
                        // REQUEST는 설정 섹션과 동일하게 기간 내 요청 합계(usageEvents.requestsCosts) 사용
                        const req = (typeof r.usage === 'number') ? r.usage : 0;
                        const spend = (m.spendData && typeof m.spendData.spend === 'number') ? m.spendData.spend : 0;
                        return {
                            name: r.name || '-',
                            email: r.email || '-',
                            role: roleLabel,
                            request: req,
                            spend: spend,
                            lastAct: toLastAct(r.email)
                        };
                    });

                    // 정렬: 요청수 내림차순
                    detailedRows.sort((a, b) => (b.request || 0) - (a.request || 0));

                    const headerHTML = `
                        <div class="table-grid" style="display:grid; grid-template-columns: 2fr 3fr 1fr 1fr 1fr 1.5fr; gap:12px; align-items:center; font-weight:600; color:#e1e1e1; border-bottom:1px solid #3a3a3a; padding-bottom:8px;">
                            <div>NAME</div>
                            <div>EMAIL</div>
                            <div>ROLE</div>
                            <div>REQUEST</div>
                            <div>SPEND</div>
                            <div>LAST ACT</div>
                        </div>`;

                    const bodyHTML = detailedRows.length ? detailedRows.map(r => `
                        <div style="display:grid; grid-template-columns: 2fr 3fr 1fr 1fr 1fr 1.5fr; gap:12px; align-items:center; padding:8px 10px; border-bottom:1px solid #2a2a2a; background:#000; color:#ff9800;">
                            <div>${r.name}</div>
                            <div>${r.email}</div>
                            <div>${r.role}</div>
                            <div>${r.request}</div>
                            <div>$${(r.spend || 0).toFixed(2)}</div>
                            <div>${r.lastAct}</div>
                        </div>
                    `).join('') : `<div style="padding:8px 0; color:#7a7a7a;">표시할 데이터가 없습니다.</div>`;

                    usageBox.innerHTML = `
                        <div style="display:flex; justify-content:space-between; align-items:center;">
                            <div style="color:#fff; font-weight:600;">누적 사용량</div>
                            <div style="color:#ff9800; font-size:12px;">기간: ${usagePeriodText || '설정 없음'}</div>
                        </div>
                        <div style="margin-top:10px;">${headerHTML}${bodyHTML}</div>
                    `;

                    // 첨부용 XLSX 시트 데이터 구성: Recipients + Usage(있을 때)
                    const recipientsRows = [];
                    if (attAll) {
                        (members || []).forEach(m => {
                            recipientsRows.push([m.name || '', m.email || '', '전체']);
                        });
                    }
                    if (attInactive) {
                        const inactiveSet = new Set(Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : []);
                        (members || []).forEach(m => {
                            if (inactiveSet.has(m.email)) {
                                recipientsRows.push([m.name || '', m.email || '', '비활성']);
                            }
                        });
                    }
                    if (attCustom) {
                        const customList = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);
                        customList.forEach(email => {
                            recipientsRows.push(['', email, '직접입력']);
                        });
                    }

                    const usageRows = detailedRows.map(r => [
                        r.name, r.email, r.role, r.request, Number(r.spend || 0).toFixed(2), r.lastAct
                    ]);

                    window.__attachmentsSheets = {
                        filename: `email_attachments_${new Date().toISOString().split('T')[0]}.xlsx`,
                        sheets: [
                            { name: 'Recipients', headers: ['Name','Email','Group'], rows: recipientsRows }
                        ].concat(usageRows.length ? [{ name: 'Usage', headers: ['NAME','EMAIL','ROLE','REQUEST','SPEND','LAST ACT'], rows: usageRows }] : [])
                    };
                } catch (e) {
                    console.warn('첨부 상세 박스 렌더링 실패:', e);
                }
            })();

            // 첨부 요약의 '전체 보기' 버튼 및 수신자 그룹 칩 클릭 시 실제 이메일 리스트 표시
            (function(){
                function showEmailsModal(title, emails){
                    const listHTML = (emails && emails.length)
                        ? `<div style="max-height:50vh; overflow:auto; background:#0f0f0f; border:1px solid #3a3a3a; border-radius:6px; padding:12px; color:#e1e1e1; font-family:monospace; white-space:pre-wrap;">${emails.join('\n')}</div>`
                        : `<div style="padding:12px; color:#7a7a7a; background:#1a1a1a; border:1px solid #3a3a3a; border-radius:6px;">표시할 이메일이 없습니다.</div>`;
                    const m = `
                        <div id="recipient-emails-modal" style="position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1200;">
                            <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:90%; max-width:700px; background:#2a2a2a; border:1px solid #3a3a3a; border-radius:8px; padding:20px;">
                                <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #3a3a3a; padding-bottom:12px; margin-bottom:16px;">
                                    <div style="color:#fff; font-size:16px; font-weight:600;">${title}</div>
                                    <button class="chart-btn" onclick="document.getElementById('recipient-emails-modal').remove()">닫기</button>
                                </div>
                                ${listHTML}
                            </div>
                        </div>`;
                    document.body.insertAdjacentHTML('beforeend', m);
                }

                const chipEls = document.querySelectorAll('#schedule-preview-modal .recipient-chip');
                chipEls.forEach(chip => {
                    chip.addEventListener('click', () => {
                        const group = chip.getAttribute('data-group');
                        let emails = [];
                        if (group === 'admin') {
                            emails = (members || []).filter(m => (m.role === 'owner')).map(m => m.email).filter(Boolean);
                            showEmailsModal('관리자 이메일 리스트', emails);
                        } else if (group === 'all') {
                            emails = (members || []).map(m => m.email).filter(Boolean);
                            showEmailsModal('전체 멤버 이메일 리스트', emails);
                        } else if (group === 'inactive') {
                            // 기간이 선택되었다면 기간 기반 비활성 목록 사용, 아니면 기존 기준 사용
                            const byPeriod = Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : null;
                            emails = (byPeriod && byPeriod.length)
                                ? byPeriod
                                : (members || []).filter(m => (m.spendData && m.spendData.premiumRequests === 0)).map(m => m.email).filter(Boolean);
                            showEmailsModal('비활성 멤버 이메일 리스트', emails);
                        } else if (group === 'custom') {
                            let customs = Array.isArray(schedule.customEmails) ? schedule.customEmails : [];
                            if (!customs || customs.length === 0) {
                                customs = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);
                            }
                            showEmailsModal('직접 입력 이메일 리스트', customs);
                        }
                    });
                });

                // 첨부 요약의 전체 보기 버튼 연결
                const btnAllMembers = document.getElementById('view-all-all-members');
                if (btnAllMembers) {
                    btnAllMembers.addEventListener('click', () => {
                        const emails = (members || []).map(m => m.email).filter(Boolean);
                        showEmailsModal('전체 멤버 이메일 전체 목록', emails);
                    });
                }
                const btnInactive = document.getElementById('view-all-inactive-members');
                if (btnInactive) {
                    btnInactive.addEventListener('click', () => {
                        const byPeriod = Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : null;
                        const emails = (byPeriod && byPeriod.length)
                            ? byPeriod
                            : (members || []).filter(m => (m.spendData && m.spendData.premiumRequests === 0)).map(m => m.email).filter(Boolean);
                        showEmailsModal('비활성 멤버 이메일 전체 목록', emails);
                    });
                }
                const btnCustom = document.getElementById('view-all-custom');
                if (btnCustom) {
                    btnCustom.addEventListener('click', () => {
                        let customs = Array.isArray(schedule.customEmails) ? schedule.customEmails : [];
                        if (!customs || customs.length === 0) {
                            customs = (customAttachmentEmails || '').split(',').map(s => s.trim()).filter(Boolean);
                        }
                        showEmailsModal('직접 입력 이메일 전체 목록', customs);
                    });
                }
            })();

            // 즉시 발송 버튼 동작 (예약 미리보기 기준으로 수신자 산출)
            (function(){
                const btn = document.getElementById('schedule-preview-send-now-btn');
                if (!btn) return;
                btn.addEventListener('click', async (ev) => {
                    const original = btn.innerHTML; btn.disabled = true; btn.style.opacity='0.6'; btn.innerHTML='📧 발송 중...';
                    try {
                        const r = (schedule.recipients || '');
                        let emails = [];
                        if (r.includes('관리자')) {
                            emails = emails.concat((members || []).filter(m => m.role === 'owner').map(m => m.email).filter(Boolean));
                        }
                        if (r.includes('전체 멤버')) {
                            emails = emails.concat((members || []).map(m => m.email).filter(Boolean));
                        }
                        if (r.includes('비활성 멤버')) {
                            const byDays = Array.isArray(window.__previewInactiveEmailsByPeriod) ? window.__previewInactiveEmailsByPeriod : [];
                            if (byDays && byDays.length) {
                                emails = emails.concat(byDays);
                            } else {
                                emails = emails.concat((members || []).filter(m => (m.spendData && m.spendData.premiumRequests === 0)).map(m => m.email).filter(Boolean));
                            }
                        }
                        if (r.includes('직접입력') && Array.isArray(schedule.customEmails)) {
                            emails = emails.concat(schedule.customEmails);
                        }
                        const unique = Array.from(new Set(emails));
                        if (!unique.length) { showSimpleAlert('⚠️ 발송할 수신자가 없습니다.', 'warning'); return; }
                        const payload = {
                            message: (schedule.message || '삼성 AI Experience Group 대시보드 리포트입니다.'),
                            selectedGroups: ['관리자','전체 멤버','비활성 멤버','직접입력'].filter(x=>r.includes(x)),
                            customEmails: Array.isArray(schedule.customEmails) ? schedule.customEmails : [],
                            allEmails: unique,
                            timestamp: new Date().toLocaleString('ko-KR'),
                            source: 'preview',
                            scheduleTitle: schedule.title || '예약 리포트',
                            attachmentsSheets: (window.__attachmentsSheets || schedule.attachmentsSheets || null)
                        };
                        await sendEmailViaSMTP(payload);
                        showSimpleAlert('✅ 이메일이 성공적으로 발송되었습니다!', 'success');
                    } catch (e) {
                        console.error(e); showSimpleAlert('❌ 이메일 발송에 실패했습니다. 잠시 후 다시 시도해주세요.', 'error');
                    } finally {
                        btn.innerHTML = original; btn.disabled = false; btn.style.opacity='1';
                    }
                });
            })();

            // 수정 버튼: 예약 수정 모달 열기
            (function(){
                const editBtn = document.getElementById('schedule-preview-edit-btn');
                if (!editBtn) return;
                editBtn.addEventListener('click', () => {
                    try { openEditScheduleModal(schedule); } catch(e) { console.error(e); }
                });
            })();
        }

        // 선택된 예약 수정 열기
        function editSelectedSchedule() {
            // DOM에서 실제 체크된 상태를 다시 확인하여 신뢰성 보강
            const domChecked = Array.from(document.querySelectorAll('#email-schedule-modal .schedule-select-checkbox'))
                .filter(cb => cb.checked)
                .map(cb => parseInt(cb.getAttribute('data-id')))
                .filter(id => !isNaN(id));
            const ids = domChecked.length ? domChecked : Array.from(window._selectedScheduleIds || []);
            if (ids.length !== 1) {
                showSimpleAlert('⚠️ 하나의 예약만 선택하여 수정하세요.', 'warning');
                return;
            }
            const id = ids[0];
            const schedule = (window.emailScheduleList || []).find(s => s.id === id);
            if (!schedule) {
                showSimpleAlert('⚠️ 선택된 예약을 찾을 수 없습니다.', 'warning');
                return;
            }
            // 기존 인라인 편집(제목/주기/시간/수신자 클릭 편집) 유지 + 별도 수정 모달 제공
            openEditScheduleModal(schedule);
        }

        function openEditScheduleModal(schedule) {
            // 간단한 수정 모달: 제목, 메시지, 주기(셀렉트), 시간(시간 선택), 수신자 문자열
            const html = `
                <div id="edit-schedule-modal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1100;">
                    <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:90%; max-width:720px; background:#2a2a2a; border:1px solid #3a3a3a; border-radius:8px; padding:20px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #3a3a3a; padding-bottom:12px; margin-bottom:16px;">
                            <div style="color:#fff; font-size:18px; font-weight:600;">예약 수정</div>
                            <button style="background:none; border:none; color:#7a7a7a; font-size:18px; cursor:pointer;" onclick="document.getElementById('edit-schedule-modal').remove()">×</button>
                        </div>
                        <div style="display:grid; gap:12px;">
                            <label style="color:#e1e1e1; font-size:14px;">제목
                                <input id="edit-title" class="search-box" style="width:100%; margin-top:6px; color:#ff9800;" value="${schedule.title || ''}">
                            </label>
                            <label style="color:#e1e1e1; font-size:14px;">메시지
                                <textarea id="edit-message" class="search-box" style="width:100%; height:90px; margin-top:6px; color:#ff9800;">${schedule.message || ''}</textarea>
                            </label>
                            <label style="color:#e1e1e1; font-size:14px;">주기
                                <select id="edit-frequency" class="setting-select" style="background-color: transparent; width:100%; margin-top:6px; color:#ff9800;" onfocus="this.style.backgroundColor='#3a3a3a'" onblur="this.style.backgroundColor='transparent'">
                                    ${['매일','매주','매월'].map(opt => `<option value="${opt}" ${opt===(schedule.frequency||'')?'selected':''}>${opt}</option>`).join('')}
                                </select>
                            </label>
                            <label style="color:#e1e1e1; font-size:14px;">이번 발송
                                <input id="edit-current-send-dt" type="datetime-local" class="search-box" style="width:100%; margin-top:6px; color:#ff9800;" value="${(() => { const dv = parseNextSendTime(schedule.currentSend || schedule.nextSend || ''); if(!dv) return ''; const y=dv.getFullYear(); const m=String(dv.getMonth()+1).padStart(2,'0'); const d=String(dv.getDate()).padStart(2,'0'); const hh=String(dv.getHours()).padStart(2,'0'); const mm=String(dv.getMinutes()).padStart(2,'0'); return `${y}-${m}-${d}T${hh}:${mm}`; })()}">
                            </label>
                            <div style="color:#e1e1e1; font-size:14px;">수신자 그룹</div>
                            <div style="display:flex; gap:10px; flex-wrap: wrap; align-items:center;">
                                <label style="display:flex; align-items:center; gap:6px;">
                                    <input type="checkbox" id="edit-admin-checkbox" ${((schedule.recipients||'').includes('관리자')) ? 'checked' : ''} style="width:16px; height:16px;">
                                    <span style="color:#e1e1e1; font-size:14px;">관리자</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:6px;">
                                    <input type="checkbox" id="edit-all-members-checkbox" ${((schedule.recipients||'').includes('전체 멤버')) ? 'checked' : ''} style="width:16px; height:16px;">
                                    <span style="color:#e1e1e1; font-size:14px;">전체 멤버</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:6px;">
                                    <input type="checkbox" id="edit-inactive-members-checkbox" ${((schedule.recipients||'').includes('비활성 멤버')) ? 'checked' : ''} style="width:16px; height:16px;">
                                    <span style="color:#e1e1e1; font-size:14px;">비활성 멤버</span>
                                </label>
                                <label style="display:flex; align-items:center; gap:6px;">
                                    <input type="checkbox" id="edit-custom-email-checkbox" ${((Array.isArray(schedule.customEmails) && schedule.customEmails.length>0) || (schedule.recipients||'').includes('직접입력')) ? 'checked' : ''} onclick="(function(){var c=document.getElementById('edit-custom-email-container'); if(c){ c.style.display = document.getElementById('edit-custom-email-checkbox').checked ? 'block' : 'none'; } })()" style="width:16px; height:16px;">
                                    <span style="color:#e1e1e1; font-size:14px;">직접 입력</span>
                                </label>
                            </div>
                            <div id="edit-custom-email-container" style="display: ${(Array.isArray(schedule.customEmails) && schedule.customEmails.length>0) ? 'block' : 'none'}; margin-top:8px;">
                                <textarea id="edit-custom-emails" placeholder="email을 직접 입력 하세요.(example1@samsung.com, example2@samsung.com)" style="width: 100%; height: 100px; padding: 10px 12px; background-color: #2a2a2a; border: 1px solid #3a3a3a; border-radius: 4px; color: #ff9800; font-size: 14px; outline: none; resize: vertical; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">${Array.isArray(schedule.customEmails) ? schedule.customEmails.join(', ') : ''}</textarea>
                            </div>
                        </div>
                        <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:16px;">
                            <button class="chart-btn" onclick="(function(){
                                const t=document.getElementById('edit-title').value.trim();
                                const m=document.getElementById('edit-message').value.trim();
                                const f=document.getElementById('edit-frequency').value;
                                const dtVal=document.getElementById('edit-current-send-dt').value; // yyyy-MM-ddTHH:mm
                                // 수신자 그룹 수집
                                var groups=[];
                                if (document.getElementById('edit-admin-checkbox') && document.getElementById('edit-admin-checkbox').checked) groups.push('관리자');
                                if (document.getElementById('edit-all-members-checkbox') && document.getElementById('edit-all-members-checkbox').checked) groups.push('전체 멤버');
                                if (document.getElementById('edit-inactive-members-checkbox') && document.getElementById('edit-inactive-members-checkbox').checked) groups.push('비활성 멤버');
                                var customList = [];
                                var customChecked = document.getElementById('edit-custom-email-checkbox') && document.getElementById('edit-custom-email-checkbox').checked;
                                var customValEl = document.getElementById('edit-custom-emails');
                                if (customChecked) {
                                    var raw = (customValEl && customValEl.value) ? customValEl.value : '';
                                    var parts = raw.split(',').map(function(s){return s.trim();}).filter(function(s){return s.length>0;});
                                    // 간단한 이메일 유효성 검사
                                    var re=/^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                                    for (var i=0;i<parts.length;i++){ if(!re.test(parts[i])){ showSimpleAlert('⚠️ 올바르지 않은 이메일 형식입니다: '+parts[i], 'warning'); return; } }
                                    if (parts.length>0) { customList = parts; groups.push('직접입력'); }
                                }
                                const list=window.emailScheduleList||[];
                                const idx=list.findIndex(s=>s.id===${schedule.id});
                                if(idx>=0){
                                    list[idx].title=t||list[idx].title;
                                    list[idx].message=m;
                                    list[idx].frequency=f||list[idx].frequency;
                                    // 시간 반영: 인라인 편집과 동일하게 datetime-local 기준으로 업데이트
                                    if (dtVal) {
                                        var mdt = dtVal.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})$/);
                                        if (mdt) {
                                            var yy = parseInt(mdt[1],10);
                                            var mo = parseInt(mdt[2],10);
                                            var dd = parseInt(mdt[3],10);
                                            var hhs = mdt[4];
                                            var mms = mdt[5];
                                            list[idx].currentSend = yy + '. ' + mo + '. ' + dd + '. ' + hhs + ':' + mms;
                                            var hourNum=parseInt(hhs,10);
                                            var minuteNum=parseInt(mms,10);
                                            var ampm = (hourNum===0) ? '오전' : (hourNum<12 ? '오전' : '오후');
                                            var hour12 = (hourNum===0)?12 : (hourNum<=12?hourNum:hourNum-12);
                                            list[idx].time = ampm + ' ' + hour12 + '시 ' + String(minuteNum).padStart(2,'0') + '분';
                                            try {
                                                var freqVal2 = (typeof getFrequencyValue === 'function') ? getFrequencyValue(list[idx].frequency) : null;
                                                if (freqVal2 && typeof calculateNextSendTimeFromCurrent === 'function') {
                                                    list[idx].nextSend = calculateNextSendTimeFromCurrent(list[idx].currentSend, freqVal2);
                                                }
                                            } catch(e) {}
                                        }
                                    }
                                    list[idx].recipients = groups.join(', ');
                                    list[idx].customEmails = customList;
                                }
                                document.getElementById('edit-schedule-modal').remove();
                                // 리스트 다시 표시
                                const modal=document.getElementById('email-schedule-modal');
                                if(modal){
                                    // 테이블만 새로 그림
                                    const content=document.getElementById('schedule-list-content');
                                    if(content){
                                        // 간단히 전체 팝업 재호출로 반영
                                        modal.remove();
                                        showEmailScheduleList();
                                    }
                                }
                                showSimpleAlert('✅ 예약이 수정되었습니다.', 'success');
                            })()">저장</button>
                            <button class="chart-btn" onclick="document.getElementById('edit-schedule-modal').remove()">닫기</button>
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', html);
        }

        // 미리보기 행의 본문(메시지) 클릭 시 전체 보기 + 수정 모달
        function openPreviewMessageEditor(id) {
            try {
                const schedule = (window.emailScheduleList || []).find(s => s.id === id);
                if (!schedule) {
                    showSimpleAlert('⚠️ 메시지를 찾을 수 없습니다.', 'warning');
                    return;
                }
                const html = `
                    <div id="message-editor-modal" style="position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 1200;">
                        <div style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:90%; max-width:720px; background:#2a2a2a; border:1px solid #3a3a3a; border-radius:8px; padding:20px;">
                            <div style="display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid #3a3a3a; padding-bottom:12px; margin-bottom:16px;">
                                <div style="color:#fff; font-size:18px; font-weight:600;">메시지 보기/수정</div>
                                <button class="chart-btn" onclick="document.getElementById('message-editor-modal').remove()">닫기</button>
                            </div>
                            <div style="display:grid; gap:10px;">
                                <div style="color:#e1e1e1; font-size:14px;">전체 본문</div>
                                <textarea id="message-editor-text" class="search-box" style="width:100%; height:260px;">${(schedule.message || '').toString().replace(/</g,'&lt;').replace(/>/g,'&gt;')}</textarea>
                                <div style="color:#7a7a7a; font-size:12px;">미리보기 (2줄 요약, 길이 제한 적용): ${(() => { const limit = (window.PREVIEW_MESSAGE_MAX || 80); const __m = (schedule.message || '').toString().replace(/\s+/g,' ').trim(); return __m.length > limit ? __m.slice(0, limit) + '…' : __m; })()}</div>
                            </div>
                            <div style="display:flex; justify-content:flex-end; gap:10px; margin-top:12px;">
                                <button class="analytics-btn" onclick="(function(){
                                    const ta=document.getElementById('message-editor-text');
                                    const val=ta ? ta.value : '';
                                    const list=window.emailScheduleList||[];
                                    const idx=list.findIndex(s=>s.id===${id});
                                    if(idx>=0){ list[idx].message=val; }
                                    // 미리보기 행 요약도 업데이트
                                    const preview=document.getElementById('preview-message-${id}');
                                    if(preview){
                                        var _v = (val || '').toString().replace(/\s+/g,' ').trim();
                                        var _max = (window.PREVIEW_MESSAGE_MAX || 80);
                                        preview.textContent = _v.length > _max ? _v.slice(0, _max) + '…' : _v;
                                    }
                                    document.getElementById('message-editor-modal').remove();
                                    showSimpleAlert('✅ 본문을 저장했습니다.', 'success');
                                })()">저장</button>
                            </div>
                        </div>
                    </div>`;
                document.body.insertAdjacentHTML('beforeend', html);
            } catch (e) {
                console.error('메시지 에디터 열기 실패:', e);
                showSimpleAlert('❌ 메시지 에디터를 여는 중 오류가 발생했습니다.', 'error');
            }
        }

        // 수신자 보기 함수
        async function showEmailRecipients() {
            // 기존 모달이 있으면 제거
            const existingModal = document.getElementById('email-recipients-modal');
            if (existingModal) {
                existingModal.remove();
            }

            // 현재 설정 값들 수집
            const frequency = document.getElementById('email-frequency-select');
            const timeInput = document.getElementById('email-time-input');
            
            const frequencyText = frequency ? frequency.options[frequency.selectedIndex].text : '매주';
            
            // 시간 입력 처리
            let timeText = '오전 9시 00분';
            if (timeInput && timeInput.value) {
                const [hours, minutes] = timeInput.value.split(':');
                const hour = parseInt(hours);
                const minute = parseInt(minutes);
                
                if (hour < 12) {
                    timeText = `오전 ${hour}시 ${minute.toString().padStart(2, '0')}분`;
                } else if (hour === 12) {
                    timeText = `오후 12시 ${minute.toString().padStart(2, '0')}분`;
                } else {
                    timeText = `오후 ${hour - 12}시 ${minute.toString().padStart(2, '0')}분`;
                }
            }

            // 선택된 수신자 그룹 확인 및 실제 멤버 데이터 수집
            const selectedGroups = [];
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('custom-email-checkbox');
            
            let allRecipients = [];
            
            // 관리자 수집
            if (adminCheckbox && adminCheckbox.checked) {
                const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                allRecipients = allRecipients.concat(admins);
                selectedGroups.push('관리자');
                console.log(`관리자 ${admins.length}명 추가`);
            }
            
            // 전체 멤버 수집
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                const allMembers = originalMembersData ? [...originalMembersData] : [];
                allRecipients = allRecipients.concat(allMembers);
                selectedGroups.push('전체 멤버');
                console.log(`전체 멤버 ${allMembers.length}명 추가`);
            }
            
            // 비활성 멤버 수집 (실시간 조회)
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                try {
                    // 실시간으로 비활성 멤버 조회
                    const currentMembersData = await getTeamMembers();
                    const currentInactiveMembers = currentMembersData ? currentMembersData.filter(member => member.spendData.premiumRequests === 0) : [];
                    allRecipients = allRecipients.concat(currentInactiveMembers);
                    selectedGroups.push('비활성 멤버');
                    console.log(`현재 시점 비활성 멤버 ${currentInactiveMembers.length}명 추가`);
                } catch (error) {
                    console.error('비활성 멤버 조회 실패:', error);
                    // 실패 시 캐시된 데이터 사용
                    const inactiveMembers = originalMembersData ? originalMembersData.filter(member => member.spendData.premiumRequests === 0) : [];
                    allRecipients = allRecipients.concat(inactiveMembers);
                    selectedGroups.push('비활성 멤버');
                    console.log(`캐시된 비활성 멤버 ${inactiveMembers.length}명 추가`);
                }
            }
            
            // 직접 입력 이메일 확인
            const customEmails = document.getElementById('custom-emails');
            const customEmailList = customEmails && customEmails.value.trim() ? customEmails.value.trim() : '';
            
            if (customEmailCheckbox && customEmailCheckbox.checked && customEmailList) {
                const emailList = customEmailList.split(',').filter(email => email.trim().length > 0);
                emailList.forEach(email => {
                    allRecipients.push({
                        name: '직접 입력',
                        email: email.trim(),
                        role: 'custom',
                        spendData: { premiumRequests: 0, spend: 0 }
                    });
                });
                selectedGroups.push('직접 입력');
                console.log(`직접 입력 이메일 ${emailList.length}개 추가`);
            }
            
            // 중복 제거 (이메일 기준)
            const uniqueRecipients = [];
            const seenEmails = new Set();
            allRecipients.forEach(recipient => {
                if (!seenEmails.has(recipient.email)) {
                    seenEmails.add(recipient.email);
                    uniqueRecipients.push(recipient);
                }
            });
            
            console.log(`총 ${uniqueRecipients.length}명의 고유 수신자 수집 완료`);

            // 모달 HTML 생성
            const modalHTML = `
                <div id="email-recipients-modal" style="
                    display: block;
                    position: fixed;
                    z-index: 1000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                ">
                    <div style="
                        background-color: #2a2a2a;
                        margin: 5% auto;
                        padding: 25px;
                        border-radius: 8px;
                        width: 90%;
                        max-width: 700px;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
                        max-height: 85vh;
                        overflow-y: auto;
                        border: 1px solid #3a3a3a;
                    ">
                        <!-- 모달 헤더 -->
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 25px;
                            padding-bottom: 15px;
                            border-bottom: 1px solid #3a3a3a;
                        ">
                            <div style="color: #fff; font-size: 18px; font-weight: 600;">수신자 미리보기</div>
                            <button onclick="closeEmailRecipientsModal()" style="
                                background: none;
                                border: none;
                                color: #7a7a7a;
                                font-size: 20px;
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 3px;
                                transition: color 0.2s ease;
                            " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#7a7a7a'">×</button>
                        </div>

                        <!-- 발송 설정 -->
                        <div style="margin-bottom: 25px;">
                            <div style="color: #fff; font-size: 16px; font-weight: 600; margin-bottom: 15px;">발송 설정</div>
                            <div style="
                                color: #b1b1b1;
                                font-size: 14px;
                                line-height: 1.6;
                            ">
                                <div style="
                                    margin-bottom: 8px;
                                    padding: 8px 12px;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    background-color: transparent;
                                ">• 주기: <span style="color: #ff9800;">${frequencyText}</span></div>
                                <div style="
                                    margin-bottom: 8px;
                                    padding: 8px 12px;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    background-color: transparent;
                                ">• 시간: <span style="color: #ff9800;">${timeText}</span></div>

                            </div>
                        </div>

                        <!-- 발송 메시지 -->
                        <div style="margin-bottom: 25px;">
                            <div style="color: #fff; font-size: 16px; font-weight: 600; margin-bottom: 15px;">발송 메시지</div>
                            <div style="
                                position: relative;
                                background-color: #1a1a1a;
                                border: 1px solid #3a3a3a;
                                border-radius: 4px;
                                transition: all 0.2s ease;
                            ">
                                <textarea 
                                    id="email-message-input" 
                                    placeholder="이메일에 포함될 메시지를 입력하세요..."
                                    style="
                                        width: 100%;
                                        height: 120px;
                                        padding: 12px;
                                        border: none;
                                        background: transparent;
                                        color: #ff9800;
                                        font-size: 14px;
                                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        line-height: 1.5;
                                        outline: none;
                                        resize: vertical;
                                        min-height: 120px;
                                        max-height: 200px;
                                    "
                                    onfocus="this.parentElement.style.backgroundColor='#2a2a2a'; this.parentElement.style.borderColor='#4a9eff'"
                                    onblur="this.parentElement.style.backgroundColor='#1a1a1a'; this.parentElement.style.borderColor='#3a3a3a'"
                                    oninput="syncMessageInputs('email-message-input')"
                                ></textarea>
                            </div>
                            <div style="
                                color: #7a7a7a;
                                font-size: 12px;
                                margin-top: 5px;
                                text-align: right;
                            ">
                                <span id="message-char-count">0</span>/1000 글자
                            </div>
                        </div>

                        <!-- 수신자 그룹 -->
                        <div style="margin-bottom: 25px;">
                            <div style="color: #fff; font-size: 16px; font-weight: 600; margin-bottom: 15px;">수신자 그룹</div>
                            
                            <!-- 수신자 검색 창 -->
                            <div style="margin-bottom: 20px; position: relative;">
                                <div style="
                                    position: relative;
                                    display: flex;
                                    align-items: center;
                                    background-color: #1a1a1a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    padding: 0 12px;
                                    transition: all 0.2s ease;
                                " onfocus="this.style.backgroundColor='#2a2a2a'; this.style.borderColor='#4a9eff'" onblur="this.style.backgroundColor='#1a1a1a'; this.style.borderColor='#3a3a3a'">
                                    <span style="
                                        color: #7a7a7a;
                                        margin-right: 8px;
                                        font-size: 14px;
                                    ">🔍</span>
                                    <input 
                                        type="text" 
                                        id="recipient-search" 
                                        placeholder="수신자 검색..."
                                        style="
                                            flex: 1;
                                            padding: 10px 0;
                                            border: none;
                                            background: transparent;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                            outline: none;
                                        "
                                    >
                                    <button 
                                        id="clear-search" 
                                        onclick="clearRecipientSearch()"
                                        style="
                                            background: none;
                                            border: none;
                                            color: #7a7a7a;
                                            cursor: pointer;
                                            padding: 4px;
                                            font-size: 16px;
                                            margin-left: 8px;
                                            display: none;
                                        "
                                        onmouseover="this.style.color='#fff'" 
                                        onmouseout="this.style.color='#7a7a7a'"
                                    >×</button>
                                </div>
                            </div>

                            ${generateRecipientGroups(selectedGroups, customEmailList)}
                            
                            <!-- 총 수신자 수 표시 -->
                            <div style="
                                margin-top: 20px;
                                padding: 15px;
                                background-color: #1a1a1a;
                                border-radius: 4px;
                                border: 1px solid #3a3a3a;
                            ">
                                <div style="color: #fff; font-size: 16px; font-weight: 600; margin-bottom: 10px;">📊 수신자 통계</div>
                                <div style="color: #b1b1b1; font-size: 14px; line-height: 1.6;">
                                    <div>• 총 수신자: <span style="color: #ff9800; font-weight: 600;">${uniqueRecipients.length}명</span></div>
                                    <div>• 중복 제거: <span style="color: #4a9eff; font-weight: 600;">${allRecipients.length - uniqueRecipients.length}명</span></div>
                                    <div>• 선택된 그룹: <span style="color: #4a9eff; font-weight: 600;">${selectedGroups.join(', ')}</span></div>
                                </div>
                            </div>
                        </div>

                        <!-- 하단 버튼 -->
                        <div style="display: flex; justify-content: space-between; gap: 10px; border-top: 1px solid #3a3a3a; padding-top: 20px;">
                            <button onclick="sendEmailFromPreview()" class="analytics-btn" style="padding: 10px 20px;">📧 즉시 발송</button>
                            <button onclick="closeEmailRecipientsModal()" class="chart-btn" style="padding: 10px 20px;">닫기</button>
                        </div>
                    </div>
                </div>
            `;

            // 모달을 페이지에 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);

            // 수신자 검색 기능 및 메시지 입력창 기능 추가
            setTimeout(() => {
                const searchInput = document.getElementById('recipient-search');
                const clearButton = document.getElementById('clear-search');
                const messageInput = document.getElementById('email-message-input');
                const charCount = document.getElementById('message-char-count');
                
                // 수신자 검색 기능
                if (searchInput) {
                    searchInput.addEventListener('input', function() {
                        const searchTerm = this.value.toLowerCase();
                        const recipientRows = document.querySelectorAll('#email-recipients-modal .recipient-row');
                        
                        // X 버튼 표시/숨김
                        if (clearButton) {
                            clearButton.style.display = this.value ? 'block' : 'none';
                        }
                        
                        recipientRows.forEach(row => {
                            const text = row.textContent.toLowerCase();
                            if (text.includes(searchTerm)) {
                                row.style.display = 'grid';
                            } else {
                                row.style.display = 'none';
                            }
                        });
                    });
                }
                
                // 메시지 입력창 초기 동기화 및 글자 수 카운터 기능
                if (messageInput && charCount) {
                    const maxLength = 1000;
                    
                    // Email Report 테이블의 메시지를 팝업으로 동기화
                    const emailReportMessage = document.getElementById('email-report-message');
                    if (emailReportMessage && emailReportMessage.value) {
                        messageInput.value = emailReportMessage.value;
                        console.log('팝업 열릴 때 메시지 동기화:', emailReportMessage.value);
                    }
                    
                    // 초기 글자 수 설정
                    charCount.textContent = messageInput.value.length;
                    
                    messageInput.addEventListener('input', function() {
                        const currentLength = this.value.length;
                        charCount.textContent = currentLength;
                        
                        // 글자 수 제한
                        if (currentLength > maxLength) {
                            this.value = this.value.substring(0, maxLength);
                            charCount.textContent = maxLength;
                        }
                        
                        // 글자 수에 따른 색상 변경
                        if (currentLength >= maxLength * 0.9) {
                            charCount.style.color = '#ff9800'; // 경고 색상
                        } else if (currentLength >= maxLength * 0.8) {
                            charCount.style.color = '#ff9800'; // 주의 색상
                        } else {
                            charCount.style.color = '#7a7a7a'; // 기본 색상
                        }
                    });
                }
            }, 100);
        }

        // 총 수신자 수 계산 함수
        function calculateTotalRecipients(selectedGroups, customEmailList) {
            let total = 0;
            
            // 실제 멤버 데이터를 사용하여 그룹별 수신자 수 계산
            selectedGroups.forEach(group => {
                switch(group) {
                    case '관리자':
                        const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                        total += admins.length;
                        break;
                    case '전체 멤버':
                        const allMembers = originalMembersData ? [...originalMembersData] : [];
                        total += allMembers.length;
                        break;
                    case '비활성 멤버':
                        const inactiveMembers = originalMembersData ? originalMembersData.filter(member => member.spendData.premiumRequests === 0) : [];
                        total += inactiveMembers.length;
                        break;
                }
            });
            
            // 직접 입력 이메일 수 추가
            if (customEmailList) {
                const emails = customEmailList.split(',').filter(email => email.trim().length > 0);
                total += emails.length;
            }
            
            return total;
        }

        // 수신자 그룹 HTML 생성 함수
        function generateRecipientGroups(selectedGroups, customEmailList) {
            let html = '';
            
            // 실제 멤버 데이터를 사용하여 그룹별 수신자 표시
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('custom-email-checkbox');
            
            // 관리자 그룹
            if (adminCheckbox && adminCheckbox.checked) {
                const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px;">• 관리자 <span style="color: #fff;">(</span><span style="color: #fff; font-weight: 700;">${admins.length}명</span><span style="color: #fff;">)</span></div>
                        <div style="
                            border: 1px solid #3a3a3a;
                            border-radius: 4px;
                            overflow: hidden;
                            max-height: 200px;
                            overflow-y: auto;
                            scrollbar-width: thin;
                            scrollbar-color: #2a2a2a #1a1a1a;
                        ">
                            ${admins.length > 0 ? admins.map(admin => `
                                <div class="recipient-row" style="
                                    display: grid;
                                    grid-template-columns: 1fr 2fr;
                                    border-bottom: 1px solid #3a3a3a;
                                ">
                                    <div style="padding: 10px; color: #ff9800; border-right: 1px solid #3a3a3a;">${admin.name || 'Unnamed'}</div>
                                    <div style="padding: 10px; color: #ff9800;">${admin.email}</div>
                                </div>
                            `).join('') : '<div style="padding: 10px; color: #7a7a7a; text-align: center;">관리자가 없습니다.</div>'}
                        </div>
                    </div>
                `;
            }
            
            // 전체 멤버 그룹
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                const allMembers = originalMembersData ? [...originalMembersData] : [];
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px;">• 전체 멤버 <span style="color: #fff;">(</span><span style="color: #fff; font-weight: 700;">${allMembers.length}명</span><span style="color: #fff;">)</span></div>
                        <div style="
                            border: 1px solid #3a3a3a;
                            border-radius: 4px;
                            overflow: hidden;
                            max-height: 200px;
                            overflow-y: auto;
                            scrollbar-width: thin;
                            scrollbar-color: #2a2a2a #1a1a1a;
                        ">
                            ${allMembers.length > 0 ? allMembers.map(member => `
                                <div class="recipient-row" style="
                                    display: grid;
                                    grid-template-columns: 1fr 2fr;
                                    border-bottom: 1px solid #3a3a3a;
                                ">
                                    <div style="padding: 10px; color: #4CAF50; border-right: 1px solid #3a3a3a;">${member.name || 'Unnamed'}</div>
                                    <div style="padding: 10px; color: #4CAF50;">${member.email}</div>
                                </div>
                            `).join('') : '<div style="padding: 10px; color: #7a7a7a; text-align: center;">멤버가 없습니다.</div>'}
                        </div>
                    </div>
                `;
            }
            
            // 비활성 멤버 그룹
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                const inactiveMembers = originalMembersData ? originalMembersData.filter(member => member.spendData.premiumRequests === 0) : [];
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px;">• 비활성 멤버 <span style="color: #fff;">(</span><span style="color: #fff; font-weight: 700;">${inactiveMembers.length}명</span><span style="color: #fff;">)</span></div>
                        <div style="
                            border: 1px solid #3a3a3a;
                            border-radius: 4px;
                            overflow: hidden;
                            max-height: 200px;
                            overflow-y: auto;
                            scrollbar-width: thin;
                            scrollbar-color: #2a2a2a #1a1a1a;
                        ">
                            ${inactiveMembers.length > 0 ? inactiveMembers.map(member => `
                                <div class="recipient-row" style="
                                    display: grid;
                                    grid-template-columns: 1fr 2fr;
                                    border-bottom: 1px solid #3a3a3a;
                                ">
                                    <div style="padding: 10px; color: #7a7a7a; border-right: 1px solid #3a3a3a;">${member.name || 'Unnamed'}</div>
                                    <div style="padding: 10px; color: #7a7a7a;">${member.email}</div>
                                </div>
                            `).join('') : '<div style="padding: 10px; color: #7a7a7a; text-align: center;">비활성 멤버가 없습니다.</div>'}
                        </div>
                    </div>
                `;
            }
            
            // 직접 입력 이메일 그룹
            if (customEmailCheckbox && customEmailCheckbox.checked && customEmailList) {
                const emailList = customEmailList.split(',').filter(email => email.trim().length > 0);
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="color: #fff; font-size: 14px; font-weight: 600; margin-bottom: 10px;">• 직접 입력 <span style="color: #fff;">(</span><span style="color: #fff; font-weight: 700;">${emailList.length}개</span><span style="color: #fff;">)</span></div>
                        <div style="
                            border: 1px solid #3a3a3a;
                            border-radius: 4px;
                            overflow: hidden;
                            max-height: 200px;
                            overflow-y: auto;
                            scrollbar-width: thin;
                            scrollbar-color: #2a2a2a #1a1a1a;
                        ">
                            ${emailList.length > 0 ? emailList.map(email => `
                                <div class="recipient-row" style="
                                    display: grid;
                                    grid-template-columns: 1fr 2fr;
                                    border-bottom: 1px solid #3a3a3a;
                                ">
                                    <div style="padding: 10px; color: #4a9eff; border-right: 1px solid #3a3a3a;">직접 입력</div>
                                    <div style="padding: 10px; color: #4a9eff;">${email.trim()}</div>
                                </div>
                            `).join('') : '<div style="padding: 10px; color: #7a7a7a; text-align: center;">직접 입력된 이메일이 없습니다.</div>'}
                        </div>
                    </div>
                `;
            }
            
           
            
            
            return html;
        }

        // 멤버 행 생성 함수
        function generateMemberRows(count, type) {
            let html = '';
            const names = ['김철수', '이영희', '박민수', '정수진', '최동현', '윤서연', '강태우', '임지영', '한승우', '송미라'];
            const domains = ['samsung.com', 'samsung.co.kr'];
            
            for (let i = 0; i < count; i++) {
                const name = names[i % names.length] + (Math.floor(i / names.length) + 1);
                const domain = domains[i % domains.length];
                const email = `${name.toLowerCase().replace(/[가-힣]/g, '')}@${domain}`;
                
                html += `
                    <div class="recipient-row" style="
                        display: grid;
                        grid-template-columns: 1fr 2fr;
                        ${i < count - 1 ? 'border-bottom: 1px solid #3a3a3a;' : ''}
                    ">
                        <div style="padding: 10px; color: #ff9800; border-right: 1px solid #3a3a3a;">${name}</div>
                        <div style="padding: 10px; color: #ff9800;">${email}</div>
                    </div>
                `;
            }
            
            return html;
        }

        // 검색창 초기화 함수
        function clearRecipientSearch() {
            const searchInput = document.getElementById('recipient-search');
            const clearButton = document.getElementById('clear-search');
            
            if (searchInput) {
                searchInput.value = '';
                if (clearButton) {
                    clearButton.style.display = 'none';
                }
                
                // 모든 행 다시 표시
                const recipientRows = document.querySelectorAll('#email-recipients-modal .recipient-row');
                recipientRows.forEach(row => {
                    row.style.display = 'grid';
                });
            }
        }

        // 예약 리스트 모달 닫기 함수
        function closeEmailScheduleModal() {
            const modal = document.getElementById('email-schedule-modal');
            if (modal) {
                modal.remove();
            }
        }



        // 예약 리스트 필터링 함수
        function filterScheduleList(filter) {
            const filterButtons = document.querySelectorAll('#email-schedule-modal [data-filter]');
            const scheduleItems = document.querySelectorAll('#email-schedule-modal .schedule-item');
            
            // 필터 버튼 활성화 상태 변경
            filterButtons.forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            // 아이템 필터링
            scheduleItems.forEach(item => {
                if (filter === 'all') {
                    // 전체 보기: 모든 아이템 표시
                    item.style.display = 'grid';
                } else if (filter === 'active') {
                    // 활성 보기: 활성 라디오 버튼이 체크된 아이템만 표시
                    const activeRadio = item.querySelector('input[value="active"]');
                    if (activeRadio && activeRadio.checked) {
                    item.style.display = 'grid';
                } else {
                    item.style.display = 'none';
                    }
                } else if (filter === 'inactive') {
                    // 비활성 보기: 비활성 라디오 버튼이 체크된 아이템만 표시
                    const inactiveRadio = item.querySelector('input[value="inactive"]');
                    if (inactiveRadio && inactiveRadio.checked) {
                        item.style.display = 'grid';
                    } else {
                        item.style.display = 'none';
                    }
                }
            });
        }

        // 예약 상세 보기 함수
        function showScheduleDetail(id) {
            alert(`예약 ID ${id}의 상세 정보를 보여줍니다.`);
            // 실제로는 상세 모달을 띄우거나 페이지를 이동
        }

        // 예약 편집 함수
        function editSchedule(id) {
            alert(`예약 ID ${id}를 편집합니다.`);
            // 실제로는 편집 모달을 띄우거나 페이지를 이동
        }

        // 예약 상태 업데이트 함수
        function updateScheduleStatus(id, status) {
            // 전역 변수 업데이트
            if (window.emailScheduleList) {
                const schedule = window.emailScheduleList.find(s => s.id === id);
                if (schedule) {
                    schedule.status = status;
                    console.log(`예약 상태 업데이트: ${id} -> ${status}`);
                    
                    // 스케줄러 상태 확인
                    checkSchedulerStatus();
                }
            }
        }

        // 전체 예약 삭제 함수
        function deleteAllSchedules() {
            // 전체 삭제 확인 모달 생성
            const modalHTML = `
                <div id="delete-all-confirm-modal" style="
                    display: block;
                    position: fixed;
                    z-index: 2000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                ">
                    <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90%;
                        max-width: 400px;
                        background-color: #1a1a1a;
                        border: 1px solid #3a3a3a;
                        border-radius: 8px;
                        padding: 30px;
                        text-align: center;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                    ">
                        <!-- 모달 헤더 -->
                        <div style="
                            margin-bottom: 20px;
                            color: #fff;
                            font-size: 18px;
                            font-weight: 600;
                        ">전체 예약 삭제</div>
                        
                        <!-- 확인 메시지 -->
                        <div style="
                            margin-bottom: 25px;
                            color: #e1e1e1;
                            font-size: 14px;
                            line-height: 1.5;
                        ">정말로 모든 예약을 삭제하시겠습니까?</div>
                        
                        <!-- 버튼 -->
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button class="chart-btn" onclick="closeDeleteAllConfirmModal()" style="min-width: 80px;">취소</button>
                            <button class="analytics-btn" onclick="confirmDeleteAllSchedules()" style="min-width: 80px;">확인</button>
                        </div>
                    </div>
                </div>
            `;

            // 모달을 페이지에 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 전체 삭제 확인 모달 닫기 함수
        function closeDeleteAllConfirmModal() {
            const modal = document.getElementById('delete-all-confirm-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 전체 예약 삭제 확인 함수
        function confirmDeleteAllSchedules() {
            // 모달 닫기
            closeDeleteAllConfirmModal();
            
            // 모든 예약 삭제
            window.emailScheduleList = [];
            
            // 스케줄러 상태 확인
            checkSchedulerStatus();
            
            // 성공 메시지 표시
            showSimpleAlert('✅ 모든 예약이 삭제되었습니다.', 'success');
            
            // 예약 리스트 화면 새로고침
            setTimeout(() => {
                showEmailScheduleList();
            }, 1000);
        }

        // 예약 삭제 함수
        function deleteSchedule(id) {
            // 삭제 확인 모달 생성
            const modalHTML = `
                <div id="delete-confirm-modal" style="
                    display: block;
                    position: fixed;
                    z-index: 2000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                ">
                    <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 90%;
                        max-width: 400px;
                        background-color: #1a1a1a;
                        border: 1px solid #3a3a3a;
                        border-radius: 8px;
                        padding: 30px;
                        text-align: center;
                        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
                    ">
                        <!-- 모달 헤더 -->
                        <div style="
                            margin-bottom: 20px;
                            color: #fff;
                            font-size: 18px;
                            font-weight: 600;
                        ">예약 삭제</div>
                        
                        <!-- 확인 메시지 -->
                        <div style="
                            margin-bottom: 25px;
                            color: #e1e1e1;
                            font-size: 14px;
                            line-height: 1.5;
                        ">정말로 이 예약을 삭제하시겠습니까?</div>
                        
                        <!-- 버튼 -->
                        <div style="display: flex; gap: 10px; justify-content: center;">
                            <button class="chart-btn" onclick="closeDeleteConfirmModal()" style="min-width: 80px;">취소</button>
                            <button class="analytics-btn" onclick="confirmDeleteSchedule(${id})" style="min-width: 80px;">확인</button>
                        </div>
                    </div>
                </div>
            `;

            // 모달을 페이지에 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 삭제 확인 모달 닫기 함수
        function closeDeleteConfirmModal() {
            const modal = document.getElementById('delete-confirm-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 예약 삭제 확인 함수
        function confirmDeleteSchedule(id) {
            // 모달 닫기
            closeDeleteConfirmModal();
            
            // 전역 변수에서 삭제
            if (window.emailScheduleList) {
                window.emailScheduleList = window.emailScheduleList.filter(schedule => schedule.id !== id);
            }
            
            // 스케줄러 상태 확인
            checkSchedulerStatus();
            
            // 성공 메시지 표시
            showSimpleAlert('✅ 예약이 삭제되었습니다.', 'success');
            
            // 예약 리스트 화면 새로고침
            setTimeout(() => {
                showEmailScheduleList();
            }, 1000);
            
            console.log(`예약 ID ${id}가 삭제되었습니다.`);
        }

        // 새 예약 추가 함수
        function addNewSchedule() {
            // 기존 모달 닫기
            closeEmailScheduleModal();
            
            // 새 예약 입력 모달 생성
            const modalHTML = `
                <div id="new-schedule-modal" style="
                    display: block;
                    position: fixed;
                    z-index: 1000;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.7);
                ">
                    <div style="
                        position: absolute;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        width: 95%;
                        max-width: 1200px;
                        max-height: 90vh;
                        background-color: #1a1a1a;
                        border: 1px solid #3a3a3a;
                        border-radius: 8px;
                        padding: 30px;
                        overflow-y: auto;
                    ">
                        <!-- 모달 헤더 -->
                        <div style="
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 25px;
                            padding-bottom: 15px;
                            border-bottom: 1px solid #3a3a3a;
                        ">
                            <div style="color: #fff; font-size: 18px; font-weight: 600;">새 예약 추가</div>
                            <button onclick="closeNewScheduleModal()" style="
                                background: none;
                                border: none;
                                color: #7a7a7a;
                                font-size: 20px;
                                cursor: pointer;
                                padding: 5px;
                                border-radius: 3px;
                                transition: color 0.2s ease;
                            " onmouseover="this.style.color='#fff'" onmouseout="this.style.color='#7a7a7a'">×</button>
                        </div>

                        <!-- 예약 입력 폼 -->
                        <div style="margin-bottom: 20px;">
                            <div style="color: #fff; font-size: 16px; font-weight: 600; margin-bottom: 15px;">예약 정보</div>
                            
                            <!-- 제목 입력 -->
                            <div style="margin-bottom: 15px;">
                                <div style="color: #e1e1e1; font-size: 14px; margin-bottom: 8px;">제목</div>
                                <input type="text" id="new-schedule-title" placeholder="예약 제목을 입력하세요" style="
                                    width: 100%;
                                    padding: 10px 12px;
                                    background-color: #2a2a2a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    color: #e1e1e1;
                                    font-size: 14px;
                                    outline: none;
                                " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'">
                            </div>

                            <!-- 주기 선택 -->
                            <div style="margin-bottom: 15px;">
                                <div style="color: #e1e1e1; font-size: 14px; margin-bottom: 8px;">주기</div>
                                <select id="new-schedule-frequency" style="
                                    width: 100%;
                                    padding: 10px 12px;
                                    background-color: #2a2a2a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    color: #e1e1e1;
                                    font-size: 14px;
                                    outline: none;
                                " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'">
                                    <option value="daily">매일</option>
                                    <option value="weekly" selected>매주</option>
                                    <option value="monthly">매월</option>
                                </select>
                            </div>

                            <!-- 시간 입력 -->
                            <div style="margin-bottom: 15px;">
                                <div style="color: #e1e1e1; font-size: 14px; margin-bottom: 8px;">시간</div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <select id="new-schedule-hour" style="
                                        background-color: #2a2a2a;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 10px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        outline: none;
                                        flex: 1;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'" onchange="updateNewScheduleTime()">
                                        <option value="00">오전 12시</option>
                                        <option value="01">오전 1시</option>
                                        <option value="02">오전 2시</option>
                                        <option value="03">오전 3시</option>
                                        <option value="04">오전 4시</option>
                                        <option value="05">오전 5시</option>
                                        <option value="06">오전 6시</option>
                                        <option value="07">오전 7시</option>
                                        <option value="08">오전 8시</option>
                                        <option value="09" selected>오전 9시</option>
                                        <option value="10">오전 10시</option>
                                        <option value="11">오전 11시</option>
                                        <option value="12">오후 12시</option>
                                        <option value="13">오후 1시</option>
                                        <option value="14">오후 2시</option>
                                        <option value="15">오후 3시</option>
                                        <option value="16">오후 4시</option>
                                        <option value="17">오후 5시</option>
                                        <option value="18">오후 6시</option>
                                        <option value="19">오후 7시</option>
                                        <option value="20">오후 8시</option>
                                        <option value="21">오후 9시</option>
                                        <option value="22">오후 10시</option>
                                        <option value="23">오후 11시</option>
                                    </select>
                                    <select id="new-schedule-minute" style="
                                        background-color: #2a2a2a;
                                        border: 1px solid #3a3a3a;
                                        border-radius: 4px;
                                        padding: 10px 12px;
                                        color: #e1e1e1;
                                        font-size: 14px;
                                        outline: none;
                                        min-width: 100px;
                                        max-height: 200px;
                                        overflow-y: auto;
                                    " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'" onchange="updateNewScheduleTime()">
                                        <option value="00" selected>00분</option>
                                        <option value="01">01분</option>
                                        <option value="02">02분</option>
                                        <option value="03">03분</option>
                                        <option value="04">04분</option>
                                        <option value="05">05분</option>
                                        <option value="06">06분</option>
                                        <option value="07">07분</option>
                                        <option value="08">08분</option>
                                        <option value="09">09분</option>
                                        <option value="10">10분</option>
                                        <option value="11">11분</option>
                                        <option value="12">12분</option>
                                        <option value="13">13분</option>
                                        <option value="14">14분</option>
                                        <option value="15">15분</option>
                                        <option value="16">16분</option>
                                        <option value="17">17분</option>
                                        <option value="18">18분</option>
                                        <option value="19">19분</option>
                                        <option value="20">20분</option>
                                        <option value="21">21분</option>
                                        <option value="22">22분</option>
                                        <option value="23">23분</option>
                                        <option value="24">24분</option>
                                        <option value="25">25분</option>
                                        <option value="26">26분</option>
                                        <option value="27">27분</option>
                                        <option value="28">28분</option>
                                        <option value="29">29분</option>
                                        <option value="30">30분</option>
                                        <option value="31">31분</option>
                                        <option value="32">32분</option>
                                        <option value="33">33분</option>
                                        <option value="34">34분</option>
                                        <option value="35">35분</option>
                                        <option value="36">36분</option>
                                        <option value="37">37분</option>
                                        <option value="38">38분</option>
                                        <option value="39">39분</option>
                                        <option value="40">40분</option>
                                        <option value="41">41분</option>
                                        <option value="42">42분</option>
                                        <option value="43">43분</option>
                                        <option value="44">44분</option>
                                        <option value="45">45분</option>
                                        <option value="46">46분</option>
                                        <option value="47">47분</option>
                                        <option value="48">48분</option>
                                        <option value="49">49분</option>
                                        <option value="50">50분</option>
                                        <option value="51">51분</option>
                                        <option value="52">52분</option>
                                        <option value="53">53분</option>
                                        <option value="54">54분</option>
                                        <option value="55">55분</option>
                                        <option value="56">56분</option>
                                        <option value="57">57분</option>
                                        <option value="58">58분</option>
                                        <option value="59">59분</option>
                                    </select>
                                    <!-- 숨겨진 time input (기존 로직 호환성을 위해) -->
                                    <input type="time" id="new-schedule-time" value="09:00" style="display: none;">
                                </div>
                            </div>

                            <!-- 수신자 그룹 선택 -->
                            <div style="margin-bottom: 15px;">
                                <div style="color: #e1e1e1; font-size: 14px; margin-bottom: 8px;">수신자 그룹</div>
                                <div style="
                                    background-color: #2a2a2a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    padding: 12px;
                                ">
                                    <!-- 관리자 체크박스 -->
                                    <div style="margin-bottom: 8px;">
                                        <label style="
                                            display: flex;
                                            align-items: center;
                                            cursor: pointer;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                        ">
                                            <input type="checkbox" id="new-admin-checkbox" style="
                                                margin-right: 8px;
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                            관리자
                                        </label>
                                    </div>
                                    
                                    <!-- 전체 멤버 체크박스 -->
                                    <div style="margin-bottom: 8px;">
                                        <label style="
                                            display: flex;
                                            align-items: center;
                                            cursor: pointer;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                        ">
                                            <input type="checkbox" id="new-all-members-checkbox" style="
                                                margin-right: 8px;
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                            전체 멤버
                                        </label>
                                    </div>
                                    
                                    <!-- 비활성 멤버 체크박스 -->
                                    <div style="margin-bottom: 8px;">
                                        <label style="
                                            display: flex;
                                            align-items: center;
                                            cursor: pointer;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                        ">
                                            <input type="checkbox" id="new-inactive-members-checkbox" style="
                                                margin-right: 8px;
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                            비활성 멤버
                                        </label>
                                    </div>
                                    
                                    <!-- 직접 입력 체크박스 -->
                                    <div style="margin-bottom: 8px;">
                                        <label style="
                                            display: flex;
                                            align-items: center;
                                            cursor: pointer;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                        ">
                                            <input type="checkbox" id="new-custom-email-checkbox" onclick="toggleNewCustomEmailInput()" style="
                                                margin-right: 8px;
                                                width: 16px;
                                                height: 16px;
                                                accent-color: #4a9eff;
                                            ">
                                            직접 입력
                                        </label>
                                    </div>
                                    
                                    <!-- 직접 입력 이메일 텍스트 영역 (기본적으로 숨김) -->
                                    <div id="new-custom-email-container" style="display: none; margin-top: 8px;">
                                        <textarea id="new-custom-emails" placeholder="email을 직접 입력 하세요.(example1@samsung.com, example2@samsung.com)" style="
                                            width: 100%;
                                            padding: 8px 12px;
                                            background-color: #1a1a1a;
                                            border: 1px solid #3a3a3a;
                                            border-radius: 4px;
                                            color: #e1e1e1;
                                            font-size: 14px;
                                            outline: none;
                                            resize: vertical;
                                            min-height: 60px;
                                            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                        " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'"></textarea>
                                    </div>
                                </div>
                            </div>

                            <!-- 메시지 입력 -->
                            <div style="margin-bottom: 20px;">
                                <div style="color: #e1e1e1; font-size: 14px; margin-bottom: 8px;">메시지</div>
                                <textarea id="new-schedule-message" placeholder="발송할 메시지를 입력하세요" style="
                                    width: 100%;
                                    height: 100px;
                                    padding: 10px 12px;
                                    background-color: #2a2a2a;
                                    border: 1px solid #3a3a3a;
                                    border-radius: 4px;
                                    color: #e1e1e1;
                                    font-size: 14px;
                                    outline: none;
                                    resize: vertical;
                                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                                " onfocus="this.style.borderColor='#4a9eff'" onblur="this.style.borderColor='#3a3a3a'"></textarea>
                            </div>
                        </div>

                        <!-- 하단 버튼 -->
                        <div style="display: flex; justify-content: flex-end; gap: 10px; border-top: 1px solid #3a3a3a; padding-top: 20px;">
                            <button class="chart-btn" onclick="closeNewScheduleModal()">취소</button>
                            <button class="analytics-btn" onclick="saveNewSchedule()">저장</button>
                        </div>
                    </div>
                </div>
            `;

            // 모달을 페이지에 추가
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // 새 예약 모달 닫기 함수
        function closeNewScheduleModal() {
            const modal = document.getElementById('new-schedule-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 새 예약 직접 입력 이메일 토글 함수
        function toggleNewCustomEmailInput() {
            const customEmailCheckbox = document.getElementById('new-custom-email-checkbox');
            const customEmailContainer = document.getElementById('new-custom-email-container');
            
            if (customEmailCheckbox && customEmailContainer) {
                if (customEmailCheckbox.checked) {
                    customEmailContainer.style.display = 'block';
                } else {
                    customEmailContainer.style.display = 'none';
                    // 체크 해제 시 입력값 초기화
                    const customEmails = document.getElementById('new-custom-emails');
                    if (customEmails) {
                        customEmails.value = '';
                    }
                }
            }
        }

        // 새 예약 저장 함수
        function saveNewSchedule() {
            // 입력값 가져오기
            const title = document.getElementById('new-schedule-title').value.trim();
            const frequencySelect = document.getElementById('new-schedule-frequency');
            const timeInput = document.getElementById('new-schedule-time');
            const message = document.getElementById('new-schedule-message').value.trim();

            // 제목 기본값 설정
            const titleText = title || '제목 없음';

            // 선택된 수신자 그룹 확인
            const selectedGroups = [];
            const adminCheckbox = document.getElementById('new-admin-checkbox');
            const allMembersCheckbox = document.getElementById('new-all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('new-inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('new-custom-email-checkbox');

            if (adminCheckbox && adminCheckbox.checked) {
                selectedGroups.push('관리자');
            }
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                selectedGroups.push('전체 멤버');
            }
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                selectedGroups.push('비활성 멤버');
            }

            // 직접 입력이 선택된 경우 수신자 그룹에 추가
            if (customEmailCheckbox && customEmailCheckbox.checked) {
                selectedGroups.push('직접입력');
            }

            if (selectedGroups.length === 0) {
                showSimpleAlert('⚠️ 수신자 그룹을 최소 하나 이상 선택해주세요.', 'warning');
                return;
            }

            // 직접 입력 체크 시 이메일 주소 확인
            const customEmails = document.getElementById('new-custom-emails');
            
            if (customEmailCheckbox && customEmailCheckbox.checked) {
                if (!customEmails || !customEmails.value.trim()) {
                    showSimpleAlert('⚠️ 직접 입력을 선택하셨습니다.\n이메일 주소를 입력해주세요.', 'warning');
                    return;
                }
                
                // 이메일 형식 간단 검증
                const emailList = customEmails.value.split(',');
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                for (let email of emailList) {
                    email = email.trim();
                    if (email && !emailRegex.test(email)) {
                        showSimpleAlert(`⚠️ 올바르지 않은 이메일 형식입니다: ${email}\n\n올바른 형식: example@samsung.com`, 'warning');
                        return;
                    }
                }
            }

            // 주기 텍스트 변환
            const frequencyText = frequencySelect.options[frequencySelect.selectedIndex].text;
            const frequencyValue = frequencySelect.value;

            // 시간 텍스트 변환
            let timeText = '오전 9시 00분';
            let timeValue = '09:00';
            if (timeInput && timeInput.value) {
                const [hours, minutes] = timeInput.value.split(':');
                const hour = parseInt(hours);
                const minute = parseInt(minutes);
                timeValue = timeInput.value;
                
                if (hour < 12) {
                    timeText = `오전 ${hour}시 ${minute.toString().padStart(2, '0')}분`;
                } else if (hour === 12) {
                    timeText = `오후 12시 ${minute.toString().padStart(2, '0')}분`;
                } else {
                    timeText = `오후 ${hour - 12}시 ${minute.toString().padStart(2, '0')}분`;
                }
            }

            // 메시지 기본값 설정
            const messageText = message || '입력 메시지가 없습니다.';

            // 수신자 정보 수집
            const recipientsText = selectedGroups.join(', ');

            // 새 예약 생성
            const newSchedule = {
                id: Date.now(),
                title: titleText,
                frequency: frequencyText,
                time: timeText,
                recipients: recipientsText,
                status: "활성",
                nextSend: calculateNextSendTime(frequencyValue, timeValue),
                message: messageText,
                // 첨부 파일 설정 스냅샷
                attachAllMembers: !!document.getElementById('attachment-all-members')?.checked,
                attachInactiveMembers: !!document.getElementById('attachment-inactive-members')?.checked,
                attachCustom: !!document.getElementById('attachment-custom')?.checked,
                attachAllUsage: !!document.getElementById('attachment-all-usage')?.checked,
                attachInactiveUsage: !!document.getElementById('attachment-inactive-usage')?.checked,
                attachCustomUsage: !!document.getElementById('attachment-custom-usage')?.checked,
                usagePeriodText: (document.getElementById('usage-attachment-period-text')?.textContent || '').trim(),
                // 새 예약 모달에서 입력한 직접 입력 이메일 저장
                customEmails: (function(){
                    const chk = document.getElementById('new-custom-email-checkbox');
                    const ta = document.getElementById('new-custom-emails');
                    if (chk && chk.checked && ta && ta.value.trim()) {
                        return ta.value.split(',').map(e => e.trim()).filter(Boolean);
                    }
                    return [];
                })(),
                // 첨부 시트 스냅샷 (있으면 저장)
                attachmentsSheets: (window.__attachmentsSheets || null)
            };

            // 예약 리스트에 추가
            if (!window.emailScheduleList) {
                window.emailScheduleList = [];
            }

            // 중복 데이터 체크
            const isDuplicate = window.emailScheduleList.some(existingSchedule => {
                return existingSchedule.frequency === newSchedule.frequency &&
                       existingSchedule.time === newSchedule.time &&
                       existingSchedule.recipients === newSchedule.recipients &&
                       existingSchedule.message === newSchedule.message;
            });

            // 중복이 아닌 경우에만 추가
            if (!isDuplicate) {
                window.emailScheduleList.push(newSchedule);
                
                // 스케줄러 상태 확인
                checkSchedulerStatus();
                
                // 모달 닫기
                closeNewScheduleModal();
                
                // 저장 성공 메시지
                showSimpleAlert('✅ 새 예약이 성공적으로 추가되었습니다!', 'success');
                console.log('새 예약 추가 완료', newSchedule);
                
                // 예약 리스트 화면으로 이동
                setTimeout(() => {
                    showEmailScheduleList();
                }, 1000);
            } else {
                // 중복인 경우 경고 메시지
                showSimpleAlert('⚠️ 동일한 설정의 예약이 이미 존재합니다.', 'warning');
            }
        }

        // 수신자 미리보기 모달 닫기 함수
        function closeEmailRecipientsModal() {
            const modal = document.getElementById('email-recipients-modal');
            if (modal) {
                modal.remove();
            }
        }

        // 설정 저장 함수
        async function saveEmailSettings() {
            // 예약 메일 발송 관리 토글 확인
            const emailToggle = document.querySelector('#settings .toggle-switch');
            const isEmailSchedulerEnabled = emailToggle && !emailToggle.classList.contains('off');

            if (!isEmailSchedulerEnabled) {
                showSimpleAlert('⚠️ 예약 메일 발송 관리가 비활성화 상태입니다.\n설정을 저장하기 전에 예약 메일 발송 관리를 활성화해주세요.', 'warning');
                return;
            }

            // 선택된 수신자 그룹 확인 (직접 입력 제외)
            // 수신자 그룹 전용 체크박스만 대상으로 한정하여 다른 설정(예: 사용량) 체크박스가 포함되지 않도록 함
            const selectedGroups = [];
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailToggle = document.getElementById('custom-email-checkbox');

            if (adminCheckbox && adminCheckbox.checked) {
                selectedGroups.push('관리자');
            }
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                selectedGroups.push('전체 멤버');
            }
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                selectedGroups.push('비활성 멤버');
            }

            // 직접 입력 체크 시 이메일 주소 확인
            const customEmailCheckbox = customEmailToggle;
            const customEmails = document.getElementById('custom-emails');
            
            // 수신자 그룹이나 직접 입력 중 하나라도 선택되어야 함
            const hasCustomEmail = customEmailCheckbox && customEmailCheckbox.checked && customEmails && customEmails.value.trim();
            
            if (selectedGroups.length === 0 && !hasCustomEmail) {
                showSimpleAlert('⚠️ 수신자 그룹을 선택하거나 직접 이메일을 입력해주세요.', 'warning');
                return;
            }
            
            if (hasCustomEmail) {
                // 이메일 형식 간단 검증
                const emailList = customEmails.value.split(',');
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                for (let email of emailList) {
                    email = email.trim();
                    if (email && !emailRegex.test(email)) {
                        showSimpleAlert(`⚠️ 올바르지 않은 이메일 형식입니다: ${email}\n\n올바른 형식: example@samsung.com`, 'warning');
                        return;
                    }
                }
            }



            // 메시지 입력 확인 및 기본값 설정
            const messageInput = document.getElementById('email-report-message');
            let messageText = messageInput ? messageInput.value.trim() : '';
            
            // 메시지가 없으면 기본 메시지 설정
            if (!messageText) {
                messageText = '입력 메시지가 없습니다.';
            }

            // 현재 설정 값들 수집
            const frequency = document.getElementById('email-frequency-select');
            const timeInput = document.getElementById('email-time-input');
            
            const frequencyText = frequency ? frequency.options[frequency.selectedIndex].text : '매주';
            const frequencyValue = frequency ? frequency.value : 'weekly';
            
            // 시간 입력 처리
            let timeText = '오전 9시 00분';
            let timeValue = '09:00';
            if (timeInput && timeInput.value) {
                const [hours, minutes] = timeInput.value.split(':');
                const hour = parseInt(hours);
                const minute = parseInt(minutes);
                timeValue = timeInput.value;
                
                if (hour < 12) {
                    timeText = `오전 ${hour}시 ${minute.toString().padStart(2, '0')}분`;
                } else if (hour === 12) {
                    timeText = `오후 12시 ${minute.toString().padStart(2, '0')}분`;
                } else {
                    timeText = `오후 ${hour - 12}시 ${minute.toString().padStart(2, '0')}분`;
                }
            }

            // 수신자 정보 수집 (비활성 멤버 실시간 조회 포함)
            let recipientsText = selectedGroups.join(', ');
            
            // 비활성 멤버가 선택된 경우 실시간 조회
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                try {
                    // 실시간으로 비활성 멤버 조회
                    const currentMembersData = await getTeamMembers();
                    const currentInactiveMembers = currentMembersData ? currentMembersData.filter(member => member.spendData.premiumRequests === 0) : [];
                    console.log(`예약 발송 시점 비활성 멤버 ${currentInactiveMembers.length}명 조회`);
                } catch (error) {
                    console.error('예약 발송 시 비활성 멤버 조회 실패:', error);
                }
            }
            
            if (hasCustomEmail) {
                // 직접 입력이 체크되고 이메일이 있는 경우에만 추가
                recipientsText += recipientsText ? ', 직접입력' : '직접입력';
            }

            // 이번 발송 시간 계산 (현재 설정된 시간)
            const currentSendTime = calculateCurrentSendTime(frequencyValue, timeValue);
            
            // 새 예약 생성
            const newSchedule = {
                id: Date.now(), // 고유 ID 생성
                title: `${frequencyText} 리포트`,
                frequency: frequencyText,
                time: timeText,
                recipients: recipientsText,
                status: "활성",
                currentSend: currentSendTime, // 이번 발송 시간
                nextSend: calculateNextSendTime(frequencyValue, timeValue),
                message: messageText,
                // 첨부 파일 설정 스냅샷
                attachAllMembers: !!document.getElementById('attachment-all-members')?.checked,
                attachInactiveMembers: !!document.getElementById('attachment-inactive-members')?.checked,
                attachCustom: !!document.getElementById('attachment-custom')?.checked,
                attachAllUsage: !!document.getElementById('attachment-all-usage')?.checked,
                attachInactiveUsage: !!document.getElementById('attachment-inactive-usage')?.checked,
                attachCustomUsage: !!document.getElementById('attachment-custom-usage')?.checked,
                usagePeriodText: (document.getElementById('usage-attachment-period-text')?.textContent || '').trim(),
                // Settings에서의 직접 입력 이메일 저장
                customEmails: (function(){
                    const chk = document.getElementById('custom-email-checkbox');
                    const ta = document.getElementById('custom-emails');
                    if (chk && chk.checked && ta && ta.value.trim()) {
                        return ta.value.split(',').map(e => e.trim()).filter(Boolean);
                    }
                    return [];
                })(),
                // 첨부 시트 스냅샷 (있으면 저장)
                attachmentsSheets: (window.__attachmentsSheets || null)
            };

            // 예약 리스트에 추가 (전역 변수로 관리)
            if (!window.emailScheduleList) {
                window.emailScheduleList = [];
            }

            // 중복 데이터 체크
            const isDuplicate = window.emailScheduleList.some(existingSchedule => {
                return existingSchedule.frequency === newSchedule.frequency &&
                       existingSchedule.time === newSchedule.time &&
                       existingSchedule.recipients === newSchedule.recipients &&
                       existingSchedule.message === newSchedule.message;
            });

            // 중복이 아닌 경우에만 추가
            if (!isDuplicate) {
            window.emailScheduleList.push(newSchedule);

                // 저장 성공 메시지 - 심플한 팝업으로 변경
                showSimpleAlert('✅ Email Report 설정이 성공적으로 저장되었습니다!\n\n새로운 예약이 예약 리스트에 추가되었습니다.', 'success');
            console.log('Email Report 설정 저장 완료', newSchedule);
            } else {
                // 중복인 경우 아무런 반응 없음 (조용히 무시)
                console.log('중복된 설정이므로 저장하지 않음:', newSchedule);
            }
        }

        // 심플한 알림 팝업 함수
        function showSimpleAlert(message, type = 'info') {
            // 기존 알림 제거
            const existingAlert = document.querySelector('.simple-alert');
            if (existingAlert) {
                existingAlert.remove();
            }

            // 알림 타입별 스타일 설정
            let bgColor, textColor, icon;
            switch(type) {
                case 'success':
                    bgColor = '#4CAF50';
                    textColor = '#fff';
                    icon = '✅';
                    break;
                case 'warning':
                    bgColor = '#ff9800';
                    textColor = '#fff';
                    icon = '⚠️';
                    break;
                case 'error':
                    bgColor = '#f44336';
                    textColor = '#fff';
                    icon = '❌';
                    break;
                default:
                    bgColor = '#4a9eff';
                    textColor = '#fff';
                    icon = 'ℹ️';
            }

            // 알림 요소 생성
            const alertElement = document.createElement('div');
            alertElement.className = 'simple-alert';
            alertElement.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: ${bgColor};
                color: ${textColor};
                padding: 15px 20px;
                border-radius: 8px;
                font-size: 14px;
                font-weight: 500;
                z-index: 10000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                max-width: 400px;
                word-wrap: break-word;
                line-height: 1.4;
                animation: slideInRight 0.3s ease-out;
            `;
            alertElement.innerHTML = `${icon} ${message}`;

            // 애니메이션 CSS 추가
            if (!document.querySelector('#simple-alert-styles')) {
                const style = document.createElement('style');
                style.id = 'simple-alert-styles';
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes slideOutRight {
                        from {
                            transform: translateX(0);
                            opacity: 1;
                        }
                        to {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }

            // 알림 표시
            document.body.appendChild(alertElement);

            // 3초 후 자동 제거
            setTimeout(() => {
                if (alertElement.parentNode) {
                    alertElement.style.animation = 'slideOutRight 0.3s ease-out';
                    setTimeout(() => {
                        if (alertElement.parentNode) {
                            alertElement.remove();
                        }
                    }, 300);
                }
            }, 3000);
        }

        // 이번 발송 시간 계산 함수 (설정 저장 시 지정된 시간)
        function calculateCurrentSendTime(frequency, time) {
            const now = new Date();
            const [hours, minutes] = time.split(':');
            let currentDate = new Date();
            
            // 현재 날짜에 설정된 시간 적용
            currentDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            
            // 만약 현재 시간이 이미 지났으면, 다음 주기로 설정
            if (currentDate <= now) {
                switch(frequency) {
                    case 'daily':
                        // 내일 같은 시간
                        currentDate.setDate(currentDate.getDate() + 1);
                        break;
                    case 'weekly':
                        // 다음주 같은 시간
                        currentDate.setDate(currentDate.getDate() + 7);
                        break;
                    case 'monthly':
                        // 다음달 같은 시간
                        currentDate.setMonth(currentDate.getMonth() + 1);
                        break;
                }
            }
            
            return currentDate.toLocaleDateString('ko-KR') + ' ' + currentDate.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
        }

        // 다음 발송 시간 계산 함수 (예약 생성 시 사용)
        function calculateNextSendTime(frequency, time) {
            const now = new Date();
            const [hours, minutes] = time.split(':');
            let nextDate = new Date();
            
            // 시간 설정
            nextDate.setHours(parseInt(hours), parseInt(minutes), 0, 0);
            
            // 현재 시간 기준으로 한 주기 후로 설정
            switch(frequency) {
                case 'daily':
                    // 1일 후로 설정
                    nextDate.setDate(nextDate.getDate() + 1);
                    break;
                case 'weekly':
                    // 1주 후로 설정 
                    nextDate.setDate(nextDate.getDate() + 7);
                    break;
                case 'monthly':
                    // 1개월 후로 설정 (정확한 월 계산)
                    const currentMonth = nextDate.getMonth();
                    const currentYear = nextDate.getFullYear();
                    const currentDay = nextDate.getDate();
                    
                    let nextMonth = currentMonth + 1;
                    let nextYear = currentYear;
                    
                    if (nextMonth > 11) {
                        nextMonth = 0;
                        nextYear++;
                    }
                    
                    // 다음 달의 마지막 날을 확인하여 날짜 조정
                    const lastDayOfNextMonth = new Date(nextYear, nextMonth + 1, 0).getDate();
                    const adjustedDay = Math.min(currentDay, lastDayOfNextMonth);
                    
                    nextDate.setFullYear(nextYear, nextMonth, adjustedDay);
                    break;
            }
            
            // 현재 시간보다 이전이면 추가 조정
            while (nextDate <= now) {
                switch(frequency) {
                    case 'daily':
                        nextDate.setDate(nextDate.getDate() + 1);
                        break;
                    case 'weekly':
                        nextDate.setDate(nextDate.getDate() + 7);
                        break;
                    case 'monthly':
                        const month = nextDate.getMonth();
                        const year = nextDate.getFullYear();
                        const day = nextDate.getDate();
                        
                        let newMonth = month + 1;
                        let newYear = year;
                        
                        if (newMonth > 11) {
                            newMonth = 0;
                            newYear++;
                        }
                        
                        const lastDayOfNewMonth = new Date(newYear, newMonth + 1, 0).getDate();
                        const newAdjustedDay = Math.min(day, lastDayOfNewMonth);
                        
                        nextDate.setFullYear(newYear, newMonth, newAdjustedDay);
                        break;
                }
            }
            
            console.log(`📅 예약 생성 시 다음 발송 시간 계산: ${frequency} 주기, 시간: ${time}, 다음: ${nextDate.toLocaleString('ko-KR')}`);
            
            return nextDate.toLocaleDateString('ko-KR') + ' ' + nextDate.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
        }

        // 즉시 발송 함수
        async function sendEmailImmediately() {
            console.log('📧 즉시 발송 버튼이 클릭되었습니다.');
            
            // 현재 설정된 정보 수집
            const emailData = collectCurrentEmailSettings();
            
            if (!emailData) {
                return; // 오류가 있으면 함수 종료 (collectCurrentEmailSettings에서 알림 처리)
            }
            
            // 버튼 비활성화 및 로딩 표시
            const sendButton = event.target;
            const originalText = sendButton.innerHTML;
            sendButton.innerHTML = '📧 발송 중...';
            sendButton.disabled = true;
            sendButton.style.opacity = '0.6';
            
            try {
                // SMTP를 통한 메일 발송
                await sendEmailViaSMTP(emailData);
                
                // 성공 메시지
                showSimpleAlert('✅ 이메일이 성공적으로 발송되었습니다!', 'success');
                console.log('✅ 즉시 발송 완료');
                
            } catch (error) {
                console.error('❌ 이메일 발송 실패:', error);
                showSimpleAlert('❌ 이메일 발송에 실패했습니다. 잠시 후 다시 시도해주세요.', 'error');
            } finally {
                // 버튼 복원
                sendButton.innerHTML = originalText;
                sendButton.disabled = false;
                sendButton.style.opacity = '1';
            }
        }

        // 현재 설정된 정보 수집 함수
        function collectCurrentEmailSettings() {
            console.log('📋 현재 설정 정보 수집 시작');
            
            // 메시지 수집
            const messageInput = document.getElementById('email-report-message');
            let messageText = messageInput ? messageInput.value.trim() : '';
            
            // 메시지가 없으면 기본 메시지 설정
            if (!messageText) {
                messageText = '삼성 AI Experience Group 대시보드 리포트입니다.';
            }
            
            // 체크박스 상태 확인
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('custom-email-checkbox');
            
            const selectedRecipients = [];
            let allRecipientEmails = [];
            
            // 관리자 수집
            if (adminCheckbox && adminCheckbox.checked) {
                const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                const adminEmails = admins.map(admin => admin.email);
                allRecipientEmails = allRecipientEmails.concat(adminEmails);
                selectedRecipients.push('관리자');
                console.log(`✓ 관리자 ${admins.length}명 선택:`, adminEmails);
            }
            
            // 전체 멤버 수집
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                const allMembers = originalMembersData ? [...originalMembersData] : [];
                const allMemberEmails = allMembers.map(member => member.email);
                allRecipientEmails = allRecipientEmails.concat(allMemberEmails);
                selectedRecipients.push('전체 멤버');
                console.log(`✓ 전체 멤버 ${allMembers.length}명 선택:`, allMemberEmails);
            }
            
            // 비활성 멤버 수집
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                const inactiveMembers = originalMembersData ? originalMembersData.filter(member => {
                    // spendData가 있는 경우와 없는 경우 모두 처리
                    if (member.spendData) {
                        return member.spendData.premiumRequests === 0;
                    }
                    return true; // spendData가 없으면 비활성으로 간주
                }) : [];
                const inactiveMemberEmails = inactiveMembers.map(member => member.email);
                allRecipientEmails = allRecipientEmails.concat(inactiveMemberEmails);
                selectedRecipients.push('비활성 멤버');
                console.log(`✓ 비활성 멤버 ${inactiveMembers.length}명 선택:`, inactiveMemberEmails);
            }
            
            // 직접 입력 이메일 주소 수집
            const customEmails = document.getElementById('custom-emails');
            let customEmailList = [];
            
            if (customEmailCheckbox && customEmailCheckbox.checked && customEmails && customEmails.value.trim()) {
                const emails = customEmails.value.split(',').map(email => email.trim()).filter(email => email);
                customEmailList = emails;
                allRecipientEmails = allRecipientEmails.concat(customEmailList);
                console.log('📧 직접 입력된 이메일:', customEmailList);
            }
            
            // 수신자가 없으면 오류
            if (selectedRecipients.length === 0 && customEmailList.length === 0) {
                showSimpleAlert('⚠️ 수신자를 선택해주세요. (관리자, 전체 멤버, 비활성 멤버 또는 직접 입력)', 'warning');
                return null;
            }
            
            // 직접 입력 이메일이 있는 경우 유효성 검사
            if (customEmailList.length > 0) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                for (let email of customEmailList) {
                    if (!emailRegex.test(email)) {
                        showSimpleAlert(`⚠️ 올바르지 않은 이메일 형식입니다: ${email}`, 'warning');
                        return null;
                    }
                }
            }
            
            // 중복 이메일 제거
            const uniqueEmails = [...new Set(allRecipientEmails)];
            console.log(`📬 총 수신자 ${uniqueEmails.length}명 (중복 제거 후):`, uniqueEmails);
            
            // 발신자 정보 수집 (옵션)
            const senderNameEl = document.getElementById('email-sender-name');
            const senderEmailEl = document.getElementById('email-sender-address');
            const fromName = senderNameEl ? senderNameEl.value.trim() : '';
            const fromEmail = senderEmailEl ? senderEmailEl.value.trim() : '';

            return {
                message: messageText,
                selectedGroups: selectedRecipients,
                customEmails: customEmailList,
                allEmails: uniqueEmails, // 모든 수신자 이메일 (중복 제거)
                timestamp: new Date().toLocaleString('ko-KR'),
                fromName,
                fromEmail
            };
        }

        // 수신자 미리보기에서 즉시 발송하는 함수
        async function sendEmailFromPreview() {
            console.log('📧 미리보기에서 즉시 발송 버튼이 클릭되었습니다.');
            
            // 미리보기 팝업에서 현재 설정된 정보 다시 수집
            const emailData = collectEmailDataFromPreview();
            
            if (!emailData) {
                return; // 오류가 있으면 함수 종료
            }
            
            // 버튼 비활성화 및 로딩 표시
            const sendButton = event.target;
            const originalText = sendButton.innerHTML;
            sendButton.innerHTML = '📧 발송 중...';
            sendButton.disabled = true;
            sendButton.style.opacity = '0.6';
            
            try {
                // SMTP를 통한 메일 발송
                await sendEmailViaSMTP(emailData);
                
                // 성공 메시지 (자동 닫기 제거)
                showSimpleAlert('✅ 이메일이 성공적으로 발송되었습니다!', 'success');
                console.log('✅ 미리보기에서 즉시 발송 완료');
                
            } catch (error) {
                console.error('❌ 이메일 발송 실패:', error);
                showSimpleAlert('❌ 이메일 발송에 실패했습니다. 잠시 후 다시 시도해주세요.', 'error');
            } finally {
                // 버튼 복원
                sendButton.innerHTML = originalText;
                sendButton.disabled = false;
                sendButton.style.opacity = '1';
            }
        }

        // 미리보기 팝업에서 이메일 데이터 수집 함수
        function collectEmailDataFromPreview() {
            console.log('📋 미리보기에서 현재 설정 정보 수집 시작');
            
            // 메시지 수집 (미리보기 팝업의 메시지 입력창에서)
            const messageInput = document.getElementById('email-preview-message');
            let messageText = messageInput ? messageInput.value.trim() : '';
            
            // 메시지가 없으면 원본 입력창에서 가져오기
            if (!messageText) {
                const originalMessageInput = document.getElementById('email-report-message');
                messageText = originalMessageInput ? originalMessageInput.value.trim() : '';
            }
            
            // 메시지가 여전히 없으면 기본 메시지 설정
            if (!messageText) {
                messageText = '삼성 AI Experience Group 대시보드 리포트입니다.';
            }
            
            // 현재 체크박스 상태를 다시 확인하여 수신자 수집
            const adminCheckbox = document.getElementById('admin-checkbox');
            const allMembersCheckbox = document.getElementById('all-members-checkbox');
            const inactiveMembersCheckbox = document.getElementById('inactive-members-checkbox');
            const customEmailCheckbox = document.getElementById('custom-email-checkbox');
            
            const selectedRecipients = [];
            let allRecipientEmails = [];
            
            // 관리자 수집
            if (adminCheckbox && adminCheckbox.checked) {
                const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                const adminEmails = admins.map(admin => admin.email);
                allRecipientEmails = allRecipientEmails.concat(adminEmails);
                selectedRecipients.push('관리자');
                console.log(`✓ 관리자 ${admins.length}명 선택:`, adminEmails);
            }
            
            // 전체 멤버 수집
            if (allMembersCheckbox && allMembersCheckbox.checked) {
                const allMembers = originalMembersData ? [...originalMembersData] : [];
                const allMemberEmails = allMembers.map(member => member.email);
                allRecipientEmails = allRecipientEmails.concat(allMemberEmails);
                selectedRecipients.push('전체 멤버');
                console.log(`✓ 전체 멤버 ${allMembers.length}명 선택:`, allMemberEmails);
            }
            
            // 비활성 멤버 수집
            if (inactiveMembersCheckbox && inactiveMembersCheckbox.checked) {
                const inactiveMembers = originalMembersData ? originalMembersData.filter(member => {
                    if (member.spendData) {
                        return member.spendData.premiumRequests === 0;
                    }
                    return true;
                }) : [];
                const inactiveMemberEmails = inactiveMembers.map(member => member.email);
                allRecipientEmails = allRecipientEmails.concat(inactiveMemberEmails);
                selectedRecipients.push('비활성 멤버');
                console.log(`✓ 비활성 멤버 ${inactiveMembers.length}명 선택:`, inactiveMemberEmails);
            }
            
            // 직접 입력 이메일 주소 수집
            const customEmails = document.getElementById('custom-emails');
            let customEmailList = [];
            
            if (customEmailCheckbox && customEmailCheckbox.checked && customEmails && customEmails.value.trim()) {
                const emails = customEmails.value.split(',').map(email => email.trim()).filter(email => email);
                customEmailList = emails;
                allRecipientEmails = allRecipientEmails.concat(customEmailList);
                console.log('📧 직접 입력된 이메일:', customEmailList);
            }
            
            // 수신자가 없으면 오류
            if (selectedRecipients.length === 0 && customEmailList.length === 0) {
                showSimpleAlert('⚠️ 수신자를 선택해주세요. (관리자, 전체 멤버, 비활성 멤버 또는 직접 입력)', 'warning');
                return null;
            }
            
            // 직접 입력 이메일이 있는 경우 유효성 검사
            if (customEmailList.length > 0) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                for (let email of customEmailList) {
                    if (!emailRegex.test(email)) {
                        showSimpleAlert(`⚠️ 올바르지 않은 이메일 형식입니다: ${email}`, 'warning');
                        return null;
                    }
                }
            }
            
            // 발신자 정보 수집 (옵션)
            const senderNameEl = document.getElementById('email-sender-name');
            const senderEmailEl = document.getElementById('email-sender-address');
            const fromName = senderNameEl ? senderNameEl.value.trim() : '';
            const fromEmail = senderEmailEl ? senderEmailEl.value.trim() : '';

            // 중복 이메일 제거
            const uniqueEmails = [...new Set(allRecipientEmails)];
            console.log(`📬 총 수신자 ${uniqueEmails.length}명 (중복 제거 후):`, uniqueEmails);
            
            return {
                message: messageText,
                selectedGroups: selectedRecipients,
                customEmails: customEmailList,
                allEmails: uniqueEmails,
                timestamp: new Date().toLocaleString('ko-KR'),
                source: 'preview', // 미리보기에서 발송됨을 표시
                attachmentsSheets: (window.__attachmentsSheets || null),
                fromName,
                fromEmail
            };
        }

            // SMTP를 통한 메일 발송 함수
        async function sendEmailViaSMTP(emailData) {
            console.log('📤 SMTP를 통한 메일 발송 시작');
            
            // 수신자 목록 텍스트 생성
            let recipientText = '';
            if (emailData.selectedGroups.length > 0) {
                recipientText += `선택된 그룹: ${emailData.selectedGroups.join(', ')}`;
                recipientText += ` (총 ${emailData.allEmails.length}명)`;
            }
            if (emailData.customEmails.length > 0) {
                if (recipientText) recipientText += '\n';
                recipientText += `직접 입력 이메일: ${emailData.customEmails.join(', ')}`;
            }
            
            // 발송 데이터 준비
            const emailPayload = {
                to_emails: emailData.allEmails,
                subject: emailData.source === 'scheduled' 
                    ? `[Samsung AI Dashboard] ${emailData.scheduleTitle || '예약 리포트'}` 
                    : '[Samsung AI Dashboard] 즉시 발송 리포트',
                message: emailData.message,
                recipients: recipientText,
                timestamp: emailData.timestamp,
                dashboard_url: window.location.href,
                recipient_count: emailData.allEmails ? emailData.allEmails.length : 0,
                attachmentsSheets: emailData.attachmentsSheets || null,
                from_email: (emailData.fromEmail || '').trim() || null,
                from_name: (emailData.fromName || '').trim() || null
            };
            
            console.log('📧 SMTP 발송 데이터:', emailPayload);
            console.log(`📬 발송 대상: ${emailData.allEmails ? emailData.allEmails.length : 0}명`);
            console.log('📧 수신자 목록:', emailData.allEmails);
            
            // SMTP 서버로 발송 요청
            try {
                const response = await fetch('/api/send-email', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(emailPayload)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('✅ SMTP 발송 성공:', result);
                return result;
                
            } catch (error) {
                console.error('❌ SMTP 발송 실패:', error);
                throw new Error(`SMTP 발송 실패: ${error.message}`);
            }
        }

        // =====================================================
        // 📅 자동 메일 발송 스케줄러 시스템
        // =====================================================

        // 스케줄러 상태 관리
        let emailSchedulerInterval = null;
        let isSchedulerRunning = false;

        // 스케줄러 시작 함수
        function startEmailScheduler() {
            console.log('🔧 [SCHEDULER] startEmailScheduler() 호출됨');
            
            if (isSchedulerRunning) {
                console.log('📅 [SCHEDULER] 이메일 스케줄러가 이미 실행 중입니다.');
                console.log(`📅 [SCHEDULER] 현재 인터벌 ID: ${emailSchedulerInterval}`);
                return;
            }

            console.log('📅 [SCHEDULER] 이메일 스케줄러를 시작합니다.');
            console.log(`📅 [SCHEDULER] 현재 시간: ${new Date().toLocaleString('ko-KR')}`);
            
            // 예약 리스트 상태 확인
            if (window.emailScheduleList) {
                console.log(`📋 [SCHEDULER] 현재 저장된 예약 개수: ${window.emailScheduleList.length}개`);
                window.emailScheduleList.forEach((schedule, index) => {
                    console.log(`📋 [SCHEDULER] 예약 ${index + 1}: ${schedule.title} (상태: ${schedule.status})`);
                    console.log(`📋 [SCHEDULER]   - 이번 발송: ${schedule.currentSend}`);
                    console.log(`📋 [SCHEDULER]   - 다음 발송: ${schedule.nextSend}`);
                });
            } else {
                console.log('📋 [SCHEDULER] 저장된 예약이 없습니다.');
            }
            
            isSchedulerRunning = true;

            // 1분마다 예약 리스트 검사
            emailSchedulerInterval = setInterval(() => {
                console.log('⏰ [SCHEDULER] 정기 검사 시작 (1분 간격)');
                checkAndSendScheduledEmails();
            }, 60000); // 60초 = 1분

            console.log(`✅ [SCHEDULER] 인터벌 설정 완료, ID: ${emailSchedulerInterval}`);

            // 즉시 한 번 검사
            console.log('🚀 [SCHEDULER] 초기 검사 시작');
            checkAndSendScheduledEmails();
        }

        // 스케줄러 중지 함수
        function stopEmailScheduler() {
            if (emailSchedulerInterval) {
                clearInterval(emailSchedulerInterval);
                emailSchedulerInterval = null;
                isSchedulerRunning = false;
                console.log('📅 이메일 스케줄러가 중지되었습니다.');
            }
        }

        // 예약된 이메일 검사 및 발송
        async function checkAndSendScheduledEmails() {
            console.log('🔍 [CHECK] ===== 예약된 이메일 검사 시작 =====');
            console.log(`🔍 [CHECK] 검사 시간: ${new Date().toLocaleString('ko-KR')}`);
            
            // 토글 상태 확인
            console.log(`🔧 [CHECK] emailSchedulerActive 상태: ${emailSchedulerActive}`);
            if (!emailSchedulerActive) {
                console.log('❌ [CHECK] 예약 메일 발송이 비활성화되어 있습니다.');
                console.log('❌ [CHECK] Settings에서 "예약 메일 발송 관리" 토글을 활성화해야 합니다.');
                return;
            }

            // 예약 리스트 존재 여부 확인
            console.log(`🔧 [CHECK] window.emailScheduleList 존재: ${!!window.emailScheduleList}`);
            if (!window.emailScheduleList) {
                console.log('❌ [CHECK] window.emailScheduleList가 존재하지 않습니다.');
                return;
            }
            
            console.log(`🔧 [CHECK] 전체 예약 개수: ${window.emailScheduleList.length}개`);
            if (window.emailScheduleList.length === 0) {
                console.log('📅 [CHECK] 예약된 이메일이 없습니다.');
                return;
            }

            const now = new Date();
            console.log(`⏰ [CHECK] 현재 시간: ${now.toLocaleString('ko-KR')}`);
            console.log(`⏰ [CHECK] 현재 시간 (timestamp): ${now.getTime()}`);

            // 모든 예약 상태 로그
            window.emailScheduleList.forEach((schedule, index) => {
                console.log(`📋 [CHECK] 예약 ${index + 1}: "${schedule.title}"`);
                console.log(`📋 [CHECK]   - ID: ${schedule.id}`);
                console.log(`📋 [CHECK]   - 상태: ${schedule.status}`);
                console.log(`📋 [CHECK]   - 이번 발송: ${schedule.currentSend}`);
                console.log(`📋 [CHECK]   - 다음 발송: ${schedule.nextSend}`);
                console.log(`📋 [CHECK]   - 주기: ${schedule.frequency}`);
                console.log(`📋 [CHECK]   - 수신자: ${schedule.recipients}`);
            });

            // 활성 상태인 예약만 검사
            const activeSchedules = window.emailScheduleList.filter(schedule => 
                schedule.status === '활성'
            );

            console.log(`🔍 [CHECK] 활성 예약 필터링 결과: ${activeSchedules.length}개`);
            
            if (activeSchedules.length === 0) {
                console.log('📋 [CHECK] 활성 상태인 예약이 없습니다.');
                return;
            }

            // 활성 예약 상세 로그
            activeSchedules.forEach((schedule, index) => {
                console.log(`✅ [CHECK] 활성 예약 ${index + 1}: "${schedule.title}" (ID: ${schedule.id})`);
            });

            for (const schedule of activeSchedules) {
                console.log(`🔄 [PROCESS] 예약 처리 시작: "${schedule.title}" (ID: ${schedule.id})`);
                
                try {
                    // 먼저 발송 시간 도달 여부 검사 (시간 갱신 전에!)
                    console.log(`🔄 [PROCESS] 발송 시간 도달 여부 검사 중... (시간 갱신 전)`);
                    const shouldSend = shouldSendEmailNow(schedule, now);
                    console.log(`🔄 [PROCESS] 발송 여부 결과: ${shouldSend}`);
                    
                    // 발송 후에 시간 갱신 적용
                    console.log(`🔄 [PROCESS] 시간 갱신 검사 중... (발송 검사 후)`);
                    updateScheduleTimeIfNeeded(schedule);
                    
                    if (shouldSend) {
                        console.log(`📧 [SEND] 예약 발송 시작: ${schedule.title} (ID: ${schedule.id})`);
                        
                        // 예약에 따른 이메일 데이터 수집
                        console.log(`📋 [SEND] 이메일 데이터 수집 중...`);
                        const emailData = await collectEmailDataFromSchedule(schedule);
                        
                        if (emailData) {
                            console.log(`✅ [SEND] 이메일 데이터 수집 성공`);
                            console.log(`📧 [SEND] 수신자 ${emailData.allEmails ? emailData.allEmails.length : 0}명`);
                            
                            // 이메일 발송
                            console.log(`📤 [SEND] SMTP 발송 시작...`);
                            await sendEmailViaSMTP(emailData);
                            console.log(`✅ [SEND] SMTP 발송 완료`);
                            
                            // 다음 발송 시간 업데이트
                            console.log(`🔄 [SEND] 다음 발송 시간 업데이트 중...`);
                            updateNextSendTime(schedule);
                            
                            console.log(`🎉 [SEND] 예약 이메일 발송 완료: ${schedule.title}`);
                            
                            // 예약 리스트 팝업이 열려있으면 테이블 새로고침
                            refreshEmailScheduleList();
                            
                            // 성공 로그를 UI에 표시 (옵션)
                            showScheduledEmailNotification(schedule, 'success');
                        } else {
                            console.error(`❌ [SEND] 예약 이메일 데이터 수집 실패: ${schedule.title}`);
                            showScheduledEmailNotification(schedule, 'error');
                        }
                    } else {
                        console.log(`⏰ [PROCESS] 아직 발송 시간이 아님: ${schedule.title}`);
                    }
                } catch (error) {
                    console.error(`❌ [PROCESS] 예약 이메일 발송 실패: ${schedule.title}`, error);
                    showScheduledEmailNotification(schedule, 'error');
                }
            }
        }

        // 현재 시간에 이메일을 발송해야 하는지 검사
        function shouldSendEmailNow(schedule, currentTime) {
            console.log(`🕐 [TIME] 발송 시간 검사: "${schedule.title}"`);
            
            // currentSend 시간을 우선 체크, 없으면 nextSend 사용
            const targetSendTimeStr = schedule.currentSend || schedule.nextSend;
            console.log(`🕐 [TIME] 대상 발송 시간 문자열: "${targetSendTimeStr}"`);
            
            const targetSendTime = parseNextSendTime(targetSendTimeStr);
            console.log(`🕐 [TIME] 파싱된 발송 시간: ${targetSendTime ? targetSendTime.toLocaleString('ko-KR') : 'null'}`);
            
            if (!targetSendTime) {
                console.warn(`⚠️ [TIME] 발송 시간 파싱 실패: ${targetSendTimeStr}`);
                return false;
            }

            // 현재 시간이 예약 시간과 같거나 지났는지 확인 (1분 오차 허용)
            const timeDiff = currentTime.getTime() - targetSendTime.getTime();
            console.log(`🕐 [TIME] 시간 차이: ${timeDiff}ms (${Math.round(timeDiff / 1000)}초)`);
            console.log(`🕐 [TIME] 현재 시간: ${currentTime.toLocaleString('ko-KR')} (${currentTime.getTime()})`);
            console.log(`🕐 [TIME] 발송 시간: ${targetSendTime.toLocaleString('ko-KR')} (${targetSendTime.getTime()})`);
            
            const shouldSend = timeDiff >= 0 && timeDiff < 60000; // 1분 이내
            console.log(`🕐 [TIME] 발송 조건: timeDiff >= 0 (${timeDiff >= 0}) && timeDiff < 60000 (${timeDiff < 60000})`);
            console.log(`🕐 [TIME] 최종 발송 여부: ${shouldSend}`);

            if (shouldSend) {
                console.log(`⏰ [TIME] ✅ 발송 시간 도달: ${schedule.title}`);
                console.log(`⏰ [TIME]   - 이번 발송: ${targetSendTimeStr}`);
                console.log(`⏰ [TIME]   - 현재 시간: ${currentTime.toLocaleString('ko-KR')}`);
            } else {
                console.log(`⏰ [TIME] ❌ 아직 발송 시간 아님: ${schedule.title}`);
                if (timeDiff < 0) {
                    console.log(`⏰ [TIME]   - 발송 예정: ${Math.abs(Math.round(timeDiff / 1000))}초 후`);
                } else {
                    console.log(`⏰ [TIME]   - 발송 시간 지남: ${Math.round(timeDiff / 1000)}초 전`);
                }
            }

            return shouldSend;
        }

        // nextSend 문자열을 Date 객체로 변환 (오전/오후 12시간형식과 24시간형식 모두 지원)
        function parseNextSendTime(nextSendStr) {
            try {
                if (!nextSendStr || typeof nextSendStr !== 'string') return null;

                // 1) "2025. 8. 7. 오전 9:00" 형식
                const ampmPattern = /(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(오전|오후)\s*(\d{1,2}):(\d{2})/;
                const ampmMatch = nextSendStr.match(ampmPattern);
                if (ampmMatch) {
                    const year = parseInt(ampmMatch[1]);
                    const month = parseInt(ampmMatch[2]) - 1;
                    const day = parseInt(ampmMatch[3]);
                    const ampm = ampmMatch[4];
                    let hour = parseInt(ampmMatch[5]);
                    const minute = parseInt(ampmMatch[6]);

                    if (ampm === '오후' && hour !== 12) {
                        hour += 12;
                    } else if (ampm === '오전' && hour === 12) {
                        hour = 0;
                    }
                    return new Date(year, month, day, hour, minute, 0, 0);
                }

                // 2) "2025. 8. 7. 09:00" 형식 (24시간)
                const h24Pattern = /(\d{4})\.\s*(\d{1,2})\.\s*(\d{1,2})\.\s*(\d{1,2}):(\d{2})/;
                const h24Match = nextSendStr.match(h24Pattern);
                if (h24Match) {
                    const year = parseInt(h24Match[1]);
                    const month = parseInt(h24Match[2]) - 1;
                    const day = parseInt(h24Match[3]);
                    const hour = parseInt(h24Match[4]);
                    const minute = parseInt(h24Match[5]);
                    return new Date(year, month, day, hour, minute, 0, 0);
                }

                // 3) 일반 Date 파싱 시도 (fallback)
                const fallback = new Date(nextSendStr);
                if (!isNaN(fallback.getTime())) return fallback;

                return null;
            } catch (error) {
                console.error('nextSend 시간 파싱 오류:', error);
                return null;
            }
        }

        // 예약에서 이메일 데이터 수집
        async function collectEmailDataFromSchedule(schedule) {
            console.log(`📋 예약에서 이메일 데이터 수집: ${schedule.title}`);

            try {
                // 멤버 데이터가 없으면 먼저 로드
                if (!originalMembersData || originalMembersData.length === 0) {
                    console.log('📥 멤버 데이터를 먼저 로드합니다...');
                    const membersData = await getTeamMembers();
                    if (membersData && membersData.teamMembers) {
                        originalMembersData = membersData.teamMembers;
                        console.log(`✅ 멤버 데이터 로드 완료: ${originalMembersData.length}명`);
                    } else {
                        console.error('❌ 멤버 데이터 로드 실패');
                        return null;
                    }
                }

                // 수신자 그룹 파싱
                const recipients = schedule.recipients.split(', ');
                const selectedRecipients = [];
                let allRecipientEmails = [];
                let customEmailList = Array.isArray(schedule.customEmails) ? schedule.customEmails : [];

                // 각 수신자 그룹 처리
                for (const recipient of recipients) {
                    if (recipient === '관리자') {
                        const admins = originalMembersData ? originalMembersData.filter(member => member.role === 'owner') : [];
                        const adminEmails = admins.map(admin => admin.email);
                        allRecipientEmails = allRecipientEmails.concat(adminEmails);
                        selectedRecipients.push('관리자');
                        console.log(`✓ 관리자 ${admins.length}명 추가`);
                    } else if (recipient === '전체 멤버') {
                        const allMembers = originalMembersData ? [...originalMembersData] : [];
                        const allMemberEmails = allMembers.map(member => member.email);
                        allRecipientEmails = allRecipientEmails.concat(allMemberEmails);
                        selectedRecipients.push('전체 멤버');
                        console.log(`✓ 전체 멤버 ${allMembers.length}명 추가`);
                    } else if (recipient === '비활성 멤버') {
                        const inactiveMembers = originalMembersData ? originalMembersData.filter(member => {
                            if (member.spendData) {
                                return member.spendData.premiumRequests === 0;
                            }
                            return true;
                        }) : [];
                        const inactiveMemberEmails = inactiveMembers.map(member => member.email);
                        allRecipientEmails = allRecipientEmails.concat(inactiveMemberEmails);
                        selectedRecipients.push('비활성 멤버');
                        console.log(`✓ 비활성 멤버 ${inactiveMembers.length}명 추가`);
                    } else if (recipient === '직접입력') {
                        // 스케줄에 저장된 직접 입력 이메일 추가
                        if (customEmailList.length > 0) {
                            allRecipientEmails = allRecipientEmails.concat(customEmailList);
                            selectedRecipients.push('직접입력');
                            console.log(`✓ 직접입력 ${customEmailList.length}명 추가`);
                        } else {
                            console.warn('⚠️ 스케줄에 저장된 직접입력 이메일이 없습니다.');
                        }
                    }
                }

                // 중복 이메일 제거
                const uniqueEmails = [...new Set(allRecipientEmails)];
                console.log(`📬 총 수신자 ${uniqueEmails.length}명 (중복 제거 후)`);

                if (uniqueEmails.length === 0) {
                    console.warn('⚠️ 수신자가 없습니다.');
                    return null;
                }

                return {
                    message: schedule.message || '예약된 삼성 AI Experience Group 대시보드 리포트입니다.',
                    selectedGroups: selectedRecipients,
                    customEmails: customEmailList,
                    allEmails: uniqueEmails,
                    timestamp: new Date().toLocaleString('ko-KR'),
                    source: 'scheduled',
                    fromName: (document.getElementById('email-sender-name')?.value || '').trim(),
                    fromEmail: (document.getElementById('email-sender-address')?.value || '').trim(),
                    scheduleId: schedule.id,
                    scheduleTitle: schedule.title,
                    attachmentsSheets: (function(){
                        try {
                            // 스케줄에 저장된 사용량 첨부 옵션과 기간 텍스트가 있는 경우, 가능하면 최신 데이터로 재구성
                            const usageText = (document.getElementById('usage-attachment-period-text')?.textContent || '').trim();
                        const sheets = (schedule.attachmentsSheets && Array.isArray(schedule.attachmentsSheets.sheets))
                            ? schedule.attachmentsSheets.sheets
                            : (window.__attachmentsSheets && Array.isArray(window.__attachmentsSheets.sheets) ? window.__attachmentsSheets.sheets : []);
                            if (sheets.length) {
                                return {
                                    filename: `email_attachments_${new Date().toISOString().split('T')[0]}.xlsx`,
                                    sheets: sheets
                                };
                            }
                            return null;
                        } catch(e){ return null; }
                    })()
                };

            } catch (error) {
                console.error('예약 이메일 데이터 수집 오류:', error);
                return null;
            }
        }

        // 발송 완료 후 시간 업데이트 (이번 발송 → 다음 발송 이동)
        function updateNextSendTime(schedule) {
            const frequency = getFrequencyValue(schedule.frequency);
            const time = getTimeValue(schedule.time);
            
            if (frequency && time) {
                // 현재 시간을 이번 발송 시간으로 설정
                const now = new Date();
                schedule.currentSend = now.toLocaleDateString('ko-KR') + ' ' + now.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
                
                // 새로운 다음 발송 시간 계산 (이번 발송 기준으로 한 주기 후)
                schedule.nextSend = calculateNextSendTimeFromCurrent(schedule.currentSend, frequency);
                
                console.log(`⏰ 발송 완료 후 시간 업데이트: ${schedule.title}`);
                console.log(`   이번 발송: ${schedule.currentSend}`);
                console.log(`   다음 발송: ${schedule.nextSend}`);
                
                // 업데이트된 정보를 저장소에 반영
                saveScheduleUpdatesToStorage(schedule);
            }
        }

        // 이번 발송 기준으로 다음 발송 시간 계산
        function calculateNextSendTimeFromCurrent(currentSendStr, frequency) {
            try {
                // currentSend 시간을 Date 객체로 변환
                const currentSendTime = parseNextSendTime(currentSendStr);
                if (!currentSendTime) {
                    console.error('currentSend 시간 파싱 실패:', currentSendStr);
                    return currentSendStr; // 파싱 실패 시 기존 값 유지
                }

                // 주기에 따라 다음 발송 시간 계산
                const nextSendTime = new Date(currentSendTime);
                switch(frequency) {
                    case 'daily':
                        // 매일: 1일 후
                        nextSendTime.setDate(nextSendTime.getDate() + 1);
                        break;
                    case 'weekly':
                        // 매주: 7일 후
                        nextSendTime.setDate(nextSendTime.getDate() + 7);
                        break;
                    case 'monthly':
                        // 매월: 1개월 후 (정확한 월 계산)
                        const currentMonth = nextSendTime.getMonth();
                        const currentYear = nextSendTime.getFullYear();
                        const currentDay = nextSendTime.getDate();
                        
                        // 다음 달의 같은 날짜로 설정
                        let nextMonth = currentMonth + 1;
                        let nextYear = currentYear;
                        
                        if (nextMonth > 11) {
                            nextMonth = 0;
                            nextYear++;
                        }
                        
                        // 다음 달의 마지막 날을 확인하여 날짜 조정
                        const lastDayOfNextMonth = new Date(nextYear, nextMonth + 1, 0).getDate();
                        const adjustedDay = Math.min(currentDay, lastDayOfNextMonth);
                        
                        nextSendTime.setFullYear(nextYear, nextMonth, adjustedDay);
                        break;
                }

                console.log(`📅 다음 발송 시간 계산: ${frequency} 주기, 현재: ${currentSendTime.toLocaleString('ko-KR')}, 다음: ${nextSendTime.toLocaleString('ko-KR')}`);

                return nextSendTime.toLocaleDateString('ko-KR') + ' ' + nextSendTime.toLocaleTimeString('ko-KR', {hour: '2-digit', minute: '2-digit'});
            } catch (error) {
                console.error('다음 발송 시간 계산 오류:', error);
                return currentSendStr; // 오류 시 기존 값 유지
            }
        }

        // 주기 텍스트를 값으로 변환
        function getFrequencyValue(frequencyText) {
            switch(frequencyText) {
                case '매일': return 'daily';
                case '매주': return 'weekly';
                case '매월': return 'monthly';
                default: return 'weekly';
            }
        }

        // 시간 텍스트를 값으로 변환
        function getTimeValue(timeText) {
            try {
                // "오전 9시 00분" 형태를 "09:00" 형태로 변환
                const match = timeText.match(/(오전|오후)\s*(\d{1,2})시\s*(\d{2})분/);
                if (!match) return '09:00';

                const ampm = match[1];
                let hour = parseInt(match[2]);
                const minute = match[3];

                if (ampm === '오후' && hour !== 12) {
                    hour += 12;
                } else if (ampm === '오전' && hour === 12) {
                    hour = 0;
                }

                return `${hour.toString().padStart(2, '0')}:${minute}`;
            } catch (error) {
                console.error('시간 변환 오류:', error);
                return '09:00';
            }
        }

        // 예약 이메일 발송 알림 표시
        function showScheduledEmailNotification(schedule, type) {
            let message = '';
            let alertType = 'info';

            switch(type) {
                case 'success':
                    message = `✅ 예약 이메일 발송 완료\n\n${schedule.title}\n다음 발송: ${schedule.nextSend}`;
                    alertType = 'success';
                    break;
                case 'error':
                    message = `❌ 예약 이메일 발송 실패\n\n${schedule.title}\n다시 시도하거나 설정을 확인해주세요.`;
                    alertType = 'error';
                    break;
            }

            // 조용한 알림 (콘솔에만 기록, UI 알림은 선택사항)
            console.log(`📢 ${message}`);
            
            // 필요시 UI 알림도 표시
            // showSimpleAlert(message, alertType);
        }

        // 스케줄러 UI 제어 함수
        function toggleEmailScheduler() {
            if (isSchedulerRunning) {
                stopEmailScheduler();
                updateSchedulerUI(false);
                showSimpleAlert('📅 예약 메일 스케줄러가 중지되었습니다.', 'info');
            } else {
                startEmailScheduler();
                updateSchedulerUI(true);
                showSimpleAlert('📅 예약 메일 스케줄러가 시작되었습니다.\n1분마다 활성 예약을 검사합니다.', 'success');
            }
        }

        // 스케줄러 상태 UI 업데이트
        function updateSchedulerUI(isRunning) {
            const statusIndicator = document.getElementById('scheduler-status-indicator');
            const controlBtn = document.getElementById('scheduler-control-btn');

            if (statusIndicator && controlBtn) {
                if (isRunning) {
                    statusIndicator.textContent = '실행 중';
                    statusIndicator.style.backgroundColor = '#4a9eff';
                    controlBtn.textContent = '중지';
                    controlBtn.style.color = '#ff6b35';
                } else {
                    statusIndicator.textContent = '중지됨';
                    statusIndicator.style.backgroundColor = '#5a5a5a';
                    controlBtn.textContent = '시작';
                    controlBtn.style.color = '#e1e1e1';
                }
            }
        }

        // 시간 드롭다운 업데이트 함수
        function updateTimeInput() {
            const hourSelect = document.getElementById('email-hour-select');
            const minuteSelect = document.getElementById('email-minute-select');
            const timeInput = document.getElementById('email-time-input');
            
            if (hourSelect && minuteSelect && timeInput) {
                const hour = hourSelect.value.padStart(2, '0');
                const minute = minuteSelect.value.padStart(2, '0');
                timeInput.value = `${hour}:${minute}`;
                
                console.log(`⏰ 시간 드롭다운 업데이트: ${hour}:${minute}`);
            }
        }

        // 페이지 로드 시 시간 드롭다운 초기화
        function initializeTimeDropdowns() {
            const timeInput = document.getElementById('email-time-input');
            const hourSelect = document.getElementById('email-hour-select');
            const minuteSelect = document.getElementById('email-minute-select');
            
            if (timeInput && hourSelect && minuteSelect) {
                const [hours, minutes] = timeInput.value.split(':');
                hourSelect.value = hours;
                minuteSelect.value = minutes;
                
                console.log(`⏰ 시간 드롭다운 초기화: ${hours}:${minutes}`);
            }
        }

        // 새 예약 모달 시간 드롭다운 업데이트 함수
        function updateNewScheduleTime() {
            const hourSelect = document.getElementById('new-schedule-hour');
            const minuteSelect = document.getElementById('new-schedule-minute');
            const timeInput = document.getElementById('new-schedule-time');
            
            if (hourSelect && minuteSelect && timeInput) {
                const hour = hourSelect.value.padStart(2, '0');
                const minute = minuteSelect.value.padStart(2, '0');
                timeInput.value = `${hour}:${minute}`;
                
                console.log(`⏰ 새 예약 시간 드롭다운 업데이트: ${hour}:${minute}`);
            }
        }

        // 예약 시간 갱신 함수 (이번 발송 시간이 과거인 경우)
        function updateScheduleTimeIfNeeded(schedule) {
            const now = new Date();
            const currentSendTime = parseNextSendTime(schedule.currentSend);
            
            if (!currentSendTime) {
                console.warn(`⚠️ 이번 발송 시간 파싱 실패: ${schedule.currentSend}`);
                return;
            }
            
            // 이번 발송 시간이 현재보다 과거인 경우 갱신
            if (currentSendTime < now) {
                console.log(`⏰ 예약 시간 갱신 필요: ${schedule.title}`);
                console.log(`   현재 시간: ${now.toLocaleString('ko-KR')}`);
                console.log(`   이번 발송 시간: ${currentSendTime.toLocaleString('ko-KR')}`);
                
                // 이번 발송 <- 다음 발송
                schedule.currentSend = schedule.nextSend;
                
                // 다음 발송 <- 다음 발송 + 주기
                const frequency = getFrequencyValue(schedule.frequency);
                if (frequency) {
                    schedule.nextSend = calculateNextSendTimeFromCurrent(schedule.currentSend, frequency);
                }
                
                console.log(`   갱신 후 이번 발송: ${schedule.currentSend}`);
                console.log(`   갱신 후 다음 발송: ${schedule.nextSend}`);
                
                // 갱신된 내용을 window.emailScheduleList에 저장
                saveScheduleUpdatesToStorage(schedule);
                
                // 시간이 갱신되었으므로 팝업도 새로고침
                console.log('🔄 시간 갱신으로 인한 팝업 새로고침 요청');
                refreshEmailScheduleList();
            }
        }
        
        // 예약 정보 업데이트를 저장소에 반영하는 함수
        function saveScheduleUpdatesToStorage(updatedSchedule) {
            if (window.emailScheduleList) {
                const index = window.emailScheduleList.findIndex(s => s.id === updatedSchedule.id);
                if (index !== -1) {
                    window.emailScheduleList[index] = updatedSchedule;
                    console.log(`💾 예약 정보 저장소 업데이트: ${updatedSchedule.title}`);
                }
            }
        }

        // 예약 리스트 팝업 테이블 새로고침 (메일 발송 후 사용)
        function refreshEmailScheduleList() {
            console.log('🔄 [POPUP] ===== 예약 리스트 팝업 테이블 새로고침 시작 =====');
            
            const modal = document.getElementById('email-schedule-modal');
            console.log(`🔄 [POPUP] 모달 존재 여부: ${!!modal}`);
            
            if (modal) {
                console.log('🔄 [POPUP] 예약 리스트 팝업 테이블 새로고침 중...');
                console.log(`🔄 [POPUP] 새로고침 시간: ${new Date().toLocaleString('ko-KR')}`);
                
                // window.emailScheduleList 존재 여부 확인
                console.log(`🔄 [POPUP] window.emailScheduleList 존재: ${!!window.emailScheduleList}`);
                if (window.emailScheduleList) {
                    console.log(`🔄 [POPUP] 예약 개수: ${window.emailScheduleList.length}개`);
                }
                
                // 시간 갱신 적용
                if (window.emailScheduleList) {
                    console.log('🔄 [POPUP] 각 예약에 대해 시간 갱신 적용 중...');
                    window.emailScheduleList.forEach((schedule, index) => {
                        console.log(`🔄 [POPUP] 예약 ${index + 1} 갱신 전:`);
                        console.log(`🔄 [POPUP]   - 제목: ${schedule.title}`);
                        console.log(`🔄 [POPUP]   - 이번 발송: ${schedule.currentSend}`);
                        console.log(`🔄 [POPUP]   - 다음 발송: ${schedule.nextSend}`);
                        
                        updateScheduleTimeIfNeeded(schedule);
                        
                        console.log(`🔄 [POPUP] 예약 ${index + 1} 갱신 후:`);
                        console.log(`🔄 [POPUP]   - 이번 발송: ${schedule.currentSend}`);
                        console.log(`🔄 [POPUP]   - 다음 발송: ${schedule.nextSend}`);
                    });
                }
                
                // 테이블 내용만 업데이트 (모달은 유지)
                const tableContent = document.getElementById('schedule-list-content');
                console.log(`🔄 [POPUP] 테이블 컨텐츠 요소 존재: ${!!tableContent}`);
                
                if (tableContent && window.emailScheduleList) {
                    const scheduleList = window.emailScheduleList;
                    console.log(`🔄 [POPUP] 테이블 업데이트 시작, 예약 개수: ${scheduleList.length}개`);
                    
                    // 각 예약 항목별 HTML 생성 시 로그
                    console.log('🔄 [POPUP] 각 예약별 HTML 생성 중...');
                    scheduleList.forEach((item, index) => {
                        console.log(`🔄 [POPUP] 예약 ${index + 1} HTML 생성:`);
                        console.log(`🔄 [POPUP]   - ID: ${item.id}`);
                        console.log(`🔄 [POPUP]   - 제목: ${item.title}`);
                        console.log(`🔄 [POPUP]   - 상태: ${item.status}`);
                        console.log(`🔄 [POPUP]   - 이번 발송 (HTML용): ${item.currentSend || item.nextSend}`);
                        console.log(`🔄 [POPUP]   - 다음 발송 (HTML용): ${item.nextSend}`);
                    });

                    // 테이블 내용 재생성
                    const newHTML = scheduleList.map(item => `
                        <div class="schedule-item" data-id="${item.id}" data-status="${item.status}" style="
                            display: grid;
                            grid-template-columns: 2fr 1fr 1.2fr 1.2fr 1.5fr 0.8fr 0.8fr 0.8fr;
                            gap: 15px;
                            padding: 15px;
                            border-bottom: 1px solid #3a3a3a;
                            color: #e1e1e1;
                            font-size: 14px;
                            transition: background-color 0.2s ease;
                        " onmouseover="this.style.backgroundColor='#3a3a3a'" onmouseout="this.style.backgroundColor='transparent'">
                            <!-- 제목 (편집 가능) -->
                            <div style="cursor: pointer;" onclick="editField(this, ${item.id}, 'title')">
                                <div class="editable-field" data-field="title" style="font-weight: 600; color: #fff; margin-bottom: 5px;">${item.title}</div>
                                <div style="color: #7a7a7a; font-size: 12px;">${item.message}</div>
                            </div>
                            <!-- 주기 (편집 가능) -->
                            <div style="cursor: pointer;" onclick="editField(this, ${item.id}, 'frequency')">
                                <div class="editable-field" data-field="frequency">${item.frequency}</div>
                            </div>
                            <!-- 이번 발송 (편집 가능) -->
                            <div style="cursor: pointer;" onclick="editField(this, ${item.id}, 'currentSend')">
                                <div class="editable-field" data-field="currentSend" style="color: #ff9800; font-weight: 600;">${item.currentSend || item.nextSend}</div>
                            </div>
                            <!-- 다음 발송 (자동 계산) -->
                            <div class="next-send-time" style="color: #7a7a7a;">${item.nextSend}</div>
                            <!-- 수신자 (편집 가능) -->
                            <div style="cursor: pointer;" onclick="editField(this, ${item.id}, 'recipients')">
                                <div class="editable-field" data-field="recipients">${item.recipients}</div>
                            </div>
                            <div style="text-align: center;">
                                <input type="radio" name="status-${item.id}" value="active" ${item.status === '활성' ? 'checked' : ''} 
                                       onchange="updateScheduleStatus(${item.id}, '활성')" style="
                                    width: 16px;
                                    height: 16px;
                                    accent-color: #4a9eff;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <input type="radio" name="status-${item.id}" value="inactive" ${item.status === '비활성' ? 'checked' : ''} 
                                       onchange="updateScheduleStatus(${item.id}, '비활성')" style="
                                    width: 16px;
                                    height: 16px;
                                    accent-color: #4a9eff;
                                ">
                            </div>
                            <div style="text-align: center;">
                                <button onclick="deleteSchedule(${item.id})" style="
                                    background: none;
                                    border: none;
                                    color: #ff4757;
                                    cursor: pointer;
                                    padding: 4px;
                                    font-size: 16px;
                                    font-weight: bold;
                                ">×</button>
                            </div>
                        </div>
                    `).join('');
                    
                    console.log('🔄 [POPUP] 테이블 innerHTML 업데이트 중...');
                    console.log(`🔄 [POPUP] 기존 innerHTML 길이: ${tableContent.innerHTML.length}`);
                    tableContent.innerHTML = newHTML;
                    console.log(`🔄 [POPUP] 새로운 innerHTML 길이: ${tableContent.innerHTML.length}`);
                    console.log('✅ [POPUP] 테이블 HTML 업데이트 완료!');
                    
                    // 총 개수 업데이트
                    const totalCountElement = modal.querySelector('.pagination-info span');
                    console.log(`🔄 [POPUP] 총 개수 요소 존재: ${!!totalCountElement}`);
                    if (totalCountElement) {
                        const oldCount = totalCountElement.textContent;
                        totalCountElement.textContent = scheduleList.length;
                        console.log(`🔄 [POPUP] 총 개수 업데이트: ${oldCount} → ${scheduleList.length}`);
                    }
                    
                    console.log('✅ [POPUP] 예약 리스트 팝업 테이블 새로고침 완료');
                } else {
                    console.log('❌ [POPUP] 테이블 컨텐츠 요소를 찾을 수 없거나 예약 리스트가 없습니다');
                }
            } else {
                console.log('❌ [POPUP] 예약 리스트 모달이 없어 새로고침하지 않습니다');
            }
            
            console.log('🔄 [POPUP] ===== 예약 리스트 팝업 테이블 새로고침 종료 =====');
        }

        document.addEventListener('DOMContentLoaded', function() {
            
            // 기본 설정 후
            setTimeout(async () => {
                // 드롭다운에서 초기 차트 설정
                const chartSelect = document.getElementById('chartSelect');
                if (chartSelect) {
                    chartSelect.value = 'activity-trend';
                    await switchChart('activity-trend');
                }
                console.log('=== 페이지 로드 시 자동 실제 API 데이터 새로고침 시작 ===');
                await refreshAllRealData(); // 자동 새로고침
                
                // 수신자 수 초기화
                setTimeout(() => {
                    updateRecipientCount();
                }, 2000); // 데이터 로드 후 수신자 수 계산

                // 시간 드롭다운 초기화
                setTimeout(() => {
                    initializeTimeDropdowns();
                    initializeBackupTimeDropdowns();
                }, 1000); // UI 로드 후 시간 드롭다운 초기화

                // 예약 메일 발송 관리 토글 상태 초기화
                setTimeout(() => {
                    const emailToggle = document.querySelector('#settings .toggle-switch');
                    if (emailToggle) {
                        // 기본적으로 활성화 상태로 시작
                        emailToggle.classList.remove('off');
                        emailSchedulerActive = true;
                        console.log('📅 예약 메일 발송 관리 토글 초기화: 활성화 상태');
                        
                        // 스케줄러 시작
                        startEmailScheduler();

                        // 초기 표시 상태 적용
                        const freqEl = document.getElementById('email-frequency-setting');
                        const timeEl = document.getElementById('email-time-setting');
                        if (freqEl) freqEl.style.display = '';
                        if (timeEl) timeEl.style.display = '';
                    }

                    // 자동 백업 토글은 기본 비활성 상태 유지, 표시 상태만 초기화
                    const backupToggleItem = Array.from(document.querySelectorAll('#settings .setting-item'))
                        .find(item => item.querySelector('.setting-label') && item.querySelector('.setting-label').textContent.trim() === '자동 백업');
                    if (backupToggleItem) {
                        const toggle = backupToggleItem.querySelector('.toggle-switch');
                        if (toggle && toggle.classList.contains('off')) {
                            handleBackupToggle(false);
                        }
                    }

                    // 첨부 리스트 초기 렌더링
                    setTimeout(() => {
                        renderAttachmentMemberLists();
                        // Export 범위 초기 표시 상태 동기화
                        // Export 종류 초기 상태: 모두 미선택
                        ['export-type-summary','export-type-raw','export-type-members','export-type-all'].forEach(id => {
                            const el = document.getElementById(id);
                            if (el) el.checked = false;
                        });
                        handleExportTypeCheckboxChange();
                        // Export 형식 옵션 초기 표시 상태 동기화
                        const exportFormat = document.getElementById('export-format-select');
                        if (exportFormat) handleExportFormatChange(exportFormat.value);
                    }, 500);
                }, 3000); // 데이터 로드 완료 후 토글 상태 초기화
            }, 100);
        });

        // ===== 편집 가능한 테이블 관련 함수들 =====
        
        // 임시 저장용 변수 (사용자가 저장을 누르기 전까지의 변경사항 저장)
        let tempScheduleChanges = {};
        
        // 필드 편집 함수
        function editField(element, scheduleId, fieldName) {
            console.log(`📝 [EDIT] 필드 편집 시작: ID=${scheduleId}, 필드=${fieldName}`);
            
            // 이미 편집 중인 다른 필드가 있으면 종료
            const existingInput = document.querySelector('.editing-input');
            if (existingInput) {
                existingInput.blur();
                return;
            }
            
            // 올바른 편집 대상 요소 찾기
            let editableElement;
            if (element.querySelector) {
                // 클릭된 요소 내에서 해당 필드의 편집 가능한 요소 찾기
                editableElement = element.querySelector(`[data-field="${fieldName}"]`);
                if (!editableElement) {
                    // fallback: 일반적인 editable-field 찾기
                    editableElement = element.querySelector('.editable-field');
                }
            } else {
                editableElement = element;
            }
            
            if (!editableElement) {
                console.warn(`⚠️ [EDIT] 편집 대상 요소를 찾을 수 없습니다: ${fieldName}`);
                return;
            }
            
            const currentValue = editableElement.textContent.trim();
            console.log(`📝 [EDIT] 현재 값: "${currentValue}"`);
            
            // 편집 UI 생성
            let inputElement;
            
            if (fieldName === 'frequency') {
                // 주기는 드롭다운으로 (기존 발송 주기와 동일한 옵션)
                inputElement = document.createElement('select');
                inputElement.innerHTML = `
                    <option value="daily" ${currentValue === 'daily' || currentValue === '매일' ? 'selected' : ''}>매일</option>
                    <option value="weekly" ${currentValue === 'weekly' || currentValue === '매주' ? 'selected' : ''}>매주</option>
                    <option value="monthly" ${currentValue === 'monthly' || currentValue === '매월' ? 'selected' : ''}>매월</option>
                `;
                inputElement.style.cssText = `
                    background: #2a2a2a;
                    color: #fff;
                    border: 1px solid #4a9eff;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 14px;
                    width: 100%;
                `;
                
                // 드롭다운 클릭 시 이벤트 전파 방지
                inputElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                
                // 드롭다운 변경 시 편집 완료
                inputElement.addEventListener('change', function(e) {
                    e.stopPropagation();
                    finishEdit();
                });
            } else if (fieldName === 'currentSend') {
                // 이번 발송은 datetime-local 입력
                inputElement = document.createElement('input');
                inputElement.type = 'datetime-local';
                
                // 현재 값을 datetime-local 형식으로 변환
                const dateValue = parseNextSendTime(currentValue);
                if (dateValue) {
                    // UTC 시간을 로컬 시간으로 변환하여 datetime-local 형식으로 설정
                    const year = dateValue.getFullYear();
                    const month = String(dateValue.getMonth() + 1).padStart(2, '0');
                    const day = String(dateValue.getDate()).padStart(2, '0');
                    const hours = String(dateValue.getHours()).padStart(2, '0');
                    const minutes = String(dateValue.getMinutes()).padStart(2, '0');
                    inputElement.value = `${year}-${month}-${day}T${hours}:${minutes}`;
                }
                
                inputElement.style.cssText = `
                    background: #2a2a2a;
                    color: #fff;
                    border: 1px solid #4a9eff;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 14px;
                    width: 100%;
                `;
                
                // datetime-local 클릭 시 이벤트 전파 방지
                inputElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
                // 값 변경 시 즉시 완료 처리 (날짜/시간 변경 모두 반영)
                inputElement.addEventListener('change', function(e) {
                    e.stopPropagation();
                    finishEdit();
                });
            } else {
                // 기본 텍스트 입력
                inputElement = document.createElement('input');
                inputElement.type = 'text';
                inputElement.value = currentValue;
                inputElement.style.cssText = `
                    background: #2a2a2a;
                    color: #fff;
                    border: 1px solid #4a9eff;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: 14px;
                    width: 100%;
                `;
                
                // 텍스트 입력 클릭 시 이벤트 전파 방지
                inputElement.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            inputElement.className = 'editing-input';
            
            // 편집 완료 처리
            function finishEdit() {
                let newValue;
                
                if (fieldName === 'currentSend' && inputElement.value) {
                    // datetime-local 값을 안정적으로 한국어 날짜 + 24시간 형식으로 변환 (타임존 영향 제거)
                    const match = inputElement.value.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})$/);
                    if (match) {
                        const year = parseInt(match[1], 10);
                        const month = parseInt(match[2], 10) - 1;
                        const day = parseInt(match[3], 10);
                        const hour = match[4];
                        const minute = match[5];
                        const datePart = new Date(year, month, day).toLocaleDateString('ko-KR'); // 예: "2025. 8. 7."
                        newValue = `${datePart} ${hour}:${minute}`; // 예: "2025. 8. 7. 09:30"
                    } else {
                        // 예외적으로 포맷이 다를 경우의 안전 장치
                        newValue = inputElement.value.replace('T', ' ').replace(/-/g, '. ');
                    }
                } else if (fieldName === 'frequency') {
                    // 주기 값은 드롭다운의 텍스트로 변환
                    const selectedOption = inputElement.options[inputElement.selectedIndex];
                    newValue = selectedOption.text; // "매일", "매주", "매월"
                } else {
                    newValue = inputElement.value.trim();
                }
                
                if (newValue && newValue !== currentValue) {
                    console.log(`📝 [EDIT] 값 변경: "${currentValue}" → "${newValue}"`);
                    console.log(`📝 [EDIT] 필드명: ${fieldName}, 스케줄ID: ${scheduleId}`);
                    
                    // 임시 변경사항 저장
                    if (!tempScheduleChanges[scheduleId]) {
                        tempScheduleChanges[scheduleId] = {};
                    }
                    tempScheduleChanges[scheduleId][fieldName] = newValue;
                    
                    // 주기나 이번 발송이 변경되었을 때 다음 발송 자동 계산
                    if (fieldName === 'frequency' || fieldName === 'currentSend') {
                        calculateAndUpdateNextSend(scheduleId);
                    }
                    
                    // UI 업데이트 - 올바른 필드 찾기
                    const scheduleRow = document.querySelector(`[data-id="${scheduleId}"]`);
                    console.log(`📝 [EDIT] 스케줄 행 찾기: ${!!scheduleRow}`);
                    if (scheduleRow) {
                        const targetElement = scheduleRow.querySelector(`[data-field="${fieldName}"]`);
                        console.log(`📝 [EDIT] 대상 요소 찾기: ${!!targetElement}, 선택자: [data-field="${fieldName}"]`);
                        if (targetElement) {
                            targetElement.textContent = newValue;
                            targetElement.style.backgroundColor = '#3a4a3a'; // 변경됨 표시
                            console.log(`📝 [EDIT] UI 업데이트 완료: ${fieldName} = ${newValue}`);
                        } else {
                            console.warn(`⚠️ [EDIT] 대상 필드를 찾을 수 없습니다: ${fieldName}`);
                            // 디버깅을 위해 모든 data-field 요소 출력
                            const allDataFields = scheduleRow.querySelectorAll('[data-field]');
                            console.log(`📝 [EDIT] 사용 가능한 data-field 요소들:`, Array.from(allDataFields).map(el => el.getAttribute('data-field')));
                        }
                    }
                    
                    // 원래 편집 요소도 업데이트 (fallback)
                    if (editableElement) {
                        editableElement.textContent = newValue;
                        editableElement.style.backgroundColor = '#3a4a3a';
                        console.log(`📝 [EDIT] 원래 요소 업데이트 완료: ${fieldName} = ${newValue}`);
                    }
                    
                    console.log(`📝 [EDIT] 임시 변경사항 저장 완료`);
                }
                
                // 입력 필드를 원래 요소로 복원
                const scheduleRow = document.querySelector(`[data-id="${scheduleId}"]`);
                if (scheduleRow) {
                    const targetElement = scheduleRow.querySelector(`[data-field="${fieldName}"]`);
                    if (targetElement) {
                        targetElement.style.display = 'block';
                    }
                }
                inputElement.remove();
            }
            
            // 이벤트 리스너 추가 (드롭다운은 change 이벤트로 처리되므로 blur 이벤트 제외)
            if (fieldName !== 'frequency') {
                inputElement.addEventListener('blur', finishEdit);
            }
            inputElement.addEventListener('keydown', function(e) {
                if (e.key === 'Enter') {
                    finishEdit();
                } else if (e.key === 'Escape') {
                    editableElement.style.display = 'block';
                    inputElement.remove();
                }
            });
            
            // 기존 요소 숨기고 입력 필드 표시
            editableElement.style.display = 'none';
            editableElement.parentNode.insertBefore(inputElement, editableElement.nextSibling);
            inputElement.focus();
            
            if (inputElement.type === 'text') {
                inputElement.select();
            }
        }
        
        // 다음 발송 시간 자동 계산 및 업데이트
        function calculateAndUpdateNextSend(scheduleId) {
            console.log(`🔄 [CALC] 다음 발송 시간 계산 시작: ID=${scheduleId}`);
            
            const changes = tempScheduleChanges[scheduleId];
            if (!changes) return;
            
            // 현재 스케줄 찾기
            const currentSchedule = window.emailScheduleList.find(s => s.id == scheduleId);
            if (!currentSchedule) return;
            
            // 변경된 주기와 이번 발송 시간 가져오기
            const frequency = changes.frequency || currentSchedule.frequency;
            const currentSend = changes.currentSend || currentSchedule.currentSend || currentSchedule.nextSend;
            
            console.log(`🔄 [CALC] 계산 기준: 주기=${frequency}, 이번발송=${currentSend}`);
            
            // 주기 값 변환
            const frequencyValue = getFrequencyValue(frequency);
            if (!frequencyValue) {
                console.warn(`⚠️ [CALC] 유효하지 않은 주기: ${frequency}`);
                return;
            }
            
            // 다음 발송 시간 계산
            const nextSend = calculateNextSendTimeFromCurrent(currentSend, frequencyValue);
            console.log(`🔄 [CALC] 계산 결과: 다음발송=${nextSend}`);
            
            // 임시 변경사항에 다음 발송 시간 저장
            changes.nextSend = nextSend;
            
            // UI에서 다음 발송 시간 업데이트 (정확한 선택자 사용)
            const scheduleRow = document.querySelector(`[data-id="${scheduleId}"]`);
            if (scheduleRow) {
                const nextSendDiv = scheduleRow.querySelector('.next-send-time');
                if (nextSendDiv) {
                    nextSendDiv.textContent = nextSend;
                    nextSendDiv.style.backgroundColor = '#3a4a3a'; // 변경됨 표시
                    console.log(`🔄 [CALC] 다음 발송 시간 UI 업데이트 완료: ${nextSend}`);
                } else {
                    console.warn(`⚠️ [CALC] 다음 발송 시간 div를 찾을 수 없습니다`);
                }
            }
            
            console.log(`✅ [CALC] 다음 발송 시간 계산 및 UI 업데이트 완료`);
        }
        
        // 모든 변경사항 저장
        function saveScheduleChanges() {
            console.log(`💾 [SAVE] 변경사항 저장 시작`);
            console.log(`💾 [SAVE] 임시 변경사항:`, tempScheduleChanges);
            
            let savedCount = 0;
            
            // 각 변경된 스케줄에 대해 처리
            for (const scheduleId in tempScheduleChanges) {
                const changes = tempScheduleChanges[scheduleId];
                const scheduleIndex = window.emailScheduleList.findIndex(s => s.id == scheduleId);
                
                if (scheduleIndex !== -1) {
                    // 변경사항을 실제 데이터에 적용
                    Object.assign(window.emailScheduleList[scheduleIndex], changes);
                    savedCount++;
                    
                    console.log(`💾 [SAVE] 스케줄 ${scheduleId} 저장 완료:`, changes);
                } else {
                    console.warn(`⚠️ [SAVE] 스케줄을 찾을 수 없습니다: ID=${scheduleId}`);
                }
            }
            
            if (savedCount > 0) {
                // 변경사항 초기화
                tempScheduleChanges = {};
                
                // UI에서 변경됨 표시 제거
                document.querySelectorAll('.schedule-item div[style*="background-color: rgb(58, 74, 58)"]').forEach(element => {
                    element.style.backgroundColor = '';
                });
                
                // 테이블 새로고침
                refreshEmailScheduleList();
                
                // 성공 메시지
                showSimpleAlert(`✅ ${savedCount}개의 예약 변경사항이 저장되었습니다!`, 'success');
                
                console.log(`✅ [SAVE] 총 ${savedCount}개 스케줄 저장 완료`);
            } else {
                showSimpleAlert('ℹ️ 저장할 변경사항이 없습니다.', 'info');
                console.log(`ℹ️ [SAVE] 저장할 변경사항 없음`);
            }
        }

    </script>
</body>
</html>